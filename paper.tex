%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{fancyvrb}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}
\newcommand{\sorry}{\textcolor{red}{\textbf{sorry}}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{TODO \arabic{todos}: #1}}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

% Math
\newcommand{\nats}{\mathbb{N}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{:}
\newcommand{\linl}[1]{\ms{inl}\;{#1}}
\newcommand{\linr}[1]{\ms{inr}\;{#1}}
\newcommand{\labort}[1]{\ms{abort}\;{#1}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2;\;#3}}
\newcommand{\caseexpr}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\lbrb}[2]{\brb{\lbl{#1}}{#2}}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\casestmt}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\where}[2]{#1\;\ms{where}\;#2}
\newcommand{\wbranch}[3]{#1(#2) \lto \{#3\}}
\newcommand{\lwbranch}[3]{\wbranch{\lbl{#1}}{#2}{#3}}
\newcommand{\cfgsubst}[1]{\ms{cfgs}\;\{#1\}}
\newcommand{\wseq}[2]{{#1} \mathbin{{;}{;}} {#2}}

% Judgements
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[2]{#1 \rightsquigarrow #2}
\newcommand{\thyp}[3]{#1 : {#2}^{#3}}
\newcommand{\bhyp}[2]{#1 : #2}
\newcommand{\lhyp}[2]{#1(#2)}
\newcommand{\llhyp}[2]{\lhyp{\lbl{#1}}{#2}}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\hasty}[4]{#1 \vdash_{#2} #3: {#4}}
\newcommand{\haslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\isop}[4]{#1 \in \mc{I}_{#4}(#2, #3)}
\newcommand{\issubst}[3]{#1: #2 \mapsto #3}
\newcommand{\lbsubst}[3]{#1: #2 \rightsquigarrow #3}
\newcommand{\teqv}{\approx}
\newcommand{\tmeq}[5]{#1 \vdash_{#2} #3 \teqv #4 : {#5}}
\newcommand{\lbeq}[4]{#1 \vdash #2 \teqv #3 : {#4}}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}

% Branding
\newcommand{\isotopessa}{\(\lambda_{\ms{SSA}}\)}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{The Denotational Semantics of SSA}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\begin{abstract}
  ...
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

\section{Introduction}

Static single assignment form, or SSA form, has been the dominant
compiler intermediate representation since its introduction by
\citet{ssa-intro} in the later 1980s. Every major compiler -- GCC, Clang,
MLIR, Cranelift -- uses this representation, because it makes many
optimizations much easier to do than traditional 3-address code IRs.

The key idea behind SSA is to adapt an idea from functional
programming: namely, every variable is defined only once. This means
that substitution is unconditionally valid, without first requiring a
dataflow analysis to compute where definitions reach. Unlike in
functional programming, though, scoping of definitions in SSA is
traditionally not lexical. Instead, scoping is determined by
\emph{dominance}: every variable occurence must be dominated by a
single assignment in the control flow graph.

The semantics of SSA has traditionally been handled quite informally,
because conceptually, it is a simple first-order imperative
programming language. As a result, whether a rewrite is sound or
not is usually obvious, without having to do a complex correctness
argument.

Unfortunately, computers are no longer as simple as they were in the
late 1980s. Modern computers are typically multicore, and feature many
levels of caching, and as a result the semantics of memory is no
longer correctly modelled as a big array of bytes. Finding good
semantics for modern weak memory systems remains an ongoing challenge.

As a result, it is not correct to justify compiler optimizations in
terms of a simple imperative model, and it is an open question which
equations should hold of an SSA program. This is a particularly
fraught question, because it is also unclear which equations weak
memory models should satisfy.

What we would like to know is which equations any SSA representation
should satisfy. This would let us establish a contract between
compiler writers and hardware designers. The compiler writers could
rely upon the equational theory of SSA when justifying optimizations,
without needing to know all the details of the memory model at all
times.  Conversely, memory models could be validated by seeing if they
satisfy the equations of SSA, without needing to study every possible
compiler optimization.

Concretely, our contributions are as follows: 

\begin{itemize}
\item First, we give a type-theoretic presentation of SSA, with both typing rules and an equational
  theory for well-typed terms. We also prove the correctness of suitable substitution properties for
  this calculus. 
  
\item Next, we give a categorical semantics for this type theory, in terms of distributive Elgot
  categories. We show that any denotational model with this categorical structure is also a model of
  SSA. This shows that all of the equations we give are sound with respect to the categorical
  structure. 

\item We also show that syntax quotiented by the equational theory yields the initial distributive
  Elgot category. This establishes that our set of syntactic equations is complete, and that there
  are no equations which the denotational semantics validates, but which cannot be proved
  syntactically. 

\item We show that this denotational axiomatization is useful in practice, by giving a variety of
  concrete models, including a model of TSO weak memory based on~\cite{sparky}. This demonstrates
  that it is possible to give realistic weak memory models which do not disturb the structure of SSA
  in fundamental ways.

\item Finally, we have substantially mechanized our proofs using the Lean 4 proof assistant. We have
  mechanized proofs of substitution for our type theory, as well as proofs that the syntax forms the
  initial model, and that the SPARC TSO semantics forms a valid model of SSA. The denotational
  semantics and its proof of the soundness of substitution are done on paper. 

\end{itemize}

\section{Static Single Assignment Form}

In this section, we will describe SSA form and the isomorphism between the standard $\phi$-node
based presentation and the more functional basic-blocks with arguments format. We will then discuss
standard dominance-based scoping, and how this can be recast as lexical scoping to make it more
amenable to standard type-theoretic treatment. We will then generalize this format to allow
branching to arbitrary code, rather than only labels, to obtain \textit{A-normal form}, or ANF
\cite{flanagan-93-anf}, analogously to~\citet{chakravarty-functional-ssa-2003}; a straightforward
argument shows that this adds no expressive power. Finally, to allow for substitution, we will
further generalize our syntax to allow for arbitrary expression nesting, as well as let-expressions,
to obtain \textit{type-theoretic SSA}, or \isotopessa, which will be the subject of the rest of this
paper.

As a running example, consider the simple imperative program to compute $10!$ given in
Figure~\ref{fig:fact-program}. 

\TODO{3 address code was one of the first IRs; cite Frances Allen? Perhaps also cite
\cite{allen-70-cfa} for dominance lore?}

Operating directly on an imperative language can be challenging, since having a uniform
representation of code friendly to mechanized optimization and analysis is often in tension with
features designed to improve readability and programmer productivity, such as syntax sugar. We might
therefore normalize our code into \textit{3-address code}, as in Figure~\ref{fig:fact-3addr}, by
doing the following:
\begin{itemize}
  \item Converting structured control flow in terms of (e.g.) \ms{while} to unstructured jumps
  between the basic blocks \ms{start} (the entry block), \ms{loop}, and \ms{body}, which now have
  explicit labels. 
  \item Replacing subexpressions like $i + 1$ in $a * (i + 1)$ with let-bindings, so that every
  expression in our program is atomic. 
\end{itemize}

\begin{figure}
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{let\;mut}\;i = 1; \\
      & \ms{let\;mut}\;a = 1; \\
      & \ms{while}\;i_0 < n\;\{ \\
      & \quad a = a * (i + 1) \\
      & \quad i = i + 1; \\
      & \} \\
      & \ms{ret}\;a \\
    \end{align*}
    \caption{As an imperative program}
    \label{fig:fact-imp}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      \ms{start}:\quad  & \ms{let}\;n = 10; \\
                        & \ms{let\;mut}\;i = 1; \\
                        & \ms{let\;mut}\;a = 1; \\
                        & \ms{br}\;\ms{loop} \\
      \ms{loop}: \quad  & \ms{if}\;i < n\;
                          \{\;\ms{br}\;\ms{body}\;\}\;
                          \ms{else}\;\{\;\ms{ret}\;a\;\} \\
      \ms{body}: \quad  & \ms{let}\;t = i + 1; \\
                        & a = a * t; \\
                        & i = i + 1; \\
                        & \ms{br}\;\ms{loop}
    \end{align*}
    \caption{As 3-address code}
    \label{fig:fact-3addr}
  \end{subfigure}
  \caption{
    A simple, slightly suboptimal program to compute $10!$ via multiplication in a loop, represented
    as typical imperative code and in 3-address code.
  }
  \Description{}
  \label{fig:fact-program}
\end{figure}

\TODO{better segue}

Unfortunately, many optimizations are still quite difficult to express in this format, since a
variable's value may have been set by many different definitions throughout the execution of the
program. To improve our ability to reason about programs, we introduce the \textit{static-single
assignment} restriction, which says that every variable must be defined at exactly one point in the
program. We can intuitively represent this as every variable being given by an immutable
\ms{let}-binding.

\TODO{a bit more SSA history; \citet{ssa-intro} again; also look at \citet{ssa-original}}

\todo{Explain why SSA is useful -- i.e., say substitution, even though it is not totally true\ldots}

It is difficult to express programs with loops in this format, since the value of a
variable may change on each iteration of the loop. The classical solution to this issue is to
introduce \textit{$\phi$-nodes}, which evaluate to a different value depending on which block we
\textit{previously} came from. For example, in basic block \ms{loop} in
Figure~\ref{fig:fact-ssa}, $i_0$ evaluates to 1 if we came from \ms{start}, and to $i_1$ if we
came from \ms{body}. Similarly, $a_0$ evaluates to 1 if we came from \ms{start}, and to $a_1$ if we
came from \ms{body}. This allows us to express the fact that the values of $i_0, a_0$ are
control-flow dependent while still maintaining the single-definition principle (as otherwise, we
would need a new definition for $i$ overriding the old one).

Note, however that $i_1, a_0$ are defined \textit{later} in the program than the
$\phi$-nodes $i_0, a_0$, which would normally be seen as using an undefined
value. We hence need to use the rather confusing scoping rule that the variables
in a branch of a $\phi$-node must be defined \textit{at the end of the source
basic block for that branch}, even if they are undefined when coming from other blocks. This in
general makes giving SSA an operational semantics quite confusing, and with much
time spent in compilers courses trying to build up the requisite intuition.

\begin{figure}
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      \ms{start}:\quad  & \ms{let}\;n = 10; \\
                        & \ms{let\;mut}\;i = 1; \\
                        & \ms{let\;mut}\;a = 1; \\
                        & \ms{br}\;\ms{loop} \\
      \ms{loop}: \quad  & \ms{if}\;i < n\;
                          \{\;\ms{br}\;\ms{body}\;\}\;
                          \ms{else}\;\{\;\ms{ret}\;a\;\} \\
      \ms{body}: \quad  & \ms{let}\;t = i + 1; \\
                        & a = a * t; \\
                        & i = i + 1; \\
                        & \ms{br}\;\ms{loop}
    \end{align*}
    \caption{3-address code}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      \ms{start}:\quad & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop} \\
      \ms{loop}: \quad  & \ms{let}\;i_0 = \phi(\ms{start}: 1, \ms{body}: i_1) \\
                        & \ms{let}\;a_0 = \phi(\ms{start}: 1, \ms{body}: a_1) \\
                        & \ms{if}\;i_0 < n\;
                          \{\;\ms{br}\;\ms{body}\;\}\;
                          \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
      \ms{body}: \quad  & \ms{let}\;t = i_0 + 1 \\
                        & \ms{let}\;a_1 = a_0 * t \\
                        & \ms{let}\;i_1 = i_0 + 1 \\
                        & \ms{br}\;\ms{loop}
    \end{align*}
    \caption{Converted to SSA form}
    \label{fig:fact-ssa}
  \end{subfigure}
  \todo{add diagram showing correspondence between $\phi$-nodes and mutable bindings?}
  \caption{
    Conversion of three address code for the program in Figure~\ref{fig:fact-program} to SSA 
    form, requring the insertion of $\phi$-nodes for $i$ and $a$ due to control-flow dependent
    updates. Note how SSA-form can be viewed as ``three address code in which all 
    \ms{let}-bindings are immutable.''
  }
  \Description{}
\end{figure}

One solution to this issue is to transition to an isomorphic syntax called basic blocks with
arguments (BBA), as illustrated in Figure \ref{fig:fact-bba}. In this approach, each $\phi$-node,
which lacks side effects and whose scope depends solely on the originating basic blocks rather than
its position within its own block, can be moved to the top of the block. This reorganization allows
us to treat each $\phi$-node as equivalent to an argument for the basic block, with the
corresponding values passed at the jump site. Conversely, converting a program from BBA format back
to standard SSA form with $\phi$-nodes is straightforward: introduce a $\phi$-node for each argument
of a basic block, and then, for each branch corresponding to the $\phi$-node, add an argument to the
jump instruction from the appropriate source block. 

\begin{figure}
  \begin{subfigure}[t]{.5\textwidth}
    \centering
    \begin{align*}
      \ms{start}:\quad  & \ms{let}\;n = 10; \\
                        & \ms{br}\;\ms{loop} \\
      \ms{loop}: \quad  & \begingroup \color{red}
                          \ms{let}\;i_0 = \phi(\ms{start}: 1, \ms{body}: i_1) 
                          \endgroup \\
                        & \begingroup \color{blue}
                          \ms{let}\;a_0 = \phi(\ms{start}: 1, \ms{body}: a_1) 
                          \endgroup \\
                        & \ms{if}\;i_0 < n\;\{\;\ms{br}\;\ms{body}\;\} \\
                        & \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
      \ms{body}: \quad  & \ms{let}\;t = i_0 + 1 \\
                        & \ms{let}\;a_1 = a_0 * t \\
                        & \ms{let}\;i_1 = i_0 + 1 \\
                        & \ms{br}\;\ms{loop}
    \end{align*}
    \caption{With $\phi$-nodes}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\textwidth}
    \centering
    \begin{align*}
      \ms{start}:\quad            & \ms{let}\;n = 10; \\
                                  & \ms{br}\;\ms{loop}(\textcolor{red}{1}, \textcolor{blue}{1}) \\
      \ms{loop}(\textcolor{red}{i_0}, \textcolor{blue}{a_0}): \quad  
                                  & \ms{if}\;i_0 < n\; \{\;\ms{br}\;\ms{body}\;\} \\
                                  & \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
      \ms{body}: \quad            & \ms{let}\;t = i_0 + 1 \\
                                  & \ms{let}\;a_1 = a_0 * t \\
                                  & \ms{let}\;i_1 = i_0 + 1 \\
                                  & \ms{br}\;\ms{loop}(\textcolor{red}{i_1}, \textcolor{blue}{a_1}) 
                                  \\ \\
    \end{align*}
    \caption{Basic-blocks with arguments}
    \label{fig:fact-bba}
  \end{subfigure}

  \TODO{Add arrows with \texttt{tikzmark}?}
  
  \caption{
    The program in Figure \ref{fig:fact-program} written in standard SSA (using $\phi$ nodes),
    like in LLVM \cite{llvm}, and in basic-blocks with arguments SSA, like in MLIR \cite{mlir} and
    Cranelift \cite{cranelift}. The arguments $i_0, a_0$ corresponding to the $\phi$-nodes $i_0,
    a_0$ are colored in \textcolor{red}{red} and \textcolor{blue}{blue}, respectively.
  }

  \Description{}
\end{figure}

An important insight provided by the BBA format, as discussed in \citet{appel-ssa}, is that a
program in SSA form may be interpreted as a collection of tail-recursive functions, where each
basic-block and branch correspond to a function and tail call respectively. This interpretation
offers a natural framework for defining the semantics of SSA and reasoning about optimizations.
However, there is a subtle difference between the scoping rules in this format and the actual
scoping used in traditional SSA, which requires careful consideration.

\TODO{Cite \citet{kelsey-95-cps} in paragraph above?}

In particular, while functional languages typically rely on \textit{lexical scoping}, where the
scope of a variable is determined by its position within the code's nested structure, SSA form
introduces a different scoping mechanism based on dominance. In SSA, a variable is considered to be
in scope at a specific point $P$ if and only if all execution paths from the program's entry point
to that point pass through the variable's unique definition $D$. In this case, we say that $P$ is
\textit{strictly dominated} by $D$.

When considering basic blocks, this translates to a variable being visible within the block $D$
where it is defined, starting from the point of its definition, and continuing to be visible in all
subsequent blocks $P$ strictly dominated by $D$ in the control-flow graph. For example, in
Figure~\ref{fig:fact-bba},
\begin{itemize}
  \item \ms{start} strictly dominates \ms{loop} and \ms{body}; so, for example, the variable $n$
  defined in \ms{start} is visible in \ms{loop}
  \item \ms{loop} strictly dominates \ms{body}, so the parameterts $i_0, a_0$ to \ms{loop} are
  visible, rather than needing to be passed in as parameters themselves as well
  \item \ms{body} does \textit{not} strictly dominate \ms{loop}, since there is trivially a path
  from \ms{start} to \ms{loop} which does not go through \ms{body}
\end{itemize}

In general, the relation ``$A$ strictly dominates $B$'' intersected with the relation ``$A$ jumps
directly to $B$'' (i.e. ``$A$ is a \textit{direct predecessor} of $B$'') forms a tree, called the
\textit{dominance tree} of the control-flow graph. This tree can be computed in nearly linear time
in the size of the CFG \cite{ssa-intro}. If we topologically sort the basic blocks in a CFG by the
corresponding partial order on blocks, we can insert brackets according to the dominance tree such
that a variable is in lexical scope if and only if it is in scope under dominance-based scoping, as
shown in Figure~\ref{fig:dominance-to-lexical}. This is a simple transformation, and it is easy to
see that it forms an isomorphism, as standard SSA can be recovered by simply removing the inserted
``\ms{where}-blocks."

\begin{figure}
  \centering
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      \ms{start}:\quad            & \ms{let}\;n = 10; \\
                                  & \ms{br}\;\ms{loop}(1, 1) \\
      \ms{loop}(i_0, a_0): \quad  & \ms{if}\;i_0 < n\; \{\;\ms{br}\;\ms{body}\;\} \\
                                  & \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
      \ms{body}: \quad            & \ms{let}\;t = i_0 + 1 \\
                                  & \ms{let}\;a_1 = a_0 * t \\
                                  & \ms{let}\;i_1 = i_0 + 1 \\
                                  & \ms{br}\;\ms{loop}(i_1, a_1) \\ \\ \\ \\ 
    \end{align*}
    \caption{Dominance-based scoping}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}(1, 1) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{ \\
      & \quad \ms{if}\;i_0 < n\;\{\;\ms{br}\;\ms{body}\;\} \\
      & \quad \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
      & \quad \ms{where}\;\ms{body}: \{\\ 
      & \qquad \ms{let}\;t = i_0 + 1 \\
      & \qquad \ms{let}\;a_1 = a_0 * t \\
      & \qquad \ms{let}\;i_1 = i_0 + 1 \\
      & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
      & \quad \} \\
      & \}
    \end{align*}
    \caption{Lexical scoping}
  \end{subfigure}
  \caption{Conversion of an SSA program from dominance-based scoping to explicit lexical scoping}
  \Description{}
  \label{fig:dominance-to-lexical}
\end{figure}

\TODO{rework below:}

Lexical scoping allows us to apply many of the techniques developed in theoretical computer science
and functional programming for reasoning about and developing optimizations and analysis passes. In
particular, the result of our conversion to lexical scoping looks a lot like the correspondence
between CPS and SSA described in \citet{kelsey-95-cps}. In particular, we can now begin to develop
an \textit{equational theory} for SSA programs to reason about complex rewriting operations in a
compositional way. In particular, we'd like to be able to reason about:
\begin{itemize}
  \item \textit{Control-flow rewrites}, such as jump-threading or fusing two identical branches of
  an \ms{if}-statement
  \item \textit{Algebraic rewrites}, such as simplifying arithmetic expressions
  \item Combinations of the two, such as rewriting $\ms{if}\;x > 0\;\ms{then}\;1 - x\;\ms{else}\;1 +
  x$ to $1 + \ms{abs}(x)$.
\end{itemize}

We can work towards making these easier to express by generalizing our syntax to allow the branches
of if-statements to contain arbitrary code, rather than just unconditional branches, as in
Figure~\ref{fig:bba-to-anf}. This clearly adds no additional expressive power, since:
\begin{itemize}
  \item This syntax clearly generalizes the previous syntax, so no conversion into it is necessary
  \item To revert back to the less general syntax, one must simply introduce new anonymous basic
  blocks for each branch of the if-statement, likeso:
  \begin{equation}
    \ms{if}\;e\;\{s\}\;\ms{else}\;\{t\}
    \to (\ms{if}\;e\;\{\ms{br}\;\ell_\top\}\;\ms{else}\;\{\ms{br}\;\ell_\bot\})\;
        \ms{where}\;\ell_\top: \{s\},\;\ell_\bot: \{t\}
  \end{equation}
\end{itemize}

What we end up with is something which looks a lot like
\textit{administrative normal form} (ANF), with our transformation analogous to that described in
\citet{chakravarty-functional-ssa-2003}. The key difference is that, in our format (which is
strictly first order), we require an explicit \ms{ret} instruction (rather than adopting an expression-oriented language), and write ``$\ms{let\;rec}\;f(x) = e; t$" as ``$t\;\ms{where}\;f(x) : \{e\}$."

\begin{figure}
  \centering
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}(1, 1) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{ \\
      & \quad \ms{if}\;i_0 < n\;\{\;\ms{br}\;\ms{body}\;\} \\
      & \quad \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
      & \quad \ms{where}\;\ms{body}: \{\\ 
      & \qquad \ms{let}\;t = i_0 + 1 \\
      & \qquad \ms{let}\;a_1 = a_0 * t \\
      & \qquad \ms{let}\;i_1 = i_0 + 1 \\
      & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
      & \quad \} \\
      & \}
    \end{align*}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}(1, 1) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{\\
      & \quad \ms{if}\;i_0 < n\;\{ \\
      & \qquad \ms{let}\;t = i_0 + 1 \\
      & \qquad \ms{let}\;a_1 = a_0 * t \\
      & \qquad \ms{let}\;i_1 = i_0 + 1 \\
      & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
      & \quad \}\;\ms{else}\;\{ \\
      & \qquad \ms{ret}\;a_0 \\
      & \quad \} \\
      & \}
    \end{align*}
  \end{subfigure}
  \caption{Allowing if-statements to jump to arbitrary instructions, rather than a terminator}
  \Description{}
  \label{fig:bba-to-anf}
\end{figure}

ANF, however, still lacks a good substitution property, since substituting a value for a variable
can take you out of ANF, making it difficult to express optimizations like $(i + 1) - 1 \to i$ as
rewrite rules. To fix this, we can simply relax the restriction that expressions in a program must
be atomic. This can again trivially be seen to add no excessive power, since we can always introduce
temporary variables via \ms{let}-bindings to make any expression atomic. For full generality, we
will also allow \ms{let}-bindings and \ms{if}-statements \textit{inside} expressions, which again
can be eliminated in the obvious manner, such as by taking
\begin{align*}
  \ms{let}\;x = (\ms{if}\;e\;\{a\}\;\ms{else}\;\{b\}); t &
    \to \ms{if}\;e\;\{\ms{let}\;x = a; t\}\;\ms{else}\;\{\ms{let}\;x = b; t\} \\ 
  & \to \ms{if}\;e\;\{\ms{br}\;\ell(x)\}\;\ms{else}\;\{\ms{br}\;\ell(x)\}\;
        \ms{where}\;\ell(x): \{t\}
\end{align*}

\begin{figure}
  \centering
  \begin{subfigure}[t]{.31\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}(1, 1) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{\\
      & \quad \ms{if}\;i_0 < n\;\{ \\
      & \qquad \ms{let}\;t = i_0 + 1 \\
      & \qquad \ms{let}\;a_1 = a_0 * t \\
      & \qquad \ms{let}\;i_1 = i_0 + 1 \\
      & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
      & \quad \}\;\ms{else}\;\{ \\
      & \qquad \ms{ret}\;a_0 \\
      & \quad \} \\
      & \}
    \end{align*}
    \caption{Program in ANF}
    \label{fig:fact-anf}
  \end{subfigure}%
  \begin{subfigure}[t]{.35\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}(1, 1) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{\\
      & \quad \ms{if}\;i_0 < n\;\{ \\
      & \qquad \ms{br}\;\ms{loop}(i_0 + 1, a_0 * (i_0 + 1)) \\
      & \quad \}\;\ms{else}\;\{ \\
      & \qquad \ms{ret}\;a_0 \\
      & \quad \} \\
      & \}  \\ \\ \\
    \end{align*}
    \caption{
      Programs \ref{fig:fact-anf} and \ref{fig:fact-subst} after substitution;
      since the result is the same, both programs must be equivalent.
    }
    \label{fig:fact-subst}
  \end{subfigure}\hspace{1em}%
  \begin{subfigure}[t]{.31\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}(1, 1) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{\\
      & \quad \ms{if}\;i_0 < n\;\{ \\
      & \qquad \ms{let}\;i_1 = i_0 + 1 \\
      & \qquad \ms{let}\;a_1 = a_0 * i_1 \\
      & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
      & \quad \}\;\ms{else}\;\{ \\
      & \qquad \ms{ret}\;a_0 \\
      & \quad \} \\
      & \} \\
    \end{align*}
    \caption{Optimized ANF program}
    \label{fig:fact-opt}
  \end{subfigure}
  \caption{
    Adding support for expressions, allowing us to perform substitutions of (pure) expressions.
    Optimizations such as common subexpression elimination can be built using substitution as a
    building block.
  }
  \Description{}
  \label{fig:fact-cse}
\end{figure}


This gives us our final \isotopessa language. We can now state \textit{substitutions}, like, in
Figure~\ref{fig:fact-cse}, which can be used to build up optimizations such as
\textit{common-subexpression elimination}. Substitution, in particular, lets us do algebra
\textit{algebra}, for example, since we know that:
\begin{align*}
  (i_0 + 1, a_0 * (i_0 + 1)) &= (\ms{let}\;(x, y) = (i_0, a_0)\;\ms{in}\;(x + 1, y * (x + 1))) \\
  (1, 1) &= (\ms{let}\;(x, y) = (0, 1)\;\ms{in}\;(x + 1, y * (x + 1)))
\end{align*} 
we can rewrite the program in Figure~\ref{fig:fact-subst-2} to that in Figure~\ref{fig:fact-dinat}.
We can then apply general rewrite rules such as \textit{dinaturality} (\todo{explain}, cite Elgot
lore?) to rewrite Figure~\ref{fig:fact-dinat} to Figure~\ref{fig:fact-zero}. This allows us to build
up justifications for complex optimizations, such as rewriting \ref{fig:fact-zero} to
\ref{fig:fact-opt}, in terms of simple rewriting steps. In particular, we can do \textit{complex},
\textit{error-prone} loop and control-flow graph optimizations by breaking them down into closed set
of simple algebraic steps, with each step rigorously justified via our denotational semantics

% \begin{itemize}
%   \item 
%   \item We can 
%   \item We can show that our steps are \textit{complete} by showing that quotienting by them gives
%         a model of our denotational semantics
%   \item That's why we use \isotopessa
%   \item But we gain no additional power: SSA $\subseteq$ \isotopessa; this is a retraction
%   (embedding-projection)
%   \item In particular, using the steps, every \isotopessa program can be converted to an SSA program with
%         equivalent semantics, while every SSA program is already a \isotopessa program (just add brackets!)
%   \item Unproven conjecture: this should take \~linear time, and the resuling program should be
%   \~linearly sized. Do on paper?
% \end{itemize}

\begin{figure}
  \begin{minipage}{.5\textwidth}
    \begin{subfigure}{\textwidth}
      \begin{align*}
        & \ms{let}\;n = 10; \\
        & \ms{br}\;\ms{loop}(1, 1) \\
        & \ms{where}\;\ms{loop}(i_0, a_0): \{\\
        & \quad \ms{if}\;i_0 < n\;\{ \\
        & \qquad \ms{br}\;\ms{loop}(i_0 + 1, a_0 * (i_0 + 1)) \\
        & \quad \}\;\ms{else}\;\{ \\
        & \qquad \ms{ret}\;a_0 \\
        & \quad \} \\
        & \}
      \end{align*}
      \caption{Substituted program from Figure \ref{fig:fact-subst}}
      \label{fig:fact-subst-2}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
      \begin{align*}
        & \ms{let}\;n = 10; \\
        & \ms{br}\;\ms{loop}\;(0, 1) \\
        & \ms{where}\;\ms{loop}(x, y): \{\\
        & \quad \ms{let}\;(i_0, a_0) = (x + 1, y * (x + 1)); \\
        & \quad \ms{if}\;i_0 < n\;\{ \\
        & \qquad \ms{br}\;\ms{loop}(i_0, a_0) \\
        & \quad \}\;\ms{else}\;\{ \\
        & \qquad \ms{ret}\;a_0 \\
        & \quad \} \\
        & \}
      \end{align*}
      \caption{Equivalent to Figure \ref{fig:fact-dinat} by \textit{dinaturality}}
      \label{fig:fact-dinat}
    \end{subfigure}
  \end{minipage}%
  \begin{subfigure}[c]{.5\textwidth}
    \begin{align*}
      & \ms{let}\;n = 10; \\
      & \ms{br}\;\ms{loop}( \\
      & \quad \ms{let}\;(x, y) = (0, 1); \\
      & \quad(x + 1, y * (x + 1)) \\
      & ) \\
      & \ms{where}\;\ms{loop}(i_0, a_0): \{\\
      & \quad \ms{if}\;i_0 < n\;\{ \\
      & \qquad \ms{br}\;\ms{loop}( \\
      & \qquad \quad \ms{let}\;(x, y) = (i_0, a_0); \\
      & \qquad \quad (x + 1, y * (x + 1)) \\ 
      & \qquad ) \\
      & \quad \}\;\ms{else}\;\{ \\
      & \qquad \ms{ret}\;a_0 \\
      & \quad \} \\
      & \}
    \end{align*}
    \caption{Equivalent to Figure \ref{fig:fact-subst-2} by substitution}
    \label{fig:fact-zero}
  \end{subfigure}
  \TODO{add arrows via \texttt{tikzmark}}
  \caption{
    Decomposing multi-block rewrites (from \ref{fig:fact-zero} to
    \ref{fig:fact-subst-2}, and therefore to the more optimal program 
    \ref{fig:fact-opt}) into simple algebraic steps. By verifying each step, we can
    verify complex optimizations through decomposition.
  } 
  \Description{}
\end{figure}

\section{Type Theory}

We now give a formal account of \isotopessa, starting with the types. Our types are first order, and
consists of binary sums $A + B$, products $A \otimes B$, the unit type $\mathbf{1}$, and the empty
type $\mb{0}$, all parametrized over a set of base types $X \in \mc{T}$. We write our set of types
as $\ms{Ty}(X)$. We also parametrize over:
\begin{itemize}
  
  \item A set of effects $\epsilon \in \mc{E}$, forming a join-semilattice with bottom element $\bot
  \in \mc{E}$
  
  \item For each pair $A, B \in \ms{Ty}(X)$ and effect $\epsilon \in \mc{E}$, a set of
  \textit{instructions} $f \in \mc{I}_\epsilon(A, B)$, where $\epsilon \leq \epsilon' \implies
  \mc{I}_\epsilon(A, B) \subseteq \mc{I}_{\epsilon'}(A, B)$. 
  
  We write $\mc{I}(A, B) = \bigcup_\epsilon\mc{I}_\epsilon(A, B)$, $\mc{I}_\epsilon = \bigcup_{A,
  B}\mc{I}_\epsilon(A, B)$, and $\mc{I} = \bigcup_\epsilon\mc{I}_\epsilon$.

\end{itemize}

A \textit{context} $\Gamma$ is a list of \textit{typing hypotheses} $\thyp{x}{A}{\epsilon}$, where
$x$ is a variable name, $A$ is the type of that variable, and $\epsilon$ is the effect of using that
variable (used when filling holes with effectful expressions). If $\epsilon = \bot$, we often omit
it, writing $\bhyp{x}{A}$. Similarly, we define a \textit{label-context} to be a list of
\textit{labels} $\llhyp{\ell}{A}$, where $A$ is the parameter type that must be passed on a jump to
the label $\ell$. This is summarized in the following grammar:

\begin{figure}[H]
  \begin{center}
    \begin{minipage}{.5\textwidth}
      \begin{grammar}
        <\(A, B, C\)> ::= 
        \(X\)
        \;|\; \(A \otimes B\)
        \;|\; \(\mathbf{1}\)
        \;|\; \(A + B\)
        \;|\; \(\mathbf{0}\)
      \end{grammar}
    \end{minipage}%
    \begin{minipage}{.25\textwidth}
      \begin{grammar}
        <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, \thyp{x}{A}{\epsilon}\)
      \end{grammar}
    \end{minipage}%
    \begin{minipage}{.25\textwidth}
      \begin{grammar}
        <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \llhyp{\ell}{A}\)
      \end{grammar}
    \end{minipage}
  \end{center}
  \caption{Grammar for \isotopessa types, contexts, and label-contexts}
  \label{fig:ssa-ty-grammar}
  \Description{}
\end{figure}

A \isotopessa \textit{expression} $a$ is typed with the judgement $\hasty{\Gamma}{\epsilon}{a}{A}$,
which says that under the typing context $\Gamma$, the expression $a$ has type $A$ and effect
$\epsilon$. The typing rules for expressions are given in Figure~\ref{fig:ssa-expr-rules}.

\begin{figure}[H]
  \begin{gather*}
    \prftree[r]{\rle{var}}{\Gamma\;x \leq (A, \epsilon)}{\hasty{\Gamma}{\epsilon}{x}{A}} \qquad
    \prftree[r]{\rle{op}}{\isop{f}{A}{B}{\epsilon}}{\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma}{\epsilon}{f\;a}{B}} \qquad
    \prftree[r]{\rle{let$_1$}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{B}} \\
    \prftree[r]{\rle{unit}}{\hasty{\Gamma}{\epsilon}{()}{\mb{1}}} \qquad
    \prftree[r]{\rle{pair}}{\hasty{\Gamma}{\epsilon}{a}{A}}{\hasty{\Gamma}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{(A, B)}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
      {\hasty{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{C}} \\
    \prftree[r]{\rle{inl}}{\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma}{\epsilon}{\linl{a}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}{\hasty{\Gamma}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{\linr{b}}{A + B}} \qquad
    \prftree[r]{\rle{abort}}{\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma}{\epsilon}{\labort{a}}{A}} \\
    \prftree[r]{\rle{case}}
      {\hasty{\Gamma}{\epsilon}{e}{A + B}}
      {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
      {\hasty{\Gamma, \bhyp{y}{A}}{\epsilon}{b}{C}}
      {\hasty{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}}
  \end{gather*}
  \caption{Rules for typing \isotopessa expressions}
  \Description{Rules for typing isotope-SSA expressions}
  \label{fig:ssa-expr-rules}
\end{figure}

In particular...

\TODO{rule-by-rule expression typing}

A \isotopessa \textit{region} is typed with the judgement $\haslb{\Gamma}{r}{\ms{L}}$, which says
that under the typing context $\Gamma$, the region $r$ targets the label-context $\ms{L}$. In
particular, this can be interpreted as saying that if the variables in $\Gamma$ are live on entry to
$r$, then $r$ will either loop forever or terminate by branching to one of the external labels in
$\mc{L}$ with the appropriate argument.

\begin{figure}[H]
  \begin{gather*}
    \prftree[r]{\rle{br}}{\hasty{\Gamma}{\bot}{a}{A}}{\ms{L}\;\lbl{\ell} = A}
      {\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} \qquad
    \prftree[r]{\rle{let$_1$-r}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      {\haslb{\Gamma}{\letstmt{x}{a}{r}}{\ms{L}}} \\
    \prftree[r]{\rle{let$_2$-r}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
      {\haslb{\Gamma}{\letstmt{(x, y)}{e}{r}}{\ms{L}}} \\
    \prftree[r]{\rle{case-r}}
      {\hasty{\Gamma}{\epsilon}{e}{A + B}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
      {\haslb{\Gamma}{\casestmt{e}{x}{r}{y}{s}}{\ms{L}}} \\
    \prftree[r]{\rle{cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\haslb{\Gamma}{\where{r}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}{\ms{L}}}
  \end{gather*}
  \caption{Rules for typing \isotopessa regions}
  \Description{Rules for typing isotope-SSA regions}
  \label{fig:ssa-reg-rules}
\end{figure}

In particular...

\TODO{br rule lore}

\TODO{Note that ``returning'' is implemented by simply branching to a distinguished label
$\ms{ret}$, with $\ms{ret}\;a$ simply being an abbreviation for $\ms{br}\;\ms{ret}\;a$.}

\TODO{let rules}

\TODO{case rule}

\TODO{where rule}

\TODO{notes about binding precedence of where}

\TODO{text}

\TODO{weakening rules}

\begin{theorem}[Weakening]
  Given $\Gamma \leq \Delta$, $\epsilon \leq \epsilon'$, and $\ms{L} \leq \ms{K}$, we have that
  $\hasty{\Delta}{\epsilon}{a}{A} \implies \hasty{\Gamma}{\epsilon'}{a}{A}$ and
  $\haslb{\Delta}{r}{\ms{L}} \implies \haslb{\Gamma}{r}{\ms{K}}$
\end{theorem}

\TODO{text}

\TODO{substitution rules}

\begin{theorem}[Substitution]
  Given $\issubst{\gamma}{\Gamma}{\Delta}$, we have that $\hasty{\Delta}{\epsilon}{a}{A} \implies
  \hasty{\Gamma}{\epsilon}{[\gamma]a}{A}$ and $\haslb{\Delta}{r}{\ms{L}} \implies
  \haslb{\Gamma}{[\gamma]r}{\ms{L}}$
\end{theorem}

\TODO{text}

\TODO{label substitution rules}

\begin{theorem}[Label substitution]
  Given $\lbsubst{\sigma}{\ms{L}}{\ms{K}}$, we have that
  $\haslb{\Gamma}{r}{\ms{L}} \implies \haslb{\Gamma}{[\sigma]r}{\ms{K}}$
\end{theorem}

\TODO{text}

\TODO{
  Idea: structure as Terms; Equations; Free Theorem, \textit{then} Elgot; Regions; Free Theorem,
a la \citet{crole-93-cat-types}
}

\section{Equational Theory}

\TODO{this...}

\section{Denotational Semantics}

\TODO{standard denotational semantics for functional programs is given in cartesian/cartesian closed
categories, see \citet{crole-93-cat-types}}

\TODO{we want to deal with side effects and imperative programs; \citet{moggi-91-monad} says use a
(strong) monad}

\TODO{generalizing a bit; a strong monad \textit{over} a cartesian/cartesian closed category induces
a premonoidal, or in fact a Freyd category}

\TODO{like the notion of a symmetric monoidal category, but:
\begin{itemize}
  \item Premonoidal: no sliding, because print doesn't slide
  \item Freyd: have underlying cartesian structure
\end{itemize}
}

\TODO{in particular...; fuse with below narrative/definitions}

\begin{definition}[Symmetric Premonoidal Category]
  We define a \emph{binoidal category} to be a category $\mc{C}$ equipped with a binary operation
  $\otimes : |\mc{C}| \times |\mc{C}| \to |\mc{C}|$ on the objects of $\mc{C}$ and, for each $A, B
  \in |\mc{C}|$, functors $A \otimes -, - \otimes B : \mc{C} \to \mc{C}$. We say a morphism $f : A
  \to A'$ in a binoidal category is \emph{central} if, for all $g : B \to B'$, it satisfies
  \emph{sliding}:
  $$
  f \otimes B ; A' \otimes g = A \otimes g ; f \otimes B' \qquad
  B \otimes f ; g \otimes A' = g \otimes A ; B' \otimes f
  $$
  in which case we may write these morphisms as $f \otimes g : A \otimes B \to A' \otimes B'$ and $g
  \otimes f : B \otimes A \to B' \otimes A'$ respectively. A \emph{premonoidal category} is, then, a
  binoidal category equipped with:
  \begin{itemize}
    \item An \emph{identity} object $I \in |\mc{C}|$
    \item For each triple of objects $A, B, C \in |\mc{C}|$, a central, natural isomorphism
    $\alpha_{A, B, C} : (A \otimes B) \otimes C \to A \otimes (B \otimes C)$, the \emph{associator}
    \item For each object $A$, central, natural isomorphisms $\lambda_A : A \otimes I \to A$ and
    $\rho_A : I \otimes A \to A$, the \emph{left} and \emph{right unitors}
  \end{itemize}
  satisfying the \emph{triangle} and \emph{pentagon identity}
  $$
  \alpha_{A, I, B} ; A \otimes \lambda_B = \rho_A \otimes B \qquad
  \alpha_{A \otimes B, C, D} ; \alpha_{A, B, C \otimes D}
  = \alpha_{A, B, C} \otimes D ; \alpha_{A, B \otimes C, D} ; A \otimes \alpha_{A, B, C}
  $$
  We say a premonoidal category is \emph{symmetric} if it is also equipped with a central, natural
  involution $\sigma_{A, B} : A \otimes B \to B \otimes A$, the \textit{symmetry}, satisfying the
  \emph{hexagon identity}
  $$
  \alpha_{A, B, C} ; \sigma_{A, B \otimes C} ; \alpha_{B, C, A}
  = \sigma_{A, B} \otimes C ; \alpha_{B, A, C} ; B \otimes \sigma_{A, C}
  $$
  We say a premonoidal category is \emph{monoidal} if every morphism is central.
\end{definition}

\TODO{but we want a nice notion of functor between premonoidal categories, but}

\TODO{(a) preserving central morphisms is too strong}

\TODO{(b) if we want to preserve ``pure" morphisms, in general, central $\neq$ pure}

\TODO{useful example: read is pure in Reader, but if we want a functor from Reader to State, read
 read in state is not pure!}

\TODO{(c) we want some Cartesian structure, for now...}

\TODO{\(\implies\) Freyd category lore}

\begin{definition}[Freyd category]
  A \emph{Freyd category} is a premonoidal category $\mc{C}$ equipped with a wide subcategory
  $\mc{V} \subseteq \mc{C}$ of \emph{pure} morphisms such that
  \begin{itemize}
    \item $\mc{V}$ contains all associators, unitors, and symmetries
    \item For each $A_1, A_2$, there exist morphisms $\pi_i : A_1 \times A_2 \to_{\mc{V}} A_i$
    making $A_1 \otimes A_2$ into a cartesian product on $\mc{V}$
  \end{itemize}
\end{definition}

\TODO{throw some examples in here?}

\TODO{
  \begin{itemize}
    \item Every Cartesian category $\mc{C}$ is trivially Freyd with $\mc{V} = \mc{C}$
    \item Every strong monad on a cartesian category induces a Freyd category
    \item Minimal subcategory $\mc{V}$ and Reader/State example...
  \end{itemize}
}

\TODO{monadic lore?}

\TODO{effect lore:}

\TODO{coproduct lore}

\TODO{distributivity lore}

\begin{definition}[Distributive category]
  A premonoidal category $\mc{C}$ with all coproducts is \emph{distributive} if, for all $A, B, C$,
  the obvious morphism
  $$
  \delta_{A, B, C} 
    = [(A + \iota_l), (A + \iota_r)] : (A \otimes B) + (A \otimes C) \to A \otimes (B + C)
  $$
  is an isomorphism.
\end{definition}

\TODO{``quotiented terms give the free model of distributive Freyd categories?''}

\TODO{Elgot category lore; strength}

\begin{definition}[(Strong) Elgot structure]
  A category $\mc{C}$ with all coproducts is said to have an \emph{Elgot structure} if we can define
  an operator $(-)^\dagger$ taking every morphism $f : A \to B + A$ to a morphism $f^\dagger : A \to
  B$, the \emph{fixpoint} of $f$, satisfying the following axioms:
  \begin{itemize}
    \item \emph{Fixpoint:} $f^\dagger = f;[\ms{id}, f^\dagger]$
    \item \emph{Naturality:} $(f;g + \ms{id})^\dagger = f^\dagger;g$
    \item \emph{Codiagonal:} $(f^\dagger)^\dagger = (f;[\ms{id}, \iota_r])^\dagger$
    \item \emph{Uniformity:} $\forall h, h;f = g;\ms{id} + h \implies h;f^\dagger = g^\dagger$
  \end{itemize}
  \TODO{type these?}

  If $\mc{C}$ is distributive, we say it has a \emph{strong Elgot structure} if
  $
  \forall f: A \to B + A, (f \otimes C ; \delta^{-1})^\dagger = f^\dagger \otimes C
  $

  We say a monad is Elgot if its Kliesli category has an Elgot structure. Similarly, we say a
  \emph{strong} moand is strong Elgot if its Kliesli category has a strong Elgot structure.
\end{definition}

\TODO{note squaring and dinaturality are derivable by Lemma 31 of
\citet{goncharov-18-guarded-traced}}

\TODO{examples:
\begin{itemize}
  \item Common monads: Option, List, Powerset
  \item Preserved by transformers: ReaderT, WriterT, StateT, OptionT, ExceptT
  \item Later: trace lore
\end{itemize}
}

% \begin{definition}[E-Freyd category]
%   Given a complete lattice $E$, an \emph{$E$-Freyd category} is a premonoidal category $\mc{C}$
%   equipped with a continuous function $\epsilon \in E \mapsto \mc{C}_\epsilon$ from elements of $E$
%   to wide subcategories of $\mc{C}$, such that $\mc{C}_\top = \mc{C}$ and $(\mc{C}, \mc{V} =
%   \mc{C}_\bot)$ is a Freyd category. In particular, every Freyd category is trivially an $E$-Freyd
%   category for the Sierpinski poset $E = \{\top, \bot\}$.
% \end{definition}

An \isotopessa model consists of:
\begin{itemize}
  \item A distributive premonoidal category $\mc{C}$, equipped with an Elgot structure
  \item A complete lattice $E$, and a continuous function $\epsilon \mapsto \mc{C}_\epsilon$ from
  $E$ to wide subcategories of $\mc{C}$, such that $\mc{C}_\top = \mc{C}$, and $(\mc{C}, \mc{V} =
  \mc{C}_\bot)$ is a Freyd category.
\end{itemize}
In particular, whenever $\mc{C}$ is a distributive Elgot Freyd category, we can trivially obtain an
\isotopessa model by choosing $E = \{\top, \bot\}$. We may also choose $E = \{*\}$ if and only if
$\mc{C}$ is in fact Cartesian.

\TODO{$\to_\epsilon$ lore}

\begin{figure}[H]
  \begin{align*}
    \boxed{\dnt{A}} : |\mc{C}|
  \end{align*}
  \caption{Denotational semantics for \isotopessa types and contexts}
  \Description{Denotational semantics for isotope-SSA types and contexts}
  \label{fig:ssa-ty-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\hasty{\Gamma}{\epsilon}{a}{A}} : \dnt{\Gamma} \to_\epsilon \dnt{A}}
  \end{equation*}
  \begin{align*}
    \dnt{\hasty{\Gamma}{\epsilon}{x}{A}} &= \pi_{\Gamma, x} \\
    \dnt{\hasty{\Gamma}{\epsilon}{f\;a}{B}} 
      &= \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} ; \dnt{\isop{f}{A}{B}{\epsilon}} \\
    \dnt{\hasty{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{B}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{a}{A}};
      \\&\quad\; 
      \dnt{\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{(a, b)}{A \otimes B}} 
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} \ltimes \dnt{\hasty{\Gamma}{\epsilon}{b}{B}}
      % ; \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} \otimes \dnt{\Gamma} 
      % ; \dnt{A} \otimes \dnt{\hasty{\Gamma}{\epsilon}{b}{B}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{C}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{e}{A \otimes B}} ;
      \\&\quad\; 
      \dnt{\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{()}{\mb{1}}} &= 1_{\dnt{\Gamma}} \\
    \dnt{\hasty{\Gamma}{\epsilon}{\linl{a}}{A + B}}
      &= \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} ; \iota_l \\
    \dnt{\hasty{\Gamma}{\epsilon}{\linr{b}}{A + B}}
      &= \dnt{\hasty{\Gamma}{\epsilon}{b}{B}} ; \iota_r \\
    \dnt{\hasty{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}}
      &= \dnt{\hasty{\Gamma}{\epsilon}{e}{A + B}}
      ; \\& \quad\; 
      \dnt{\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{A}}
      + \dnt{\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{B}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{\labort{a}}{A}} 
      &= \dnt{\hasty{\Gamma}{\epsilon}{a}{\mb{0}}} ; 0_{\dnt{A}}
  \end{align*}
  \caption{Denotational semantics for \isotopessa terms}
  \Description{Denotational semantics for isotope-SSA terms}
  \label{fig:ssa-term-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\haslb{\Gamma}{r}{\ms{L}}} : \dnt{\Gamma} \to \dnt{\ms{L}}}
  \end{equation*}
  \begin{align*}
    \dnt{\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} 
      &= \dnt{\hasty{\Gamma}{\bot}{a}{A}} ; \iota_{\ms{L}, \ell}
      \\
    \dnt{\haslb{\Gamma}{\letstmt{x}{a}{r}}{\ms{L}}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{a}{A}}
      ; \dnt{\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}} 
      \\
    \dnt{\haslb{\Gamma}{\letstmt{(x, y)}{e}{r}}{\ms{L}}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      ; \dnt{\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}} 
      \\ 
    \dnt{\haslb{\Gamma}{\casestmt{e}{x}{r}{y}{s}}{\ms{L}}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{e}{A + B}}
      ; \delta^{-1} ;
      \\&\quad\;
      \dnt{\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      + \dnt{\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
      \\
    \dnt{\haslb{\Gamma}{\where{r}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}{\ms{L}}}
      &=  
      \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}} 
      ; \delta^{-1} ;
      \alpha^+_{}
      \\ &\quad\;
      (
        \Sigma_i (\Delta_{\dnt{\Gamma}} 
          ; \dnt{\Gamma} \otimes 
            \dnt{\haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
          ; 
          )
      )^\dagger
  \end{align*}
  \caption{Denotational semantics for \isotopessa regions}
  \Description{Denotational semantics for isotope-SSA regions}
  \label{fig:ssa-reg-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\Gamma \leq \Delta} 
      : \dnt{\Gamma} \to_{\bot} \dnt{\Delta}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa weakenings}
  \Description{Denotational semantics for isotope-SSA weakenings}
  \label{fig:ssa-vsubst-sem} 
\end{figure} 

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\issubst{\gamma}{\Gamma}{\Delta}} 
      : \dnt{\Gamma} \to_{\epsilon_\Delta} \dnt{\Delta}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa substitutions}
  \Description{Denotational semantics for isotope-SSA substitutions}
  \label{fig:ssa-vsubst-sem} 
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\lbsubst{\kappa}{\ms{L}}{\ms{K}}} 
      : \dnt{\ms{L}} \to \dnt{\ms{K}}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa label-substitutions}
  \Description{Denotational semantics for isotope-SSA label-substitutions}
  \label{fig:ssa-lsubst-sem}
\end{figure}

\TODO{equational theory lore}

\TODO{completeness}

\section{Concrete Models}

\TODO{(strong) Elgot monad lore $\implies$ every strong Elgot monad over a Cartesian category is an
\isotopessa model}

\TODO{\cite{goncharov-16-complete-elgot}, \cite{goncharov-21-uniform-elgot},
\cite{goncharov-guarded-unguarded}}

\TODO{trace models; infinite monoids (need a name for these...)}

\TODO{monad transformers: state; reader; writer}

\TODO{Cite how we're doing \citet{liang-95-interpreters}}

\TODO{submonads}

\section{TSO weak memory}

\TODO{this...}

\section{Discussion and Related Work}

\TODO{this...}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\clearpage 

\appendix

\section{Syntax and Typing Rules}

\begin{figure}[H]
  \begin{center}
    \begin{grammar}
      <\(A, B, C\)> ::= 
      \(X\)
      \;|\; \(A \otimes B\)
      \;|\; \(\mathbf{1}\)
      \;|\; \(A + B\)
      \;|\; \(\mathbf{0}\)

      <\(a, b, c, e\)> ::= \(x\) 
      \;|\;  \(f\;a\)
      \;|\; \(\letexpr{x}{a}{e}\)
      \alt  \(()\)
      \;|\; \((a, b)\)
      \;|\; \(\letexpr{(x, y)}{a}{e}\)
      \alt  \(\linl{a}\) 
      \;|\; \(\linr{a}\)
      \;|\; \(\labort{a}\)
      \;|\; \(\caseexpr{e}{x}{s}{y}{t}\)
      
      <\(s, t\)> ::= \(\lbrb{\ell}{a}\) 
      \alt  \(\letstmt{x}{a}{t}\)
      \;|\; \(\letstmt{(x, y)}{a}{t}\)
      \;|\; \(\casestmt{e}{x}{s}{y}{t}\)
      \alt  \(\where{t}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}\)

      <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, \thyp{x}{A}{\epsilon}\)

      <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \llhyp{\ell}{A}\)
    \end{grammar}
  \end{center}
  \caption{Grammar for \isotopessa, parametrized over a set of instructions \(f \in \mc{I}\)}
  \Description{Grammar for isotope-SSA}
  \label{fig:ssa-grammar}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Rules for typing \isotopessa substitutions}
  \Description{Rules for typing isotope-SSA substitutions}
  \label{fig:ssa-vsubst-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Rules for typing \isotopessa label-substitutions}
  \Description{Rules for typing isotope-SSA label-substitutions}
  \label{fig:ssa-lsubst-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Syntax and typing for \isotopessa composition}
  \Description{Syntax and typing for isotope-SSA composition}
  \label{fig:ssa-compose}
\end{figure}

\section{Equational Theory}

\subsection{Terms}

\TODO{write nicer fused version?}

\TODO{\textit{formalize} nicer fused version?}

\begin{gather*}
  \prftree[r]{\rle{refl}}{\hasty{\Gamma}{\epsilon}{a}{A}}{\tmeq{\Gamma}{\epsilon}{a}{a}{A}} \qquad
  \prftree[r]{\rle{trans}}
    {\tmeq{\Gamma}{\epsilon}{a}{b}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{c}{A}} 
    {\tmeq{\Gamma}{\epsilon}{a}{c}{A}} \qquad
  \prftree[r]{\rle{symm}}
    {\tmeq{\Gamma}{\epsilon}{a}{b}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{a}{A}}
  \\
  \prftree[r]{\rle{let$_1$-bind}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{\letexpr{x}{a'}{b}}{B}} 
  \\
  \prftree[r]{\rle{let$_1$-bound}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{\letexpr{x}{a}{b'}}{B}}
  \\
  \prftree[r]{\rle{pair-l}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{(a, b)}{(a', b)}{A \otimes B}} \qquad
  \prftree[r]{\rle{pair-r}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{(a, b)}{(a, b')}{A \otimes B}}
  \\
  \prftree[r]{\rle{let$_2$-bind}}
    {\tmeq{\Gamma}{\epsilon}{e}{e'}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{\letexpr{(x, y)}{e'}{c}}{C}}
  \\
  \prftree[r]{\rle{let$_2$-bound}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\tmeq{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{\letexpr{(x, y)}{e}{c'}}{C}}
  \\
  \prftree[r]{\rle{inl}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\tmeq{\Gamma}{\epsilon}{\linl{a}}{\linl{a'}}{A + B}} \qquad
  \prftree[r]{\rle{inr}}
    {\tmeq{\Gamma}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{\linr{b}}{\linr{b'}}{A + B}} \qquad
  \\
  \prftree[r]{\rle{abort}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{\mb{0}}}
    {\tmeq{\Gamma}{\epsilon}{\labort{a}}{\labort{a'}}{A}}
  \\
  \prftree[r]{\rle{case-d}}
    {\tmeq{\Gamma}{\epsilon}{e}{e'}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a}{y}{b}}{C}}
  \\
  \prftree[r]{\rle{case-l}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\tmeq{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{a'}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a'}{y}{b}}{C}}
  \\
  \prftree[r]{\rle{case-r}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\tmeq{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{b'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a}{y}{b'}}{C}}
\end{gather*}


\begin{gather*}
  \prftree[r]{\rle{let$_1$-$\beta$}}
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{[b/x]a}{B}}
  \qquad
  \prftree[r]{\rle{let$_1$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{x}}{a}{A}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-op}}
    {\isop{f}{A}{B}{\epsilon}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{f\;a}{c}}{\letexpr{x}{a}{\letexpr{f\;x}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-let$_1$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{y}{(\letexpr{x}{a}{b})}{c}}
      {\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-let$_2$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \times B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{C}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{z}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{z}{(\letexpr{(x, y)}{e}{c})}{d}}
      {\letexpr{(x, y)}{e}{\letexpr{z}{c}{d}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{\linl{a}}{c}}{\letexpr{x}{a}{\letexpr{\linl{x}}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{\linr{b}}{c}}{\letexpr{x}{b}{\letexpr{\linr{x}}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-abort}}
    {\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
    {\hasty{\Gamma, \bhyp{y}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{y}{\labort{b}}{b}}
      {\letexpr{x}{a}{\letexpr{y}{\labort{x}}{b}}}{B}}
  \\
  \prftree[r]{\rle{let$_1$-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\hasty{\Gamma, \bhyp{z}{C}}{\epsilon}{d}{D}}
    { 
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{z}{(\caseexpr{e}{x}{a}{y}{b})}{d}}
      {\hspace{6em} \teqv \caseexpr{e}{x}{\letexpr{z}{a}{d}}{\letexpr{z}{b}{d}}{b} : D}
    }
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_2$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{(x, y)}}{e}{A \otimes B}} 
  \\
  \prftree[r]{\rle{let$_2$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{(a, b)}{c}}{\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_2$-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{(x, y)}{e}{c}}
      {\letexpr{z}{e}{\letexpr{z}{e}{c}}}{C}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{case-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{\linl{a}}{x}{c}{y}{d}}{\letexpr{x}{a}{c}}{C}}
  \\
  \prftree[r]{\rle{case-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{\linr{b}}{x}{c}{y}{d}}{\letexpr{y}{b}{d}}{C}}
  \\
  \prftree[r]{\rle{case-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{\linl{x}}{y}{\linr{y}}}{e}{A + B}}
  \\
  \prftree[r]{\rle{case-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{c}{y}{d}}{\letexpr{z}{e}{\caseexpr{z}{x}{c}{y}{d}}}{C}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{A}}{\epsilon}{d}{D}}
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z'}{B}}{\epsilon}{d'}{D}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{x}{a}{\letexpr{y}{c}{\caseexpr{x}{z}{d}{z'}{d'}}}}
      {\hspace{6em} \teqv \letexpr{x}{a}{\caseexpr{x}{z}{\letexpr{y}{c}{d}}{z'}{\letexpr{y}{c}{d'}}} 
      : D}
    }
  \\
  \prftree[r]{\rle{let$_2$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C \otimes D}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{D}, \bhyp{w}{A}}{\epsilon}{e}{E}}
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{D}, \bhyp{w'}{B}}{\epsilon}{e'}{E}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{x}{a}{\letexpr{(y, z)}{c}{\caseexpr{x}{w}{e}{w'}{e'}}}}
      {\hspace{5em} \teqv \letexpr{x}{a}
        {\caseexpr{x}
          {w}{\letexpr{(y, z)}{c}{e}}
          {w'}{\letexpr{(y, z)}{c}{e'}}} 
      : E}
    }
  \\
  \prftree[r]{\rle{case-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{b}{B_1 + B_2}}
    {
      \forall i j.
      \hasty{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y_i}{B_i}, \bhyp{z_j}{A_j}}{\epsilon}
            {c_{ij}}{C}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon 
        \ms{let}\;x = a;
        \ms{case}\;b\;\{\ms{inl}\;y_1 \lto \caseexpr{x}{z_1}{e_{11}}{z_2}{e_{12}}
      }
      {
        \hspace{10em} \ms{inr}\;y_2 \lto \caseexpr{x}{z_1}{e_{21}}{z_2}{e_{22}} \}
      }
      {\hspace{1.3em} \teqv
        \ms{let}\;x = a;
        \ms{case}\;x\;\{\ms{inl}\;z_1 \lto \caseexpr{b}{y_1}{e_{11}}{y_2}{e_{21}}
      }
      {
        \hspace{10em} \ms{inr}\;z_2 \lto \caseexpr{b}{y_1}{e_{12}}{y_2}{e_{22}} \}
      }
    }
  \\
  \prftree[r]{\rle{op-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\isop{f}{C}{D}{\epsilon}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{f\;c}{y}{f\;c'}}{f\;\caseexpr{e}{x}{c}{y}{c'}}{D}}
  \\
  \prftree[r]{\rle{inl-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\caseexpr{e}{x}{\linl{c}}{y}{\linl{c'}}}
      {\linl{\caseexpr{e}{x}{c}{y}{c'}}}
      {C + D}}
  \\
  \prftree[r]{\rle{inr-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{d}{D}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d'}{D}}
    {\tmeq{\Gamma}{\epsilon}
      {\caseexpr{e}{x}{\linr{d}}{y}{\linr{d'}}}
      {\linr{\caseexpr{e}{x}{d}{y}{d'}}}
      {C + D}}
  \\
  \prftree[r]{\rle{abort-case}}
  {\hasty{\Gamma}{\epsilon}{e}{A + B}}
  {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{\mb{0}}}
  {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{\mb{0}}}
  {
    \prfStackPremises
    {\Gamma \vdash_\epsilon \caseexpr{e}{x}{\labort{c}}{y}{\labort{c'}}}
    {\approx \labort{\caseexpr{e}{x}{c}{y}{c'}} : C}
  }
  \\
  \prftree[r]{\rle{pair-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A_1 + A_2}}
    {\forall i, \hasty{\Gamma, \bhyp{x_i}{A_i}}{\epsilon}{b_{ij}}{B_j}}
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \caseexpr{e}{x}{(b_{11}, b_{12})}{y}{(b_{21}, b_{22})}}
      {\approx (\caseexpr{e}{x}{b_{11}}{y}{b_{21}}, \caseexpr{e}{x}{b_{12}}{y}{b_{22}}) 
      : B_1 \otimes B_2}
    }
  \\
  \prftree[r]{\rle{case$_0$}}
    {\hasty{\Gamma}{\epsilon}{e}{A_1 + A_2}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{a}}{a}{A}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{initial}} 
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\hasty{\Gamma}{\bot}{a'}{A}}
    {\exists x, \Gamma\;x = \mb{0}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    \qquad
  \prftree[r]{\rle{terminal}}
    {\hasty{\Gamma}{\bot}{a}{\mb{1}}}
    {\hasty{\Gamma}{\bot}{a'}{\mb{1}}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{\mb{1}}}
\end{gather*}

\TODO{soundness of term equational theory (diagrams?)}

\TODO{notes on completeness? derivable equations?}

\subsection{Regions}

\begin{gather*}
  \prftree[r]{\rle{refl}}{\haslb{\Gamma}{r}{\ms{L}}}{\lbeq{\Gamma}{r}{r}{\ms{L}}} \qquad
  \prftree[r]{\rle{trans}}{\lbeq{\Gamma}{r}{s}{\ms{L}}}{\lbeq{\Gamma}{s}{t}{\ms{L}}}
    {\lbeq{\Gamma}{r}{t}{\ms{L}}} \qquad
  \prftree[r]{\rle{symm}}{\lbeq{\Gamma}{r}{s}{\ms{L}}}{\lbeq{\Gamma}{s}{r}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-left}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\lbeq{\Gamma, \bhyp{x}{A}}{r}{r'}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\caseexpr{e}{x}{r'}{y}{s}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-right}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma, \bhyp{y}{B}}{s}{s'}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\caseexpr{e}{x}{r}{y}{s'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let}$_1$}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\lbeq{\Gamma, \bhyp{x}{A}}{r}{r'}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{x}{a}{r'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let}$_2$}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\lbeq{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{r'}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{r}}{\letstmt{(x, y)}{e}{r'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{cfg-entry}}
    {\lbeq{\Gamma}{r}{r'}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbeq{\Gamma}
      {\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\where{r'}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\ms{L}}
    }
  \\
  \prftree[r]{\rle{cfg-block}}
    {\haslb{\Gamma}{r}{\ms{L}}}
    {\forall i. \lbeq{\Gamma, \bhyp{x_i}{A_i}}{t_i}{t_i'}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbeq{\Gamma}
      {\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\where{r'}{(\lwbranch{\ell_i}{x_i: A_i}{t_i'},)_i}}
      {\ms{L}}
    }
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-$\beta$}}
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{[r/x]a}{\ms{L}}}
  \qquad
  \prftree[r]{\rle{let$_1$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{a}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{y}{a}{\letstmt{x}{y}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{1\approx}$}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{x}{a'}{r}}{\ms{L}}}
  \qquad
  \prftree[r]{\rle{initial}}
    {\haslb{\Gamma}{r}{\ms{L}}}
    {\haslb{\Gamma}{s}{\ms{L}}}
    {\exists x, \Gamma\;x = \mb{0}}
    {\lbeq{\Gamma}{r}{s}{\ms{L}}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-op}}
    {\isop{f}{A}{B}{\epsilon}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\haslb{\Gamma, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{f\;a}{r}}{\letstmt{x}{a}{\letstmt{y}{f\;x}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{1}$-let$_1$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{(\letexpr{x}{a}{b})}{r}}{\letstmt{x}{a}{\letstmt{y}{b}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{z}{A \otimes B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}
      {\letstmt{z}{(a, b)}{r}}
      {\letstmt{x}{a}{\letstmt{y}{b}{\letstmt{z}{(x, y)}{r}}}}
      {\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{1}$-let$_2$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\haslb{\Gamma, \bhyp{z}{C}}{r}{\ms{L}}}
    {\lbeq{\Gamma}
      {\letstmt{z}{(\letexpr{(x, y)}{e}{c})}{r}}
      {\letstmt{(x, y)}{e}{\letstmt{z}{c}{r}}}
      {\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\haslb{\Gamma, \bhyp{y}{A + B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{\linl{a}}{r}}{\letstmt{x}{a}{\letstmt{\linl{x}}{y}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{y}{A + B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{\linr{b}}{r}}{\letstmt{x}{b}{\letstmt{\linr{x}}{y}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-abort}}
    {\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
    {\haslb{\Gamma, \bhyp{y}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{\labort{a}}{r}}{\letstmt{x}{a}{\letstmt{y}{\labort{x}}{r}}}{\ms{L}}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_2$-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{r}}{\letstmt{z}{e}{\letstmt{(x, y)}{z}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_2$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{(a, b)}{r}}{\letstmt{x}{a}{\letstmt{y}{b}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_2$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\haslb{\Gamma, \bhyp{z}{A \otimes B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{\letstmt{z}{(x, y)}{r}}}{\letstmt{z}{e}{r}}{\ms{L}}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{case-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\letstmt{z}{e}{\caseexpr{z}{x}{r}{y}{s}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{\linl{a}}{x}{r}{y}{s}}{\letstmt{x}{a}{r}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{\linr{b}}{x}{r}{y}{s}}{\letstmt{y}{b}{s}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{11}$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A_1 + A_2}}{\epsilon}{b}{B}}
    {
    \forall i. \haslb{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y}{B}, \bhyp{z_i}{A_i}}{r_i}{\ms{L}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash \letstmt{x}{a}{\letstmt{y}{c}{\casestmt{x}{z_1}{r_1}{z_2}{r_2}}}}
      {\hspace{6em} \approx 
        \letstmt{x}{a}{\casestmt{x}{z_1}{\letstmt{y}{c}{r_1}}{z_2}{\letstmt{y}{c}{r_2}}} 
        : \ms{L}}
    }
  \\
  \prftree[r]{\rle{let$_{12}$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A_1 + A_2}}{\epsilon}{b}{B \otimes C}}
    {
    \forall i. 
      \haslb{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y}{B}, \bhyp{z}{C}, \bhyp{w_i}{A_i}}{r_i}{\ms{L}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash \letstmt{x}{a}{\letstmt{(y, z)}{c}{\casestmt{x}{w_1}{r_1}{w_2}{r_2}}}}
      {\hspace{5em} \approx 
        \letstmt{x}{a}{\casestmt{x}{w_1}{\letstmt{(y, z)}{b}{r_1}}{w_2}{\letstmt{(y, z)}{b}{r_2}}} 
        : \ms{L}}
    }
  \\
  \prftree[r]{\rle{case-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A_1 + A_2}}{\epsilon}{b}{B_1 + B_2}}
    {
    \forall i j. 
      \haslb{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y_i}{B_i}, \bhyp{z_j}{A_j}}{r_{ij}}{\ms{L}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash \ms{let}\;x = a; \ms{case}\;b\;\{
        \linl{y_1} \lto \casestmt{x}{z_1}{r_{11}}{z_2}{r_{21}}
      }
      {
        \hspace{10em} \linr{y_2} \lto \casestmt{x}{z_1}{r_{12}}{z_2}{r_{22}}\}
      }
      {
        \hspace{1.3em} \approx \ms{let}\;x = a; \ms{case}\;x\;\{
        \linl{z_1} \lto \casestmt{b}{y_1}{r_{11}}{y_2}{r_{21}}
      }
      {
        \hspace{10em} \linr{z_2} \lto \casestmt{b}{y_1}{r_{12}}{y_2}{r_{22}}\}
      }
    }
\end{gather*}

\begin{gather*}
    \prftree[r]{\rle{cfg-$<$}}
      {\hasty{\Gamma}{\bot}{a}{A_k}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{\lbrb{\ell_k}{a}}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}
        {\where{(\letstmt{x_k}{a}{t_k})}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}
        {\ms{L}}}
    \\
    \prftree[r]{\rle{cfg$_1$}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\forall i. \haslb{\Gamma, \bhyp{y_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{(\letstmt{x}{a}{r})}{(\lwbranch{\ell_i}{y_i}{t_i},)_i}}
        {\letstmt{x}{a}{(\where{r}{(\lwbranch{\ell_i}{y_i}{t_i},)_i})}}
        {\ms{L}}}
    \\
    \prftree[r]{\rle{cfg$_2$}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\forall i. \haslb{\Gamma, \bhyp{z_i}{C_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{(\letstmt{(x, y)}{e}{r})}{(\lwbranch{\ell_i}{z_i}{t_i},)_i}}
        {\letstmt{(x, y)}{e}{(\where{r}{(\lwbranch{\ell_i}{z_i}{t_i},)_i})}}
        {\ms{L}}}
    \\
    \prftree[r]{\rle{cfg-case}}
      {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{r_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\forall i. \haslb{\Gamma, \bhyp{y_i}{B_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {
        \prfStackPremises
        {\Gamma \vdash \where{(\casestmt{a}{x_1}{r_1}{x_2}{r_2})}
          {(\lwbranch{\ell_i}{y_i}{t_i},)_i} }
        {\approx \casestmt{a}
          {x_1}{(\where{r_1}{(\lwbranch{\ell_i}{y_i}{t_i},)_i})}
          {x_2}{\where{r_2}{(\lwbranch{\ell_i}{y_i}{t_i},)_i}} : \ms{L}}
      }
    \\
    \prftree[r]{\rle{cfg-cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {
        \prfStackPremises
        {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}
          {s_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j, (\lhyp{\kappa_k}{B_k},)_k}}
        {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}} 
      }
      {
        \prfStackPremises
        {\Gamma \vdash \where{(\where{r}{(\lwbranch{\kappa_i}{x_i}{s_i},)_i})}
          {(\lwbranch{\ell_i}{y_j}{t_j},)_j}}
        {\approx \where{r}{(\lwbranch{\kappa_i}{x_i}{s_i},)_i(\lwbranch{\ell_i}{y_j}{t_j},)_j} 
          : \ms{L}}
      }
    \\
    % % TODO: derivable from ucfg, but prove this!
    % \prftree[r]{\rle{cfg$_0$}}
    %   {\haslb{\Gamma}{r}{\ms{L}}}
    %   {\lbeq{\Gamma}{\where{r}{}}{r}{\ms{L}}}
    % \\
    % TODO: probably derivable from dinaturality? but prove...
    % \prftree[r]{\rle{wk-cfg}}
    %   {\haslb{\Gamma}{[\ell_i \mapsto \ell_{\rho\;i}]r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
    %   {\forall i, \haslb{\Gamma, \bhyp{x_i}{A_i}}
    %     {[\ell_i \mapsto \ell_{\rho\;i}]t_i}
    %     {\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    %   {\lbeq{\Gamma}
    %     {\where{[\ell_i \mapsto \ell_{\rho i}]r}
    %       {(\lwbranch{\ell_i}{x_i}{[\ell_i \mapsto \ell_{\rho\;i}]r})_i}}
    %     {\where{r}{(\lwbranch{\ell_{\rho\;i}}{x_i}{r})_i}}
    %     {\ms{L}}}
    % \\
    % TODO: note difference between this and wk-cfg
    % TODO: think about whether _this_ is derivable... maybe from dinaturality too?
    \prftree[r]{\rle{dead-cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {\forall i, \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}{\where{r}{
          (\lwbranch{\ell_i}{x_i}{s_i},)_i
          (\lwbranch{\kappa_j}{y_j}{t_j},)_j}}
        {\where{r}{(\lwbranch{\ell_i}{x_i}{s_i},)_i}}{\ms{L}}}
\end{gather*}

...

\begin{equation*}
  \cfgsubst{(\lwbranch{\ell_i}{x_i}{t_i},)_i}\;\kappa\;a
  := \where{\lbrb{\kappa}{a}}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}
\end{equation*}

...

\begin{equation*}
  \prftree[r]{\rle{cfgsubst}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbsubst{\cfgsubst{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}{\ms{L}}}
\end{equation*}

...

\begin{gather*}
  \prftree[r]{\rle{ucfg}}
    {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {
      \lbeq{\Gamma}
        {\where{r}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}
        {[\cfgsubst{(\lwbranch{\ell_i}{x_i}{t_i},)_i}]r}
        {\ms{L}}
    }
  \\
  % NOTE: in the development, it's (ret e) wseq s_0, not [e/x] s_0
  \prftree[r]{\rle{uni}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A}}{\bot}{e}{B}}
      {\haslb{\Gamma}{r}{\ms{L}, \ell(A)}}
    }
    {
      \prfStackPremises
      {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}, \kappa(B)}}
      {\haslb{\Gamma, \bhyp{x}{A}}{t}{\ms{L}, \ell(A)}}
    }
    {
      \lbeq{\Gamma, \bhyp{x}{A}}
        {[e/y]s}
        {\where{t}{\lwbranch{\ell}{x}{\lbrb{\kappa}{e}}}}
        {\ms{L}, \kappa(B)}
    }
    {
      \lbeq{\Gamma}
        {\where{(\where{r}{\lwbranch{\ell}{x}{\lbrb{\kappa}{e}}})}
          {\lwbranch{\kappa}{y}{s}}}
        {\where{r}{t}}
        {\ms{L}}
    }
  \\
  \prftree[r]{\rle{codiag}}
    {\haslb{\Gamma}{r}{\ms{L}, \ell(A)}}
    {\haslb{\Gamma, \bhyp{y}{A}}{s}{\ms{L}, \ell(A), \kappa(A)}}
    {\lbeq{\Gamma}{\where{r}{\lwbranch{\ell}{x}{\where{\lbrb{\kappa}{x}}
      {\lwbranch{\kappa}{y}{s}}}}}
    {\where{r}{\lwbranch{\ell}{y}{[\ell/\kappa]s}}}
    {\ms{L}}}
  \\
  \prftree[r]{\rle{dinat}}
  {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
  {\forall i, \haslb{\Gamma, \bhyp{x_i}{B_i}}
    {t_i}
    {\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
  {\lbsubst{\sigma}{(\lhyp{\ell_i}{A_i},)_i}{\ms{L}, (\lhyp{\kappa_i}{B_i},)_i}}
  {\lbeq{\Gamma}
    {\where{[\sigma]r}
      {(\lwbranch{\kappa_i}{x_i}{[\sigma]t_i},)_i}}
    {\where{r}{(\lwbranch{\ell_{i}}{x_i}{[(\lwbranch{\kappa_j}{x_j}{t_j},)_j](\sigma_i)})_i}}
    {\ms{L}}}
\end{gather*}

\TODO{soundness of region equational theory (diagrams?)}

\TODO{notes on completeness? derivable equations?}

\section{Normalization}

\TODO{to Expr...}

\TODO{to BBRegion...}

\TODO{to TRegion ...}

\TODO{to ContRegion ...}

\section{Böhm–Jacopini}

\TODO{this...}

\end{document}
\endinput
