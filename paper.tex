%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{fancyvrb}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}
\newcommand{\sorry}{\textcolor{red}{\textbf{sorry}}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{TODO \arabic{todos}: #1}}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

% Math
\newcommand{\nats}{\mathbb{N}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{\Rightarrow}
\newcommand{\linl}[1]{\ms{inl}\;{#1}}
\newcommand{\linr}[1]{\ms{inr}\;{#1}}
\newcommand{\labort}[1]{\ms{abort}\;{#1}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2;\;#3}}
\newcommand{\caseexpr}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\lbrb}[2]{\brb{\lbl{#1}}{#2}}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\casestmt}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\where}[2]{#1\;\ms{where}\;#2}
\newcommand{\wbranch}[3]{#1(#2) \lto \{#3\}}
\newcommand{\lwbranch}[3]{\wbranch{\lbl{#1}}{#2}{#3}}
\newcommand{\cfgsubst}[1]{\ms{cfgs}\;\{#1\}}
\newcommand{\wseq}[2]{{#1} \mathbin{{;}{;}} {#2}}

% Judgements
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[2]{#1 \rightsquigarrow #2}
\newcommand{\thyp}[3]{#1 : {#2}^{#3}}
\newcommand{\bhyp}[2]{#1 : #2}
\newcommand{\lhyp}[2]{#1(#2)}
\newcommand{\llhyp}[2]{\lhyp{\lbl{#1}}{#2}}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\hasty}[4]{#1 \vdash_{#2} #3: {#4}}
\newcommand{\haslb}[3]{#1 \vdash #2 \rhd #3}
\newcommand{\isop}[4]{#1: #2 \to_{#4} #3}
\newcommand{\issubst}[3]{#1: #2 \mapsto #3}
\newcommand{\lbsubst}[3]{#1: #2 \rightsquigarrow #3}
\newcommand{\teqv}{\approx}
\newcommand{\tmeq}[5]{#1 \vdash_{#2} #3 \teqv #4 : {#5}}
\newcommand{\lbeq}[4]{#1 \vdash #2 \teqv #3 : {#4}}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}

% Branding
\newcommand{\isotopessa}{\(\lambda_{\ms{SSA}}\)}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{The Denotational Semantics of SSA}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\begin{abstract}
  ...
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

\section{Introduction}

Static single assignment form, or SSA form, has been the dominant
compiler intermediate representation since its introduction by
\citet{ssa-intro} in the later 1980s. Every major compiler -- GCC, Clang,
MLIR, Cranelift -- uses this representation, because it makes many
optimizations much easier to do than traditional 3-address code IRs.

The key idea behind SSA is to adapt an idea from functional
programming: namely, every variable is defined only once. This means
that substitution is unconditionally valid, without first requiring a
dataflow analysis to compute where definitions reach. Unlike in
functional programming, though, scoping of definitions in SSA is
traditionally not lexical. Instead, scoping is determined by
\emph{dominance}: every variable occurence must be dominated by a
single assignment in the control flow graph.

The semantics of SSA has traditionally been handled quite informally,
because conceptually, it is a simple first-order imperative
programming language. As a result, whether a rewrite is sound or
not is usually obvious, without having to do a complex correctness
argument.

Unfortunately, computers are no longer as simple as they were in the
late 1980s. Modern computers are typically multicore, and feature many
levels of caching, and as a result the semantics of memory is no
longer correctly modelled as a big array of bytes. Finding good
semantics for modern weak memory systems remains an ongoing challenge.

As a result, it is not correct to justify compiler optimizations in
terms of a simple imperative model, and it is an open question which
equations should hold of an SSA program. This is a particularly
fraught question, because it is also unclear which equations weak
memory models should satisfy.

What we would like to know which equations any SSA representation
should satisfy. This would let us establish a contract between
compiler writers and hardware designers. The compiler writers could
rely upon the equational theory of SSA when justifying optimizations,
without needing to know all the details of the memory model at all
times.  Conversely, memory models could be validated by seeing if they
satisfy the equations of SSA, without needing to study every possible
compiler optimization.

Concretely, our contributions are as follows: 

\begin{itemize}
\item First, we give a type-theoretic presentation of SSA, with both typing rules and an equational
  theory for well-typed terms. We also prove the correctness of suitable substitution properties for
  this calculus. 
  
\item Next, we give a categorical semantics for this type theory, in terms of distributive Elgot
  categories. We show that any denotational model with this categorical structure is also a model of
  SSA. This shows that all of the equations we give are sound with respect to the categorical
  structure. 

\item We also show that syntax quotiented by the equational theory yields the initial distributive
  Elgot category. This establishes that our set of syntactic equations is complete, and that there
  are no equations which the denotational semantics validates, but which cannot be proved
  syntactically. 

\item We show that this denotational axiomatization is useful in practice, by giving a variety of
  concrete models, including a model of TSO weak memory based on~\cite{sparky}. This demonstrates
  that it is possible to give realistic weak memory models which do not disturb the structure of SSA
  in fundamental ways.

\item Finally, we have substantially mechanized our proofs using the Lean 4 proof assistant. We have
  mechanized proofs of substitution for our type theory, as well as proofs that the syntax forms the
  initial model, and that the SPARC TSO semantics forms a valid model of SSA. The denotational
  semantics and its proof of the soundness of substitution are done on paper. 

\end{itemize}

\section{Static Single Assignment Form}

Consider the following simple program to compute $10!$
\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{let\;mut}\;i = 1; \\
  & \ms{let\;mut}\;a = 1; \\
  & \ms{while}\;i_0 < n\;\{ \\
  & \quad i = i + 1; \\
  & \quad a = a * i \\
  & \} \\
  & \ms{ret}\;a
\end{align*}
A compiler might translate this to SSA as follows:
\begin{align*}
  \ms{start}:\quad & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop} \\
  \ms{loop}: \quad  & i_0 = \phi(\ms{start}: 1, \ms{body}: i_1) \\
                    & a_0 = \phi(\ms{start}: 1, \ms{body}: a_1) \\
                    & \ms{if}\;i_0 < n\;
                      \{\;\ms{br}\;\ms{body}\;\}\;
                      \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
  \ms{body}: \quad  & i_1 = i_0 + 1 \\
                    & a_1 = a_0 * i_1 \\
                    & \ms{br}\;\ms{loop}
\end{align*}

\begin{itemize}
  \item Introduce $\phi$ to avoid redefinition of $i$, $a$, due to single definition principle
  \item Otherwise, number definitions
  \item $\phi$ is a bit confusing to write, but is isomorphic to using basic-blocks with arguments
  instead:
\end{itemize}

\begin{align*}
  \ms{start}:\quad & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}(1, 1) \\
  \ms{loop}(i_0, a_0): \quad & \ms{if}\;i_0 < n\;
                      \{\;\ms{br}\;\ms{body}\;\}\;
                      \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
  \ms{body}: \quad  & i_1 = i_0 + 1 \\
                    & a_1 = a_0 * i_1 \\
                    & \ms{br}\;\ms{loop}(i_1, a_1)
\end{align*}

\begin{itemize}
  \item Isomorphism is trivial: we just move the definition from the $\phi$ to the call-site
  \item This makes scoping a lot more clear:
  \item In SSA, to use a variable, it must be defined once we reach the use-point, or else UB
  \item Variables can only be defined at exactly one point
  \item Safe approximation: all paths to the use point must cross the definition point at least once
  \item i.e. use point must \textit{dominate} definition point
  \item \begin{itemize}
    \item Can recover UB/undef behaviour, or something else, via args, if you really want to
    \item Probably don't even bother mentioning this...
  \end{itemize}
  \item Within a basic block: later variables use earlier ones
  \item Between basic blocks: all paths through the cfg to the use-block must pass through the def
        block
  \item i.e. use-block must \textit{strictly dominate} def-block (all blocks dominate themselves,
  but see "within BB" rule)
  \item Examples: \begin{itemize}
    \item start strictly dominates loop
    \item loop strictly dominates body
    \item loop does not strictly dominate loop since loop $=$ loop
    \item body does not strictly dominate loop since we can get to loop via start, without passing
    body
  \end{itemize}
  \item In general, dominance always forms a tree (explain? cite?)
  \item Can topologically sort CFG by dominance tree, and then insert brackets for lexical scoping:
\end{itemize}

\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}(1, 1) \\
  & \ms{loop}(i_0, a_0): \{\\
  & \quad \ms{if}\;i_0 < n\;
              \{\;\ms{br}\;\ms{body}\;\}\;
                  \ms{else}\;\{\;\ms{ret}\;a_0\;\} \\
  & \quad \ms{body}: \{\\ 
  & \qquad i_1 = i_0 + 1 \\
  & \qquad a_1 = a_0 * i_1 \\
  & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
  & \quad \} \\
  & \}
\end{align*}

\begin{itemize}
  \item Interconversion is easy:
  \begin{itemize}
    \item Remove brackets to go to SSA
    \item Add brackets to go to lexical-SSA; a consistent bracketing always exists because a
    dominance tree always exists
    \item Different consistent bracketings must be semantically equivalent
  \end{itemize}

  \item Now that we have lexical scoping, we want a nice equational theory. Need:
  \begin{itemize}
    \item \textit{Control-flow rewriting}, e.g. jump-threading, fusing redundant branches...
    \item \textit{Substitution}, to allow \textit{algebraic reasoning}, which is half the point of
    SSA...
  \end{itemize}

  \item In current format, this still a pain to express. Can allow if-then-else to jump to code,
        rather than just a branch, likeso:
\end{itemize}

\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}(1, 1) \\
  & \ms{loop}(i_0, a_0): \{\\
  & \quad \ms{if}\;i_0 < n\;\{ \\
  & \qquad i_1 = i_0 + 1 \\
  & \qquad a_1 = a_0 * i_1 \\
  & \qquad \ms{br}\;\ms{loop}(i_1, a_1) \\
  & \quad \}\;\ms{else}\;\{ \\
  & \qquad \ms{ret}\;a_0 \\
  & \quad \} \\
  & \}
\end{align*}

\begin{itemize}
  \item This can trivially be seen to add no additional expressive power: can be eliminated by
        introducing anonymous basic blocks for branches and jumping to them
  \item We now have essentially ANF, cite this
  \item Can generalize to TSSA (like MNF but not higher-order); by adding an \textit{expression
  language}
  \item This lets us state \textit{substitutions}, like
\end{itemize}

\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}(1, 1) \\
  & \ms{loop}(i_0, a_0): \{\\
  & \quad \ms{if}\;i_0 < n\;\{ \\
  & \qquad \ms{br}\;\ms{loop}(i_0 + 1, a_0 * (i_0 + 1)) \\
  & \quad \}\;\ms{else}\;\{ \\
  & \qquad \ms{ret}\;a_0 \\
  & \quad \} \\
  & \}
\end{align*}

\begin{itemize}
  \item We can then do \textit{algebra}, for example, we know that:
  \item \begin{itemize}
    \item $(i_0 + 1, a_0 * (i_0 + 1)) 
      = (\ms{let}\;(x, y) = (i_0, a_0)\;\ms{in}\;(x + 1, y * (x + 1)))$
    \item $(1, 1)
    = (\ms{let}\;(x, y) = (0, 1)\;\ms{in}\;(x + 1, y * (x + 1)))$
  \end{itemize}
  \item So therefore the program above is
\end{itemize}

\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}(\ms{let}\;(x, y) = (0, 1)\;\ms{in}\;(x + 1, y * (x + 1))) \\
  & \ms{loop}(i_0, a_0): \{\\
  & \quad \ms{if}\;i_0 < n\;\{ \\
  & \qquad \ms{br}\;\ms{loop}(
    \ms{let}\;(x, y) = (i_0, a_0)\;\ms{in}\;(x + 1, y * (x + 1))) \\
  & \quad \}\;\ms{else}\;\{ \\
  & \qquad \ms{ret}\;a_0 \\
  & \quad \} \\
  & \}
\end{align*}

\begin{itemize}
  \item which by \textit{uniformity} is equal to
\end{itemize}

\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}\;(0, 1) \\
  & \ms{loop}(x, y): \{\\
  & \quad \ms{let}\;i_0 = x + 1; \\
  & \quad \ms{let}\;a_0 = y * (x + 1); \\
  & \quad \ms{if}\;i_0 < n\;\{ \\
  & \qquad \ms{br}\;\ms{loop}(i_0, a_0) \\
  & \quad \}\;\ms{else}\;\{ \\
  & \qquad \ms{ret}\;a_0 \\
  & \quad \} \\
  & \}
\end{align*}

\begin{itemize}
  \item or, by further substitution,
\end{itemize}


\begin{align*}
  & \ms{let}\;n = 10; \\
  & \ms{br}\;\ms{loop}\;(0, 1) \\
  & \ms{loop}(x, y): \{\\
  & \quad \ms{let}\;i_0 = x + 1; \\
  & \quad \ms{let}\;a_0 = y * i_0; \\
  & \quad \ms{if}\;i_0 < n\;\{ \\
  & \qquad \ms{br}\;\ms{loop}(i_0, a_0) \\
  & \quad \}\;\ms{else}\;\{ \\
  & \qquad \ms{ret}\;a_0 \\
  & \quad \} \\
  & \}
\end{align*}

\begin{itemize}
  \item In other words, we can do \textit{complex}, \textit{error-prone} loop and control-flow graph
        optimizations by breaking them down into closed set of simple algebraic steps
  \item We can justify each such step is sound rigorously via our denotational semantics
  \item We can show that our steps are \textit{complete} by showing that quotienting by them gives
        a model of our denotational semantics
  \item That's why we use TSSA
  \item But we gain no additional power: SSA $\subseteq$ TSSA; this is a retraction
  (embedding-projection)
  \item In particular, using the steps, every TSSA program can be converted to an SSA program with
        equivalent semantics, while every SSA program is already a TSSA program (just add brackets!)
  \item Unproven conjecture: this should take \~linear time, and the resuling program should be
  \~linearly sized. Do on paper?
  \item TODO: this transformation backwards would actually eliminate an unnecessary MUL, rather than
  add one. Pedantry?
\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\clearpage 

\appendix

\section{Syntax and Typing Rules}

\begin{figure}[H]
  \begin{center}
    \begin{grammar}
      <\(A, B, C\)> ::= 
      \(X\)
      \;|\; \(A \otimes B\)
      \;|\; \(\mathbf{1}\)
      \;|\; \(A + B\)
      \;|\; \(\mathbf{0}\)

      <\(a, b, c, e\)> ::= \(x\) 
      \;|\;  \(f\;a\)
      \;|\; \(\letexpr{x}{a}{e}\)
      \alt  \(()\)
      \;|\; \((a, b)\)
      \;|\; \(\letexpr{(x, y)}{a}{e}\)
      \alt  \(\linl{a}\) 
      \;|\; \(\linr{a}\)
      \;|\; \(\labort{a}\)
      \;|\; \(\caseexpr{e}{x}{s}{y}{t}\)
      
      <\(s, t\)> ::= \(\lbrb{\ell}{a}\) 
      \alt  \(\letstmt{x}{a}{t}\)
      \;|\; \(\letstmt{(x, y)}{a}{t}\)
      \;|\; \(\casestmt{e}{x}{s}{y}{t}\)
      \alt  \(\where{t}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}\)

      <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, \thyp{x}{A}{\epsilon}\)

      <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \llhyp{\ell}{A}\)
    \end{grammar}
  \end{center}
  \caption{Grammar for \isotopessa, parametrized over a set of instructions \(f \in \mc{I}\)}
  \Description{Grammar for isotope-SSA}
  \label{fig:ssa-grammar}
\end{figure}

\begin{figure}[H]
  \begin{gather*}
    \prftree[r]{\rle{var}}{\Gamma\;x \leq (A, \epsilon)}{\hasty{\Gamma}{\epsilon}{x}{A}} \qquad
    \prftree[r]{\rle{op}}{\isop{f}{A}{B}{\epsilon}}{\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma}{\epsilon}{f\;a}{B}} \qquad
    \prftree[r]{\rle{let$_1$}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{B}} \\
    \prftree[r]{\rle{unit}}{\hasty{\Gamma}{\epsilon}{()}{\mb{1}}} \qquad
    \prftree[r]{\rle{pair}}{\hasty{\Gamma}{\epsilon}{a}{A}}{\hasty{\Gamma}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{(A, B)}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
      {\hasty{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{C}} \\
    \prftree[r]{\rle{inl}}{\hasty{\Gamma}{\epsilon}{a}{A}}
      {\hasty{\Gamma}{\epsilon}{\linl{a}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}{\hasty{\Gamma}{\epsilon}{b}{B}}
      {\hasty{\Gamma}{\epsilon}{\linr{b}}{A + B}} \qquad
    \prftree[r]{\rle{abort}}{\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma}{\epsilon}{\labort{a}}{A}} \\
    \prftree[r]{\rle{case}}
      {\hasty{\Gamma}{\epsilon}{e}{A + B}}
      {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
      {\hasty{\Gamma, \bhyp{y}{A}}{\epsilon}{b}{C}}
      {\hasty{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}}
  \end{gather*}
  \caption{Rules for typing \isotopessa terms}
  \Description{Rules for typing isotope-SSA terms}
  \label{fig:ssa-term-rules}
\end{figure}

\begin{figure}[H]
  \begin{gather*}
    \prftree[r]{\rle{br}}{\hasty{\Gamma}{\bot}{a}{A}}{\ms{L}\;\lbl{\ell} = A}
      {\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} \qquad
    \prftree[r]{\rle{let$_1$-r}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      {\haslb{\Gamma}{\letstmt{x}{a}{r}}{\ms{L}}} \\
    \prftree[r]{\rle{let$_2$-r}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
      {\haslb{\Gamma}{\letstmt{(x, y)}{e}{r}}{\ms{L}}} \\
    \prftree[r]{\rle{case-r}}
      {\hasty{\Gamma}{\epsilon}{e}{A + B}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
      {\haslb{\Gamma}{\casestmt{e}{x}{r}{y}{s}}{\ms{L}}} \\
    \prftree[r]{\rle{cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\haslb{\Gamma}{\where{r}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}{\ms{L}}}
  \end{gather*}
  \caption{Rules for typing \isotopessa regions}
  \Description{Rules for typing isotope-SSA regions}
  \label{fig:ssa-reg-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Rules for typing \isotopessa substitutions}
  \Description{Rules for typing isotope-SSA substitutions}
  \label{fig:ssa-vsubst-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Rules for typing \isotopessa label-substitutions}
  \Description{Rules for typing isotope-SSA label-substitutions}
  \label{fig:ssa-lsubst-rules}
\end{figure}

\begin{figure}[H]
  \TODO{this}
  \caption{Syntax and typing for \isotopessa composition}
  \Description{Syntax and typing for isotope-SSA composition}
  \label{fig:ssa-compose}
\end{figure}

\section{Denotational Semantics}


\begin{figure}[H]
  \TODO{this}
  \caption{Denotational semantics for \isotopessa types and contexts}
  \Description{Denotational semantics for isotope-SSA types and contexts}
  \label{fig:ssa-ty-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\hasty{\Gamma}{\epsilon}{a}{A}} : \dnt{\Gamma} \to_\epsilon \dnt{A}}
  \end{equation*}
  \begin{align*}
    \dnt{\hasty{\Gamma}{\epsilon}{x}{A}} &= \pi_{\Gamma, x} \\
    \dnt{\hasty{\Gamma}{\epsilon}{f\;a}{B}} 
      &= \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} ; \dnt{\isop{f}{A}{B}{\epsilon}} \\
    \dnt{\hasty{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{B}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{a}{A}};
      \\&\quad\; 
      \dnt{\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{(a, b)}{A \otimes B}} 
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} \ltimes \dnt{\hasty{\Gamma}{\epsilon}{b}{B}}
      % ; \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} \otimes \dnt{\Gamma} 
      % ; \dnt{A} \otimes \dnt{\hasty{\Gamma}{\epsilon}{b}{B}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{C}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{e}{A \otimes B}} ;
      \\&\quad\; 
      \dnt{\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{()}{\mb{1}}} &= 1_{\dnt{\Gamma}} \\
    \dnt{\hasty{\Gamma}{\epsilon}{\linl{a}}{A + B}}
      &= \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} ; \iota_l \\
    \dnt{\hasty{\Gamma}{\epsilon}{\linr{b}}{A + B}}
      &= \dnt{\hasty{\Gamma}{\epsilon}{b}{B}} ; \iota_r \\
    \dnt{\hasty{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}}
      &= \dnt{\hasty{\Gamma}{\epsilon}{e}{A + B}}
      ; \\& \quad\; 
      \dnt{\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{A}}
      + \dnt{\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{B}}
      \\
    \dnt{\hasty{\Gamma}{\epsilon}{\labort{a}}{A}} 
      &= \dnt{\hasty{\Gamma}{\epsilon}{a}{\mb{0}}} ; 0_{\dnt{A}}
  \end{align*}
  \caption{Denotational semantics for \isotopessa terms}
  \Description{Denotational semantics for isotope-SSA terms}
  \label{fig:ssa-term-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\haslb{\Gamma}{r}{\ms{L}}} : \dnt{\Gamma} \to \dnt{\ms{L}}}
  \end{equation*}
  \begin{align*}
    \dnt{\haslb{\Gamma}{\lbrb{\ell}{a}}{\ms{L}}} 
      &= \dnt{\hasty{\Gamma}{\bot}{a}{A}} ; \iota_{\ms{L}, \ell}
      \\
    \dnt{\haslb{\Gamma}{\letstmt{x}{a}{r}}{\ms{L}}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{a}{A}}
      ; \dnt{\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}} 
      \\
    \dnt{\haslb{\Gamma}{\letstmt{(x, y)}{e}{r}}{\ms{L}}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      ; \dnt{\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}} 
      \\ 
    \dnt{\haslb{\Gamma}{\casestmt{e}{x}{r}{y}{s}}{\ms{L}}}
      &= \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\hasty{\Gamma}{\epsilon}{e}{A + B}}
      ; \delta^{-1} ;
      \\&\quad\;
      \dnt{\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
      + \dnt{\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
      \\
    \dnt{\haslb{\Gamma}{\where{r}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}{\ms{L}}}
      &=  
      \Delta_{\dnt{\Gamma}}
      ; \dnt{\Gamma} \otimes \dnt{\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}} 
      ; \delta^{-1} ;
      \alpha^+_{}
      \\ &\quad\;
      (
        \Sigma_i (\Delta_{\dnt{\Gamma}} 
          ; \dnt{\Gamma} \otimes 
            \dnt{\haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
          ; 
          )
      )^\dagger
  \end{align*}
  \caption{Denotational semantics for \isotopessa regions}
  \Description{Denotational semantics for isotope-SSA regions}
  \label{fig:ssa-reg-sem}
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\issubst{\gamma}{\Gamma}{\Delta}} 
      : \dnt{\Gamma} \to_{\epsilon_\Delta} \dnt{\Delta}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa substitutions}
  \Description{Denotational semantics for isotope-SSA substitutions}
  \label{fig:ssa-vsubst-sem} 
\end{figure}

\begin{figure}[H]
  \begin{equation*}
    \boxed{\dnt{\lbsubst{\kappa}{\ms{L}}{\ms{K}}} 
      : \dnt{\ms{L}} \to \dnt{\ms{K}}}
  \end{equation*}
  \TODO{this}
  \caption{Denotational semantics for \isotopessa label-substitutions}
  \Description{Denotational semantics for isotope-SSA label-substitutions}
  \label{fig:ssa-lsubst-sem}
\end{figure}

\section{Equational Theory}

\subsection{Terms}

\TODO{write nicer fused version?}

\TODO{\textit{formalize} nicer fused version?}

\begin{gather*}
  \prftree[r]{\rle{refl}}{\hasty{\Gamma}{\epsilon}{a}{A}}{\tmeq{\Gamma}{\epsilon}{a}{a}{A}} \qquad
  \prftree[r]{\rle{trans}}
    {\tmeq{\Gamma}{\epsilon}{a}{b}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{c}{A}} 
    {\tmeq{\Gamma}{\epsilon}{a}{c}{A}} \qquad
  \prftree[r]{\rle{symm}}
    {\tmeq{\Gamma}{\epsilon}{a}{b}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{a}{A}}
  \\
  \prftree[r]{\rle{let$_1$-bind}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{\letexpr{x}{a'}{b}}{B}} 
  \\
  \prftree[r]{\rle{let$_1$-bound}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{\letexpr{x}{a}{b'}}{B}}
  \\
  \prftree[r]{\rle{pair-l}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{(a, b)}{(a', b)}{A \otimes B}} \qquad
  \prftree[r]{\rle{pair-r}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{(a, b)}{(a, b')}{A \otimes B}}
  \\
  \prftree[r]{\rle{let$_2$-bind}}
    {\tmeq{\Gamma}{\epsilon}{e}{e'}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{\letexpr{(x, y)}{e'}{c}}{C}}
  \\
  \prftree[r]{\rle{let$_2$-bound}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\tmeq{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{c}}{\letexpr{(x, y)}{e}{c'}}{C}}
  \\
  \prftree[r]{\rle{inl}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\tmeq{\Gamma}{\epsilon}{\linl{a}}{\linl{a'}}{A + B}} \qquad
  \prftree[r]{\rle{inr}}
    {\tmeq{\Gamma}{\epsilon}{b}{b'}{B}}
    {\tmeq{\Gamma}{\epsilon}{\linr{b}}{\linr{b'}}{A + B}} \qquad
  \\
  \prftree[r]{\rle{abort}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{\mb{0}}}
    {\tmeq{\Gamma}{\epsilon}{\labort{a}}{\labort{a'}}{A}}
  \\
  \prftree[r]{\rle{case-d}}
    {\tmeq{\Gamma}{\epsilon}{e}{e'}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a}{y}{b}}{C}}
  \\
  \prftree[r]{\rle{case-l}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\tmeq{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{a'}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a'}{y}{b}}{C}}
  \\
  \prftree[r]{\rle{case-r}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\tmeq{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{b'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a}{y}{b'}}{C}}
\end{gather*}


\begin{gather*}
  \prftree[r]{\rle{let$_1$-$\beta$}}
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{b}}{[b/x]a}{B}}
  \qquad
  \prftree[r]{\rle{let$_1$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{x}{a}{x}}{a}{A}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-op}}
    {\isop{f}{A}{B}{\epsilon}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{f\;a}{c}}{\letexpr{x}{a}{\letexpr{f\;x}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-let$_1$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{y}{(\letexpr{x}{a}{b})}{c}}
      {\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-let$_2$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \times B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{C}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{z}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{z}{(\letexpr{(x, y)}{e}{c})}{d}}
      {\letexpr{(x, y)}{e}{\letexpr{z}{c}{d}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{\linl{a}}{c}}{\letexpr{x}{a}{\letexpr{\linl{x}}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{C}}{\epsilon}{d}{D}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{y}{\linr{b}}{c}}{\letexpr{x}{b}{\letexpr{\linr{x}}{y}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_1$-abort}}
    {\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
    {\hasty{\Gamma, \bhyp{y}{A}}{\epsilon}{b}{B}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{y}{\labort{b}}{b}}
      {\letexpr{x}{a}{\letexpr{y}{\labort{x}}{b}}}{B}}
  \\
  \prftree[r]{\rle{let$_1$-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{a}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{b}{C}}
    {\hasty{\Gamma, \bhyp{z}{C}}{\epsilon}{d}{D}}
    { 
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{z}{(\caseexpr{e}{x}{a}{y}{b})}{d}}
      {\hspace{6em} \teqv \caseexpr{e}{x}{\letexpr{z}{a}{d}}{\letexpr{z}{b}{d}}{b} : D}
    }
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_2$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{e}{(x, y)}}{e}{A \otimes B}} 
  \\
  \prftree[r]{\rle{let$_2$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}{\letexpr{(x, y)}{(a, b)}{c}}{\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}}
  \\
  \prftree[r]{\rle{let$_2$-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\letexpr{(x, y)}{e}{c}}
      {\letexpr{z}{e}{\letexpr{z}{e}{c}}}{C}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{case-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{\linl{a}}{x}{c}{y}{d}}{\letexpr{x}{a}{c}}{C}}
  \\
  \prftree[r]{\rle{case-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{\linr{b}}{x}{c}{y}{d}}{\letexpr{y}{b}{d}}{C}}
  \\
  \prftree[r]{\rle{case-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{\linl{x}}{y}{\linr{y}}}{e}{A + B}}
  \\
  \prftree[r]{\rle{case-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{c}{y}{d}}{\letexpr{z}{e}{\caseexpr{z}{x}{c}{y}{d}}}{C}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{A}}{\epsilon}{d}{D}}
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z'}{B}}{\epsilon}{d'}{D}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{x}{a}{\letexpr{y}{c}{\caseexpr{x}{z}{d}{z'}{d'}}}}
      {\hspace{6em} \teqv \letexpr{x}{a}{\caseexpr{x}{z}{\letexpr{y}{c}{d}}{z'}{\letexpr{y}{c}{d'}}} 
      : D}
    }
  \\
  \prftree[r]{\rle{let$_2$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{c}{C \otimes D}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{D}, \bhyp{w}{A}}{\epsilon}{e}{E}}
      {\hasty{\Gamma, \bhyp{x}{A + B}, \bhyp{y}{C}, \bhyp{z}{D}, \bhyp{w'}{B}}{\epsilon}{e'}{E}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \letexpr{x}{a}{\letexpr{(y, z)}{c}{\caseexpr{x}{w}{e}{w'}{e'}}}}
      {\hspace{5em} \teqv \letexpr{x}{a}
        {\caseexpr{x}
          {w}{\letexpr{(y, z)}{c}{e}}
          {w'}{\letexpr{(y, z)}{c}{e'}}} 
      : E}
    }
  \\
  \prftree[r]{\rle{case-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A + B}}{\epsilon}{b}{B_1 + B_2}}
    {
      \forall i j.
      \hasty{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y_i}{B_i}, \bhyp{z_j}{A_j}}{\epsilon}
            {c_{ij}}{C}
    }
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon 
        \ms{let}\;x = a;
        \ms{case}\;b\;\{\ms{inl}\;y_1 \Rightarrow \caseexpr{x}{z_1}{e_{11}}{z_2}{e_{12}}
      }
      {
        \hspace{10em} \ms{inr}\;y_2 \Rightarrow \caseexpr{x}{z_1}{e_{21}}{z_2}{e_{22}} \}
      }
      {\hspace{1.3em} \teqv
        \ms{let}\;x = a;
        \ms{case}\;x\;\{\ms{inl}\;z_1 \Rightarrow \caseexpr{b}{y_1}{e_{11}}{y_2}{e_{21}}
      }
      {
        \hspace{10em} \ms{inr}\;z_2 \Rightarrow \caseexpr{b}{y_1}{e_{12}}{y_2}{e_{22}} \}
      }
    }
  \\
  \prftree[r]{\rle{op-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\isop{f}{C}{D}{\epsilon}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{f\;c}{y}{f\;c'}}{f\;\caseexpr{e}{x}{c}{y}{c'}}{D}}
  \\
  \prftree[r]{\rle{inl-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{C}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{C}}
    {\tmeq{\Gamma}{\epsilon}
      {\caseexpr{e}{x}{\linl{c}}{y}{\linl{c'}}}
      {\linl{\caseexpr{e}{x}{c}{y}{c'}}}
      {C + D}}
  \\
  \prftree[r]{\rle{inr-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{d}{D}}
    {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{d'}{D}}
    {\tmeq{\Gamma}{\epsilon}
      {\caseexpr{e}{x}{\linr{d}}{y}{\linr{d'}}}
      {\linr{\caseexpr{e}{x}{d}{y}{d'}}}
      {C + D}}
  \\
  \prftree[r]{\rle{abort-case}}
  {\hasty{\Gamma}{\epsilon}{e}{A + B}}
  {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{c}{\mb{0}}}
  {\hasty{\Gamma, \bhyp{y}{B}}{\epsilon}{c'}{\mb{0}}}
  {
    \prfStackPremises
    {\Gamma \vdash_\epsilon \caseexpr{e}{x}{\labort{c}}{y}{\labort{c'}}}
    {\approx \labort{\caseexpr{e}{x}{c}{y}{c'}} : C}
  }
  \\
  \prftree[r]{\rle{pair-case}}
    {\hasty{\Gamma}{\epsilon}{e}{A_1 + A_2}}
    {\forall i, \hasty{\Gamma, \bhyp{x_i}{A_i}}{\epsilon}{b_{ij}}{B_j}}
    {
      \prfStackPremises
      {\Gamma \vdash_\epsilon \caseexpr{e}{x}{(b_{11}, b_{12})}{y}{(b_{21}, b_{22})}}
      {\approx (\caseexpr{e}{x}{b_{11}}{y}{b_{21}}, \caseexpr{e}{x}{b_{12}}{y}{b_{22}}) 
      : B_1 \otimes B_2}
    }
  \\
  \prftree[r]{\rle{case$_0$}}
    {\hasty{\Gamma}{\epsilon}{e}{A_1 + A_2}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\tmeq{\Gamma}{\epsilon}{\caseexpr{e}{x}{a}{y}{a}}{a}{A}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{initial}} 
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\hasty{\Gamma}{\bot}{a'}{A}}
    {\exists x, \Gamma\;x = \mb{0}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    \qquad
  \prftree[r]{\rle{terminal}}
    {\hasty{\Gamma}{\bot}{a}{\mb{1}}}
    {\hasty{\Gamma}{\bot}{a'}{\mb{1}}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{\mb{1}}}
\end{gather*}

\TODO{soundness of term equational theory (diagrams?)}

\TODO{notes on completeness? derivable equations?}

\subsection{Regions}

\begin{gather*}
  \prftree[r]{\rle{refl}}{\haslb{\Gamma}{r}{\ms{L}}}{\lbeq{\Gamma}{r}{r}{\ms{L}}} \qquad
  \prftree[r]{\rle{trans}}{\lbeq{\Gamma}{r}{s}{\ms{L}}}{\lbeq{\Gamma}{s}{t}{\ms{L}}}
    {\lbeq{\Gamma}{r}{t}{\ms{L}}} \qquad
  \prftree[r]{\rle{symm}}{\lbeq{\Gamma}{r}{s}{\ms{L}}}{\lbeq{\Gamma}{s}{r}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-left}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\lbeq{\Gamma, \bhyp{x}{A}}{r}{r'}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\caseexpr{e}{x}{r'}{y}{s}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-right}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma, \bhyp{y}{B}}{s}{s'}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\caseexpr{e}{x}{r}{y}{s'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let}$_1$}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\lbeq{\Gamma, \bhyp{x}{A}}{r}{r'}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{x}{a}{r'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let}$_2$}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\lbeq{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{r'}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{r}}{\letstmt{(x, y)}{e}{r'}}{\ms{L}}}
  \\
  \prftree[r]{\rle{cfg-entry}}
    {\lbeq{\Gamma}{r}{r'}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbeq{\Gamma}
      {\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\where{r'}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\ms{L}}
    }
  \\
  \prftree[r]{\rle{cfg-block}}
    {\haslb{\Gamma}{r}{\ms{L}}}
    {\forall i. \lbeq{\Gamma, \bhyp{x_i}{A_i}}{t_i}{t_i'}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbeq{\Gamma}
      {\where{r}{(\lwbranch{\ell_i}{x_i: A_i}{t_i},)_i}}
      {\where{r'}{(\lwbranch{\ell_i}{x_i: A_i}{t_i'},)_i}}
      {\ms{L}}
    }
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-$\beta$}}
    {\hasty{\Gamma}{\bot}{a}{A}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{[r/x]a}{\ms{L}}}
  \qquad
  \prftree[r]{\rle{let$_1$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{a}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{y}{a}{\letstmt{x}{y}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{1\approx}$}}
    {\tmeq{\Gamma}{\epsilon}{a}{a'}{A}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{x}{a}{r}}{\letstmt{x}{a'}{r}}{\ms{L}}}
  \qquad
  \prftree[r]{\rle{initial}}
    {\haslb{\Gamma}{r}{\ms{L}}}
    {\haslb{\Gamma}{s}{\ms{L}}}
    {\exists x, \Gamma\;x = \mb{0}}
    {\lbeq{\Gamma}{r}{s}{\ms{L}}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_1$-op}}
    {\isop{f}{A}{B}{\epsilon}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\haslb{\Gamma, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{f\;a}{r}}{\letstmt{x}{a}{\letstmt{y}{f\;x}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{1}$-let$_1$}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma, \bhyp{x}{A}}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{(\letexpr{x}{a}{b})}{r}}{\letstmt{x}{a}{\letstmt{y}{b}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{z}{A \otimes B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}
      {\letstmt{z}{(a, b)}{r}}
      {\letstmt{x}{a}{\letstmt{y}{b}{\letstmt{z}{(x, y)}{r}}}}
      {\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{1}$-let$_2$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\hasty{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{\epsilon}{c}{C}}
    {\haslb{\Gamma, \bhyp{z}{C}}{r}{\ms{L}}}
    {\lbeq{\Gamma}
      {\letstmt{z}{(\letexpr{(x, y)}{e}{c})}{r}}
      {\letstmt{(x, y)}{e}{\letstmt{z}{c}{r}}}
      {\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\haslb{\Gamma, \bhyp{y}{A + B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{\linl{a}}{r}}{\letstmt{x}{a}{\letstmt{\linl{x}}{y}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{y}{A + B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{\linr{b}}{r}}{\letstmt{x}{b}{\letstmt{\linr{x}}{y}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_1$-abort}}
    {\hasty{\Gamma}{\epsilon}{a}{\mb{0}}}
    {\haslb{\Gamma, \bhyp{y}{A}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{y}{\labort{a}}{r}}{\letstmt{x}{a}{\letstmt{y}{\labort{x}}{r}}}{\ms{L}}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{let$_2$-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{r}}{\letstmt{z}{e}{\letstmt{(x, y)}{z}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_2$-pair}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{(a, b)}{r}}{\letstmt{x}{a}{\letstmt{y}{b}{r}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_2$-$\eta$}}
    {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
    {\haslb{\Gamma, \bhyp{z}{A \otimes B}}{r}{\ms{L}}}
    {\lbeq{\Gamma}{\letstmt{(x, y)}{e}{\letstmt{z}{(x, y)}{r}}}{\letstmt{z}{e}{r}}{\ms{L}}}
\end{gather*}

\begin{gather*}
  \prftree[r]{\rle{case-bind}}
    {\hasty{\Gamma}{\epsilon}{e}{A + B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{e}{x}{r}{y}{s}}{\letstmt{z}{e}{\caseexpr{z}{x}{r}{y}{s}}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-inl}}
    {\hasty{\Gamma}{\epsilon}{a}{A}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{\linl{a}}{x}{r}{y}{s}}{\letstmt{x}{a}{r}}{\ms{L}}}
  \\
  \prftree[r]{\rle{case-inr}}
    {\hasty{\Gamma}{\epsilon}{b}{B}}
    {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}}}
    {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}}}
    {\lbeq{\Gamma}{\caseexpr{\linr{b}}{x}{r}{y}{s}}{\letstmt{y}{b}{s}}{\ms{L}}}
  \\
  \prftree[r]{\rle{let$_{11}$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A_1 + A_2}}{\epsilon}{b}{B}}
    {
    \forall i. \haslb{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y}{B}, \bhyp{z_i}{A_i}}{r_i}{\ms{L}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash \letstmt{x}{a}{\letstmt{y}{c}{\casestmt{x}{z_1}{r_1}{z_2}{r_2}}}}
      {\hspace{6em} \approx 
        \letstmt{x}{a}{\casestmt{x}{z_1}{\letstmt{y}{c}{r_1}}{z_2}{\letstmt{y}{c}{r_2}}} 
        : \ms{L}}
    }
  \\
  \prftree[r]{\rle{let$_{12}$-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A_1 + A_2}}{\epsilon}{b}{B \otimes C}}
    {
    \forall i. 
      \haslb{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y}{B}, \bhyp{z}{C}, \bhyp{w_i}{A_i}}{r_i}{\ms{L}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash \letstmt{x}{a}{\letstmt{(y, z)}{c}{\casestmt{x}{w_1}{r_1}{w_2}{r_2}}}}
      {\hspace{5em} \approx 
        \letstmt{x}{a}{\casestmt{x}{w_1}{\letstmt{(y, z)}{b}{r_1}}{w_2}{\letstmt{(y, z)}{b}{r_2}}} 
        : \ms{L}}
    }
  \\
  \prftree[r]{\rle{case-case}}
    {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
    {\hasty{\Gamma, \bhyp{x}{A_1 + A_2}}{\epsilon}{b}{B_1 + B_2}}
    {
    \forall i j. 
      \haslb{\Gamma, \bhyp{x}{A_1 + A_2}, \bhyp{y_i}{B_i}, \bhyp{z_j}{A_j}}{r_{ij}}{\ms{L}}
    }
    {
      \prfStackPremises
      {\Gamma \vdash \ms{let}\;x = a; \ms{case}\;b\;\{
        \linl{y_1} \Rightarrow \casestmt{x}{z_1}{r_{11}}{z_2}{r_{21}}
      }
      {
        \hspace{10em} \linr{y_2} \Rightarrow \casestmt{x}{z_1}{r_{12}}{z_2}{r_{22}}\}
      }
      {
        \hspace{1.3em} \approx \ms{let}\;x = a; \ms{case}\;x\;\{
        \linl{z_1} \Rightarrow \casestmt{b}{y_1}{r_{11}}{y_2}{r_{21}}
      }
      {
        \hspace{10em} \linr{z_2} \Rightarrow \casestmt{b}{y_1}{r_{12}}{y_2}{r_{22}}\}
      }
    }
\end{gather*}

\begin{gather*}
    \prftree[r]{\rle{cfg-$<$}}
      {\hasty{\Gamma}{\bot}{a}{A_k}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{\lbrb{\ell_k}{a}}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}
        {\where{(\letstmt{x_k}{a}{t_k})}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}
        {\ms{L}}}
    \\
    \prftree[r]{\rle{cfg$_1$}}
      {\hasty{\Gamma}{\epsilon}{a}{A}}
      {\haslb{\Gamma, \bhyp{x}{A}}{r}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\forall i. \haslb{\Gamma, \bhyp{y_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{(\letstmt{x}{a}{r})}{(\lwbranch{\ell_i}{y_i}{t_i},)_i}}
        {\letstmt{x}{a}{(\where{r}{(\lwbranch{\ell_i}{y_i}{t_i},)_i})}}
        {\ms{L}}}
    \\
    \prftree[r]{\rle{cfg$_2$}}
      {\hasty{\Gamma}{\epsilon}{e}{A \otimes B}}
      {\haslb{\Gamma, \bhyp{x}{A}, \bhyp{y}{B}}{r}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\forall i. \haslb{\Gamma, \bhyp{z_i}{C_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{(\letstmt{(x, y)}{e}{r})}{(\lwbranch{\ell_i}{z_i}{t_i},)_i}}
        {\letstmt{(x, y)}{e}{(\where{r}{(\lwbranch{\ell_i}{z_i}{t_i},)_i})}}
        {\ms{L}}}
    \\
    \prftree[r]{\rle{cfg-case}}
      {\hasty{\Gamma}{\epsilon}{a}{A_1 + A_2}}
      {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{r_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\forall i. \haslb{\Gamma, \bhyp{y_i}{B_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {
        \prfStackPremises
        {\Gamma \vdash \where{(\casestmt{a}{x_1}{r_1}{x_2}{r_2})}
          {(\lwbranch{\ell_i}{y_i}{t_i},)_i} }
        {\approx \casestmt{a}
          {x_1}{(\where{r_1}{(\lwbranch{\ell_i}{y_i}{t_i},)_i})}
          {x_2}{\where{r_2}{(\lwbranch{\ell_i}{y_i}{t_i},)_i}} : \ms{L}}
      }
    \\
    \prftree[r]{\rle{cfg-cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {
        \prfStackPremises
        {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}
          {s_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j, (\lhyp{\kappa_k}{B_k},)_k}}
        {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}} 
      }
      {
        \prfStackPremises
        {\Gamma \vdash \where{(\where{r}{(\lwbranch{\kappa_i}{x_i}{s_i},)_i})}
          {(\lwbranch{\ell_i}{y_j}{t_j},)_j}}
        {\approx \where{r}{(\lwbranch{\kappa_i}{x_i}{s_i},)_i(\lwbranch{\ell_i}{y_j}{t_j},)_j} 
          : \ms{L}}
      }
    \\
    % TODO: maybe derivable?
    \prftree[r]{\rle{cfg$_0$}}
      {\haslb{\Gamma}{r}{\ms{L}}}
      {\lbeq{\Gamma}{\where{r}{}}{r}{\ms{L}}}
    \\
    \prftree[r]{\rle{wk-cfg}}
      {\haslb{\Gamma}{[\ell_i \mapsto \ell_{\rho\;i}]r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {\forall i, \haslb{\Gamma, \bhyp{x_i}{A_i}}
        {[\ell_i \mapsto \ell_{\rho\;i}]t_i}
        {\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}
        {\where{[\ell_i \mapsto \ell_{\rho i}]r}
          {(\lwbranch{\ell_i}{x_i}{[\ell_i \mapsto \ell_{\rho\;i}]r})_i}}
        {\where{r}{(\lwbranch{\ell_{\rho\;i}}{x_i}{r})_i}}
        {\ms{L}}}
    \\
    % TODO: note difference between this and wk-cfg
    \prftree[r]{\rle{dead-cfg}}
      {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
      {\forall i, \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
      {\lbeq{\Gamma}{\where{r}{
          (\lwbranch{\ell_i}{x_i}{s_i},)_i
          (\lwbranch{\kappa_j}{y_j}{t_j},)_j}}
        {\where{r}{(\lwbranch{\ell_i}{x_i}{s_i},)_i}}{\ms{L}}}
\end{gather*}

...

\begin{equation*}
  \cfgsubst{(\lwbranch{\ell_i}{x_i}{t_i},)_i}\;\kappa\;a
  := \where{\lbrb{\kappa}{a}}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}
\end{equation*}

...

\begin{equation*}
  \prftree[r]{\rle{cfgsubst}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {\lbsubst{\cfgsubst{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}{\ms{L}}}
\end{equation*}

...

\begin{gather*}
  \prftree[r]{\rle{ucfg}}
    {\haslb{\Gamma}{r}{\ms{L}, (\lhyp{\ell_i}{A_i},)_i}}
    {\forall i. \haslb{\Gamma, \bhyp{x_i}{A_i}}{t_i}{\ms{L}, (\lhyp{\ell_j}{A_j},)_j}}
    {
      \lbeq{\Gamma}
        {\where{r}{(\lwbranch{\ell_i}{x_i}{t_i},)_i}}
        {[\cfgsubst{(\lwbranch{\ell_i}{x_i}{t_i},)_i}]r}
        {\ms{L}}
    }
  \\
  % NOTE: in the development, it's (ret e) wseq s_0, not [e/x] s_0
  \prftree[r]{\rle{uni}}
    {
      \prfStackPremises
      {\hasty{\Gamma, \bhyp{x}{A}}{\bot}{e}{B}}
      {\haslb{\Gamma}{r}{\ms{L}, \ell(A)}}
    }
    {
      \prfStackPremises
      {\haslb{\Gamma, \bhyp{y}{B}}{s}{\ms{L}, \kappa(B)}}
      {\haslb{\Gamma, \bhyp{x}{A}}{t}{\ms{L}, \ell(A)}}
    }
    {
      \lbeq{\Gamma, \bhyp{x}{A}}
        {[e/y]s}
        {\where{t}{\lwbranch{\ell}{x}{\lbrb{\kappa}{e}}}}
        {\ms{L}, \kappa(B)}
    }
    {
      \lbeq{\Gamma}
        {\where{(\where{r}{\lwbranch{\ell}{x}{\lbrb{\kappa}{e}}})}
          {\lwbranch{\kappa}{y}{s}}}
        {\where{r}{t}}
        {\ms{L}}
    }
  \\
  \prftree[r]{\rle{codiag}}
    {\haslb{\Gamma}{r}{\ms{L}, \ell(A)}}
    {\haslb{\Gamma, \bhyp{y}{A}}{s}{\ms{L}, \ell(A), \kappa(A)}}
    {\lbeq{\Gamma}{\where{r}{\lwbranch{\ell}{x}{\where{\lbrb{\kappa}{x}}
      {\lwbranch{\kappa}{y}{s}}}}}
    {\where{r}{\lwbranch{\ell}{y}{[\ell/\kappa]s}}}
    {\ms{L}}}
\end{gather*}

\TODO{soundness of region equational theory (diagrams?)}

\TODO{notes on completeness? derivable equations?}

\section{Normalization}

\TODO{to Expr...}

\TODO{to BBRegion...}

\TODO{to TRegion ...}

\TODO{to ContRegion ...}

\section{Böhm–Jacopini}

\TODO{this...}

\end{document}
\endinput
