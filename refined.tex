%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,anonymous,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{xcolor} % \usepackage[dvipsnames]{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{fancyvrb}
\usepackage{enumitem}
\usepackage{string-diagrams}
\usepackage{cancel}
\usepackage{thmtools}
\usepackage{pifont}
\usepackage{stmaryrd}
\usepackage[export]{adjustbox}
\usetikzlibrary{calc}

\lstset{ %
  autogobble=true,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{\textbf{TODO \arabic{todos}}: #1}}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\mbb}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

\newcommand{\kwms}[1]{\textcolor{violet}{\ms{#1}}}
\newcommand{\lbms}[1]{{\ms{#1}}}

% Math
\newcommand{\nats}{\mathbb{N}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{:}
\newcommand{\linl}[1]{\iota_l\;{#1}}
\newcommand{\linr}[1]{\iota_r\;{#1}}
\newcommand{\labort}[1]{\ms{abort}\;{#1}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2;\;#3}}
\newcommand{\caseexpr}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\casestmt}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\loopstmt}[4]{\ms{loop}\;#1\;\{#2(#3) \lto #4\}}
\newcommand{\awhere}[2]{#1\;\ms{where}_{\ms{nonrec}}\;#2}
\newcommand{\cwhere}[2]{#1\;\ms{where}_{\ms{rec}}\;#2}
\newcommand{\where}[2]{#1\;\ms{where}\;#2}
\newcommand{\wbranch}[3]{#1(#2) \lto \{#3\}}
\newcommand{\cfgsubst}[1]{\ms{cfgs}\;\{#1\}}
\newcommand{\wseq}[2]{{#1} \mathbin{{;}{;}} {#2}}
\newcommand{\rupg}[1]{{#1}^\upharpoonright}
\newcommand{\lupg}[1]{{#1}^\upharpoonleft}
\newcommand{\liter}[3]{\ms{iter}\;#1\;\{ \linr{#2} \lto #3 \}}
\newcommand{\einf}[1]{#1 \in \mc{E}^\infty}

\newcommand{\ncaseexpr}[3]{\ms{case}_{#1}\;#2\;\{#3\}}
\newcommand{\splitexpr}[3]{\ms{split}_{#1; #2}(#3)}
\newcommand{\webranch}[3]{#1(#2) \lto #3}

% Judgements
\newcommand{\qsp}[4]{#1 \vdash #2 = #3 + #4}
\newcommand{\qwk}[4]{#1 \vdash #2 \geq #3 + #4}
\newcommand{\swk}[3]{#1 \mapsto #2 ; #3}
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[3]{#1 \vdash #2 \rightsquigarrow #3}
\newcommand{\thyp}[3]{#1 : {#2}^{#3}}
\newcommand{\bhyp}[2]{#1 : #2}
\newcommand{\lhyp}[2]{#1(#2)}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\qbc}[2]{(#1) , #2}

\newcommand{\hasty}[4]{#1 \vdash_{#2} #3: {#4}}
\newcommand{\haslb}[4]{#1 \vdash_{#2} #3 \rhd #4}

\newcommand{\ahasty}[4]{#1 \vdash_{#2}^{\ms{anf}} #3 : {#4}}
\newcommand{\thaslb}[3]{#1 \vdash^{\ms{t}}_{\ms{ssa}} #2 \rhd #3}
\newcommand{\ahaslb}[3]{#1 \vdash^{\ms{anf}} #2 \rhd #3}
\newcommand{\bhaslb}[3]{#1 \vdash^{\ms{b}}_{\ms{ssa}} #2 \rhd #3}
% \newcommand{\chaslb}[3]{#1 \vdash^{\ms{c}}_{\ms{ssa}} #2 \rhd #3}

\newcommand{\shaslb}[3]{#1 \vdash^{\ms{s}} #2 \rhd #3}

\newcommand{\isop}[4]{#1 \in \mc{I}_{#4}(#2, #3)}
\newcommand{\issubst}[4]{#1 \vdash_{#2} #3 \rhd #4}
\newcommand{\lbsubst}[4]{#1 \vdash #2: #3 \rightsquigarrow #4}
\newcommand{\teqv}{\approx}
\newcommand{\tref}{\twoheadrightarrow}
\newcommand{\cref}{\twoheadrightarrow}
\newcommand{\antitref}{\twoheadleftarrow}
\newcommand{\anticref}{\twoheadleftarrow}
\newcommand{\tmle}[5]{#1 \vdash_{#2} #3 \tref #4 : {#5}}
\newcommand{\tmlep}[6]{#1 \vdash_{#2} #3 \tref^{#6} #4 : {#5}}
\newcommand{\tmeq}[5]{#1 \vdash_{#2} #3 \teqv #4 : {#5}}
\newcommand{\lbeq}[5]{#1 \vdash_{#2} #3 \teqv #4 \rhd {#5}}
\newcommand{\lbref}[5]{#1 \vdash_{#2} #3 \tref #4 \rhd {#5}}
\newcommand{\tmseq}[4]{\issubst{#1 \teqv #2}{#3}{#4}}
\newcommand{\lbseq}[5]{\lbsubst{#1 \teqv #2}{#3}{#4}{#5}}
\newcommand{\brle}[1]{{\textsf{#1}}}

\newcommand{\tossa}[2]{\ms{SSA}_{#1}(#2)}
\newcommand{\ssalet}[3]{\ms{let}_{\ms{SSA}}\;#1 = #2; #3}
\newcommand{\toanf}[1]{\ms{ANF}(#1)}
\newcommand{\anflet}[3]{\ms{let}_{\ms{ANF}}\;#1 = #2; #3}
\newcommand{\toterm}[1]{\ms{Term}(#1)}
\newcommand{\etoty}[1]{[#1]}
\newcommand{\ctoty}[1]{[#1]}
\newcommand{\ltoty}[2]{[#1 \mapsto #2]}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}
\newcommand{\tmor}[1]{{!}_{#1}}
\newcommand{\dmor}[1]{{\Delta}_{#1}}
\newcommand{\entrymor}[3]{\ms{esem}_{#1, #3}(#2)}
\newcommand{\loopmor}[3]{\ms{lsem}_{#1, #3}(#2)}
\newcommand{\substpure}[1]{#1\;\ms{pure}}

% Comonadic lore
\newcommand{\lmor}[1]{\ms{let}(#1)}
\newcommand{\envcom}[2]{{#1}_{#2 \otimes \cdot}}
\newcommand{\rlmor}[1]{\ms{rlet}(#1)}
\newcommand{\rcase}[1]{\ms{rcase}(#1)}
\newcommand{\rfix}[1]{\ms{rfix}(#1)}
\newcommand{\rseq}[3]{#2 \gg_{#1} #3}
\newcommand{\envpil}[1]{\pi_{{#1}l}}
\newcommand{\envpir}[1]{\pi_{{#1}r}}

\newcommand{\toenv}[2]{\ms{env}_{#1}(#2)}
\newcommand{\envcop}[3]{[#2, #3]_{#1}}
\newcommand{\envinr}[1]{\iota^{#1}_{r}}
\newcommand{\envinl}[1]{\iota^{#1}_{l}}
\newcommand{\envtn}[3]{{#2} \otimes_{#1} {#3}}
 
% Composition
\newcommand{\invar}{\square}
\newcommand{\outlb}{\blacksquare}
\newcommand{\pckd}[1]{\langle #1 \rangle}

% Weak memory
\newcommand{\bufloc}[1]{\overline{#1}}

% Branding
\newcommand{\subiterexp}{\texorpdfstring{\(\lambda_{\ms{iter}}\)}{lambda-iter}}
\newcommand{\isotopessa}{\(\lambda_{\ms{SSA}}\)}
\newcommand{\thsubiter}[1]{\ms{Th}(#1)}

% Formalization pointers
\newcommand{\formalizedas}[1]{Formalized as \texttt{#1}}

% Commutativity
\newcommand{\rightmove}{\rightharpoonup}
\newcommand{\leftmove}{\leftharpoondown}
\newcommand{\slides}{\rightleftharpoons}

% Quantities
\newcommand{\zeroq}{0}
\newcommand{\oneq}{1}
\newcommand{\delq}{1^?}
\newcommand{\cpyq}{\omega^+}
\newcommand{\topq}{\omega}
\newcommand{\zeroqv}[1]{#1^\uparrow}
\newcommand{\dwnqv}[1]{\downarrow(#1)}

% Operators
\newcommand{\pto}{\rightharpoonup}
\newcommand{\fpto}{\pto_{\ms{fin}}}
\newcommand{\alquant}{\ms{q}}
\newcommand{\alcount}{\sharp}
\newcommand{\aldquant}{\bar{\ms{q}}}
\newcommand{\varcount}[2]{\sharp(#1, #2)}
\newcommand{\ubeff}{\lightning}
\newcommand{\obind}{\mathbin{>\!\!>\mkern-6.7mu=}}
\newcommand{\mpure}[1]{\eta_#1}
\newcommand{\mbind}[3]{#2 \obind_{#1} #3}
\newcommand{\tret}[2]{#1 \therefore #2}
\newcommand{\letarr}[2]{\ms{let}\;#1\;\ms{in}\;#2}

% Truth tables
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\textcolor{red}{\ding{55}}}%
% \newcommand{\cmark}{\textcolor{Green}{\ding{51}}}%
% \newcommand{\xmark}{\textcolor{BrickRed}{\ding{55}}}%


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{A Complete Refinement System for Substructural SSA}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\begin{abstract}
  In this paper, we give a type-theoretic presentation of static single assignment (SSA) form, the
  dominant compiler intermediate representation. Our type theory is very rich one, with
  substructural types and an effect system, which enables us to give a syntactic presentation of
  refinement for SSA programs which validates the effect-dependent program transformations that
  compilers depend upon. We are also able to give a categorical semantics for our calculus, and we
  prove our calculus both sound and complete with respect to the categorical axiomatization.
  Completeness ensures that there are no missing refinements from our calculus, which lets compiler
  writers validate optimizations in a model-free way. On the other side, the fact that our
  axiomatization is sound gives us a syntax-free way of verifying that complex combinations of
  features such as undefined behaviour, nondeterminism, and weak memory still validate the program
  transformations compilers rely upon. 
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

\section{Introduction}

Static single assignment form, or SSA, rapidly became the dominant compiler intermediate
representation (IR) after its introduction by \citet{alpern-ssa-original-88} and
\citet{rosen-gvn-1988} in the 1980s. The fundamental idea behind SSA is one which is very familiar
to functional programmers: if a variable is defined exactly once and never reassigned, then
substitution is then a valid program transformation. This both simplifies the implementation and
improves the performance of many compiler optimizations.

The correctness of SSA transformations has mostly been handled informally, because it was originally
intended to be a simple, first-order imperative programming language. Unfortunately, in the decades
since its introduction, computers have become much less simple, and the optimizations that compiler
writers want to do have become much more complicated. Modern hardware is highly concurrent, and
exhibits user-visible non-sequentially-consistent behaviour: \emph{weak
memory}~\cite{batty-compositional-17}. This means memory can no longer be correctly modelled as a
global array of bytes. Furthermore, compilers like LLVM and GCC now perform very aggressive
optimizations exploiting knowledge of memory aliasing and undefined behaviour.
Because all these optimizations are all done in the presence of nondeterminism, the transformations
compilers want to do are not usually program equivalences, but merely refinements: the possible
behaviours of the optimized program must be a subset of the possible behaviours of the original
program.

As a concrete example, consider the interaction of undefined behaviour and other effects.
The division operation $\ms{div}\;y\;z$ exhibits \emph{undefined behavior} (UB) in both C and
LLVM if $z$ is zero, but otherwise has no side-effects. Therefore, the program 
$\letexpr{x}{\ms{div}\;y\;z}{e}$ is equivalent to $[\ms{div}\;y\;z/x]e$ if $z$ is known
to be nonzero, but not otherwise. For example, if $z = 0$ and $e = ()$,
$\letexpr{x}{\ms{div}\;y\;0}{()}$ always exhibits UB, whereas $[\ms{div}\;y\;0/x]() \equiv ()$ simply
does nothing! However, one direction of the rewrite -- turning $\letexpr{x}{\ms{div}\;y\;z}{e}$ into
$[\ms{div}\;y\;z/x]e$ -- is always a safe transformation, since:
\begin{itemize}
  \item If $z$ is zero, then $\letexpr{x}{\ms{div}\;y\;z}{e}$ has UB, so we can rewrite it to
  anything we want!
  \item Otherwise, $\ms{div}\;y\;z$ is pure, so substitution is unconditionally valid
\end{itemize}
%
% where the optimizer cannot deduce whether $z$ is nonzero; since
% $\ms{div}\;y\;z$ may exhibit UB, it is \emph{impure}, and hence, in general, this program is
% \emph{not} equivalent to $[\ms{div}\;y\;z/x]e$; For example, if $z = 0$ and $e = ()$,
% $\letexpr{x}{\ms{div}\;y\;z}{e}$ always exhibits UB, whereas $[\ms{div}\;y\;z/x]e \equiv ()$ simply
% does nothing!
% 
% It turns out, however, that it is always safe to rewrite $\letexpr{x}{\ms{div}\;y\;z}{e}$ to
% $[\ms{div}\;y\;z/x]e$, since
% \begin{itemize}
%   \item If $z$ is zero, then $\letexpr{x}{\ms{div}\;y\;z}{e}$ has UB, so we can rewrite it to
%   anything we want!
%   \item Otherwise, $\ms{div}\;y\;z$ is pure, so substitution is unconditionally valid
% \end{itemize}
% 
Note that this substitution moved a potentially-effectful operation \emph{forward} in the program's
execution. Depending upon how often $x$ occurs inside of $e$, this substitution could also duplicate
or drop the effectful operation. This observation gives rise to a categorization of effectful terms,
based on how they interact with substitution. 

Because it is always safe to move UB after any other effect, we call it a \emph{right-mover} with
respect to that effect. Furtheremore, since it is also always a refinement both to eliminate and to
duplicate UB, we say UB is both an \emph{eliminable} and \emph{duplicable} effect. This is because
eliminating UB reduces the set of possible behaviours, and duplicating occurences of UB does not
increase the set of possible behaviours. We also have that $(\ms{div}\;y\;z, \ms{div}\;y\;z) \tref
\letexpr{x}{\ms{div}\;y\;z}{(x, x)}$, so UB is also \emph{fusable}. When an effect is both fusable
and duplicable, we also call it \emph{relevant}.  On the other hand, it is not a refinement to
introduce UB, since $() \not\tref \letexpr{x}{\ms{div}\;y\;z}{()}$. Hence we say it is not
\emph{introducible}. We say an effect which is both \emph{eliminable} and \emph{introducible} is
\emph{affine}. 

We might also want to ask with respect to which effects UB is a \emph{left-mover}, i.e., for which
effects of $e$ we have $(e, \ms{div}\;y\;z) \tref \letexpr{x}{\ms{div}\;y\;z}{(e, x)}$ (with pairs
evaluated left-to-right). With some thought, we can see this refinement holds only when execution is
guaranteed to continue after evaluating $e$, so this rules out effects like nontermination or
exceptions, but effects like nondeterminism or memory access are fine. That is, UB is a
\emph{left-mover} with respect to nondeterminism and memory access, but not in general. Since it is
both a left and right mover w.r.t. these effects, we say UB \emph{commutes} with them. An effect
that commutes with everything, like the empty effect $\bot$, is called \emph{central}.

% Ye olde freeze miscompilations:
% https://github.com/llvm/llvm-project/issues/144780
% https://github.com/llvm/llvm-project/issues/58321
% https://github.com/llvm/llvm-project/issues/141622
% https://github.com/llvm/llvm-project/issues/91178

% Also:
% UB with infinite loop even if well-formed: https://github.com/llvm/llvm-project/issues/62057
% Arguments about fences being forward progress: https://github.com/llvm/llvm-project/issues/96702
% Ditto for `printf("")': https://github.com/llvm/llvm-project/issues/96703

% Also:
% UB on reordering checks, due to branching on `poison': 
% https://github.com/llvm/llvm-project/issues/57523
% Introduction of loads in writeonly functions, more UB:
% https://github.com/llvm/llvm-project/issues/51248
% ScalarEvolution branches on poison:
% https://github.com/llvm/llvm-project/issues/47113
% fabs fmul optimization incorrect due to undef:
% https://github.com/llvm/llvm-project/issues/47287


The question of what rewrites are permitted in the presence of effects is one that compiler
writers struggle with~\cite{llvm-github}, because the less conservative they are, the faster
the code they can generate, but the more dependent the are on having a clear understanding of each
effectful operation's semantics and interactions. 

Because of this complexity, the old informal techniques are no longer sufficient, and we need to
study SSA using more mathematically sophisticated techniques to understand and justify what modern
hardware and compilers do. In this paper, we introduce a type-theoretic account of static single
assigment form, and equip it with a semantics which explains and can be used to justify many program
transformations even in the presence of effects like state, undefined behaviour, and weak memory concurrency. Concretely, our contributions are as follows:

\begin{itemize}
\item First, we give a pair of type theories for SSA. The first
  language, \isotopessa, is intended to mimic the structure of
  traditional presentations of SSA. The second type theory,
  \subiterexp, has a syntax very different from ordinary SSA, but
  which greatly facilitates giving a syntactic presentation of its
  refinement theory. Both of these theories have a rich type system
  with both linearity and effect tracking. The extra structure enables
  us to express many effect-dependent program transformations in a
  type-directed way. We show that \subiterexp can be seen as an
  alternative presentation of ordinary SSA by showing that there are
  meaning-preserving translations to and from \isotopessa.
\item We then give a categorical axiomatization of first-order
  effectful programs with looping and control, and then show that
  \subiterexp is soundly interpreted in this model, and furthermore we
  show completeness of our refinement theory by proving that the
  syntactic model is the initial model.
\item We then give a collection of concrete models validating the
  categorical axiomatization. We start with a model including
  nontermination, nondeterminism, and undefined behaviour, and then
  show how to give another model augmented with state, as well as
  giving a model for release-acquire concurrency which validates our
  axioms. Finally, we show how a variety of interesting optimizations
  are validated by our model.
\end{itemize}
Finally, many of the results in this paper have been mechanized in the Lean proof assistant. 
\section{SSA}

\label{sec:ssa-intro}

One of the first IRs to find widespread use was \emph{register transfer level (RTL)} code. RTL
programs are composed of a collection of \emph{basic blocks}, defined to be a sequence of
instructions of the form $x = f(y, z)$ ending with a \emph{terminator} instruction, which may branch
to other basic blocks. The basic blocks, and the jumps between them, form the nodes and edges of
that program's \emph{control-flow graph}. Because RTL variables are \emph{mutable}, program analyses
have to keep track of the values of every variable \emph{at every program point}, significantly
complicating performant implementations.

To avoid this multplicative overhead, the \emph{static single assignment}, or \emph{SSA}, IR
enforces the restriction that every variable has precisely one definition. Just as in functional
programs, this raises the question of how to handle control-flow dependent variables such as loop
induction variables. The answer is the same \cite{appel-ssa}: each basic block (or tail-recursive
function!) takes a list of control-flow dependent variables as \emph{arguments}. Traditionally,
these arguments are represented ``inside out" using \emph{$\phi$-functions}, which are assignments
whose value depends on which basic block is their immediate predecessor. Our formalization follows
modern practice and uses the \emph{basic blocks with arguments} (BBA) representation of SSA.

In SSA, the property that every variable has a single definition is graph-theoretic: we require that
the use point of the variable is \emph{dominated} by its definition in the control-flow
graph.\footnote{ A node $n$ is dominated by a node $N$ in a directed graph if every path to $n$
passes through $N$. } Semantics, however, is much easier with lexical scoping. To interconvert
between the two, we note that the dominance relation on basic blocks always forms a tree rooted at
the entry block: we call this the \emph{dominator tree}. We will call a subtree of the dominator
tree, which has a single entry point (the root) and multiple exits (the leaves, all dominated by the
root), a \emph{region}. The variables defined in a given basic block $\beta$ are visible from
another block $\beta'$ if and only if $\beta$ dominates $\beta'$, i.e., if $\beta$ is a child in the
dominator tree, contained in the region $r$ rooted at $\beta$. Hence, dominance based scoping can be
represented as lexical scoping \emph{with respect to the dominator tree}.

This idea underlies the design of \isotopessa{}, what we call \emph{type-theoretic SSA}, which has
the grammar given in Figure~\ref{fig:ssa-syntax}. Rather than give a grammar for basic-blocks and
control-flow graphs, we instead give a grammar for \emph{regions} $r, s, t$, which are composed of a
series of \ms{let}-bindings (each corresponding to an instruction $o$), followed by a subtree
$\kappa$, which is composed of a terminator $\tau$ wrapped in \ms{where}-blocks containing the
region's dominated subregions.\footnote{We distinguish recursive and non-recursive \ms{where}-blocks
for effect-system bookkeeping, but semantically they are identical.}

If we squint, we can see that this is just SSA with \ms{where}-blocks as an annotation representing
the dominator tree: basic blocks correspond to sequences of \ms{let}-bindings followed by a
terminator. Indeed, it is straightforward to verify that any well-scoped SSA program can be
converted to a \isotopessa{} program by simply adding in \ms{where}-blocks corresponding to the
dominator tree; similarly, simply erasing the \ms{where}-blocks from an \isotopessa{} program yields
a program in standard basic-blocks with arguments SSA; we see an example of this in
Figure~\ref{fig:fact-lex}. We can also show that any two programs which are equivalent up to the
placement of \ms{where}-blocks have equivalent semantics, therefore justifying \isotopessa{} as
being simply SSA with additional annotations.

\begin{figure}
  \begin{subfigure}[t]{.35\textwidth}
    \centering
    \begin{adjustbox}{minipage=1.2\textwidth,scale=0.8}
    \begin{align*}
      \lbms{start}:\quad  & \kwms{let}\;n = 10; \\
                          & \kwms{br}\;\ms{loop} \\
      \lbms{loop}: \quad  & \begingroup \color{red}
                            \kwms{let}\;i_0 = \phi(\ms{start}: 1, \ms{body}: i_1) 
                          \endgroup \\
                          & \begingroup \color{blue}
                            \kwms{let}\;a_0 = \phi(\ms{start}: 1, \ms{body}: a_1) 
                          \endgroup \\
                          & \kwms{if}\;i_0 < n\;\{\;\kwms{br}\;\lbms{body}\;\} \\
                          & \kwms{else}\;\{\;\kwms{ret}\;a_0\;\} \\
      \lbms{body}: \quad  & \kwms{let}\;t = i_0 + 1 \\
                          & \kwms{let}\;a_1 = a_0 * t \\
                          & \kwms{let}\;i_1 = i_0 + 1 \\
                          & \kwms{br}\;\lbms{loop} \\ \\
    \end{align*}
    \end{adjustbox}
    \caption{$\phi$-nodes}
    \label{fig:fact-phi}
  \end{subfigure}%
  \begin{subfigure}[t]{.35\textwidth}
    \centering
    \begin{adjustbox}{minipage=1.2\textwidth,scale=0.8}
    \begin{align*}
      \lbms{start}:\quad            & \kwms{let}\;n = 10; \\
                                    & \kwms{br}\;
                                        \lbms{loop}(\textcolor{red}{1}, \textcolor{blue}{1}) \\
      \lbms{loop}(\textcolor{red}{i_0}, \textcolor{blue}{a_0}): \quad  
                                    & \kwms{if}\;i_0 < n\; \{\;\kwms{br}\;\lbms{body}\;\} \\
                                    & \kwms{else}\;\{\;\kwms{ret}\;a_0\;\} \\
      \lbms{body}: \quad            & \kwms{let}\;t = i_0 + 1 \\
                                    & \kwms{let}\;a_1 = a_0 * t \\
                                    & \kwms{let}\;i_1 = i_0 + 1 \\
                                    & \kwms{br}\;\lbms{loop}
                                      (\textcolor{red}{i_1}, \textcolor{blue}{a_1}) 
                                    \\ \\ \\ \\
    \end{align*}
    \end{adjustbox}
    \caption{Basic-blocks with arguments}
    \label{fig:fact-bba}
  \end{subfigure}%
  \begin{subfigure}[t]{.3\textwidth}
    \begin{adjustbox}{minipage=\linewidth,scale=0.8}
    \begin{align*}
      & \kwms{let}\;n = 10; \\
      & \kwms{br}\;\lbms{loop}(\textcolor{red}{1}, \textcolor{blue}{1}) \\
      & \kwms{where}\;\lbms{loop}(\textcolor{red}{i_0}, \textcolor{blue}{a_0}): \{ \\
      & \quad \kwms{if}\;i_0 < n\;\{\;\kwms{br}\;\lbms{body}\;\} \\
      & \quad \kwms{else}\;\{\;\kwms{ret}\;a_0\;\} \\
      & \quad \kwms{where}\;\lbms{body}: \{\\ 
      & \qquad \kwms{let}\;t = i_0 + 1 \\
      & \qquad \kwms{let}\;a_1 = a_0 * t \\
      & \qquad \kwms{let}\;i_1 = i_0 + 1 \\
      & \qquad \kwms{br}\;\lbms{loop}(\textcolor{red}{i_1}, \textcolor{blue}{a_1})  \\
      & \quad \} \\
      & \}
    \end{align*}
    \end{adjustbox}
    \caption{Lexical scoping}\
    \label{fig:fact-lex}
  \end{subfigure}
  
  \caption{%  
    A program to compute $10!$ written in standard SSA (using $\phi$ nodes), like in LLVM
    \cite{llvm}, and using basic-blocks with arguments, like in MLIR \cite{mlir} and Cranelift
    \cite{cranelift}, with both implicit (dominance-based) and explicit (lexical) scoping. The
    arguments $i_0, a_0$ corresponding to the $\phi$-nodes $i_0, a_0$ are colored in
    \textcolor{red}{red} and \textcolor{blue}{blue}, respectively.%
  }
  \Description{}
\end{figure}

\begin{figure}
  \begin{grammar}
    <\(o\)> ::= \(x\)
      \;|\; \(f\;x\)
      \;|\; \(()\)
      \;|\; \((x, y)\)
      \;|\;  \(\linl{x}\)
      \;|\; \(\linr{x}\)
      \;|\; \(\labort{x}\)

    <\(r, s, t\)> ::= \(\kappa\)
      \;|\; \(\letstmt{x}{o}{t}\)
      \;|\; \(\letstmt{(x, y)}{o}{t}\)

    <\(\kappa\)> ::= \(\tau\) \;|\; \(\awhere{\kappa}{L}\) \;|\; \(\cwhere{\kappa}{L}\)

    <\(\tau\)> ::= \(\brb{\ell}{o}\)
      \;|\; \(\casestmt{o}{y}{\tau}{z}{\tau'}\)

    <\(L\)> ::= \(\cdot\) \;|\; \(L, \wbranch{\ell}{x}{t}\)
  \end{grammar}
  \caption{Grammar for \isotopessa{} programs.}
  \Description{}
  \label{fig:ssa-syntax}
\end{figure}

\begin{figure}
  \begin{lstlisting}[language=C++]
    struct BasicBlock {
      vector<Instruction> instructions;             // unary/binary let-bindings
      Terminator terminator;                        // LHS of where-block
      map<Label, (Argument, BasicBlock)> children;  // RHS of where-block
    }
  \end{lstlisting}
  \caption{Data encoded by the grammar in Figure \ref{fig:ssa-syntax}}
  \Description{}
  \label{fig:ssa-data}
\end{figure}

\section{\subiterexp{}, an expression language for SSA }

SSA is a useful IR because it enables complex, whole-procedure transformation of code, but
its block-statement-value hierarchy makes it difficult to uniformly formulate the allowed
transformations as an (in)equational
theory. If we unified all of these levels into a single
expression language, then formulating many transformations becomes much simpler. For example, if
loops were an expression, then control-flow-graph transformations which duplicate or fuse loop
bodies are merely instances of substitution (and its dual, CSE/let-introduction). 

In this section, we introduce \subiterexp{}, which is an expression-oriented variant of SSA.
Essentially, it is a simple first-order expression language with support for binding/sequencing,
branching, and loops. \subiterexp{} looks very different from traditional presentations of SSA, but
we later prove in Subsection~\ref{ssec:interconversion} that the two syntaxes are completely
equivalent to one another. The main novelty of \subiterexp{} is in its type system and equational theory.
It has a rich substructural type and effect system, which enables us to give a complete inequational
characterization of refinement of \subiterexp{} programs. Since \subiterexp{} is equivalent
to SSA, we get a complete syntactic characterization of refinement for SSA programs. 

% Unfortunately, while SSA is a good format for implementing compiler optimizations, it has poor
% metatheoretic properties. In particular, much like ANF, it is challenging to state
% \emph{substitution}, and consequently to build up a solid equational theory, since expressions
% cannot be arbitrary SSA programs. In particular, since we would like to consider the substitution of
% \emph{effectful} operations, we also need to a type system to keep track of the linearity of how
% variables are used, as well as the commutativity of the effect's operation and that of any code
% between the original definition and the substitution site. Moreover, while arbitrary control-flow
% allows exceptional flexibility, it can make it difficult to build up a complete equational theory
% for our calculus, especially when we want fine-grained effect tracking.
% 
% The B\"ohm-Jacopini theorem states that programs with arbitrary control-flow can be re-written to
% require only branching and iteration; \citet{ghalayini-24-ssa-densem-arxiv} show that the
% B\"ohm-Jacopini theorem holds for a syntactic model of SSA. Inspired by this, we introduce a simpler
% expression language, \subiterexp{}, which supports \emph{only} iteration and branching as
% control-flow primitives. In a later section, we will show how to recover the full generality of SSA
% from this core language, which we will use to state our equational theory and build up our
% categorical semantics.
% 
\subsection{Syntax and Typing Rules}

As mentioned before, \subiterexp{} is a standard first-order expression language with branching and
iteration: a functional analogue of \textsc{While}. Its grammar is in
Figure~\ref{fig:expr-syntax}, and is parametrized by a set of \emph{base types} $X \in \mc{X}$ and
a set of \emph{instructions} $f \in \mc{I}$. 
%
To model multiple arguments and control flow, our grammar of types $A,
B, C$ includes all \emph{tensor products} $A \otimes B$ and \emph{coproducts} $A + B$ generated by
base types $X$, along with a \emph{unit type} $\mb{1}$ and an \emph{empty type} $\mb{0}$.
%
Mirroring this, expressions $a, b, c$ consist of
\begin{itemize}
  \item \emph{Variables} $x, y, z$
  \item \emph{Applications} $f\;a$, consisting of instructions $f \in \mc{I}$ applied to an
  expression $a$
  \item \emph{Let-bindings} $\letexpr{x}{a}{b}$ and \emph{destructuring let-bindings} $\letexpr{(x,
  y)}{a}{b}$. We write $a; b$ as syntactic sugar for $\letexpr{\cdot}{a}{b}$ (i.e., a let binding
  where the bound variable is not used in $b$).
  \item \emph{Case-expressions} $\caseexpr{e}{x}{a}{y}{b}$, representing branching control-flow
  \item \emph{Iteration-expressions} $\liter{a}{x}{b}$ representing a variant of
  \emph{tail-controlled loop}, which:
  \begin{itemize}
    \item Evaluates an initial value $a : A$
    \item Evaluates the loop body $b : B + A$ with $x = a$; if the loop evaluates to a value of type
    $B$, we return it, otherwise, we re-evaluate the loop with $x$ having the new value of type $A$
  \end{itemize}
\end{itemize}

\begin{figure}
  \begin{grammar}
    <\(A, B, C\)> ::= 
    \(X\)
    \;|\; \(A \otimes B\)
    \;|\; \(\mathbf{1}\)
    \;|\; \(A + B\)
    \;|\; \(\mathbf{0}\)

    <\(a, b, c\)> ::=
    \(x\)
    \;|\; \(f\;a\)
    \;|\; \(\letexpr{x}{a}{b}\)
    \;|\; \(()\)
    \;|\; \((a, b)\)
    \;|\; \(\letexpr{(x, y)}{a}{b}\)
    \alt  \(\linl{a}\)
    \;|\; \(\linr{b}\)
    \;|\; \(\caseexpr{a}{x}{b}{y}{c}\)
    \;|\; \(\labort{a}\)
    \;|\; \(\liter{a}{x}{b}\)
    
    <\(q\)> ::= \(\zeroq\) | \(\oneq\) | \(\cpyq\) | \(\delq\) | \(\topq\)

    <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, x : A\)

    <\(\mb{q}\)> ::= \(\cdot\) \;|\; \(\mb{q}, q\)
  \end{grammar}
  \caption{Syntax for \subiterexp{} types, expressions, quantities, and contexts.} \Description{}
  \label{fig:expr-syntax}
\end{figure}

Our typing judgement is $\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}$.
This says that in the context $\Gamma$, the expression $a$ has type $A$ and \emph{effects}
$\epsilon$, and uses $\Gamma$'s variables according to the quantities in the
\emph{quantity vector} $\mb{q}$.

\subsubsection{Variable Quantities}

Our type system tracks how often individual variables are used to reason about rewrites
involving effectful expressions. Inspired by substructural logic, which distinguishes linear
(exactly once), affine (at most once), and relevant (at least once), we introduce a join semilattice
of \emph{quantities} to model these usages. The primitive quantities are:
\begin{itemize}
  \item $\zeroq$ -- corresponding to being used zero times
  \item $\oneq$ -- corresponding to being used exactly once
  \item $\cpyq$ -- corresponding to being used multiple ($\geq 1$) times
\end{itemize}
This forms a partial order $\{\zeroq, \oneq \leq \cpyq\}$. To complete it into a join-semilattice, we add elements
\begin{itemize}
  \item $\zeroq \sqcup \oneq$ -- written $\delq$, corresponding to being used at most once
  \item $\zeroq \sqcup \cpyq$ -- written $\topq$, corresponding to being used any number of times
\end{itemize}
We call the set $Q^0 = \{\zeroq, \oneq, \cpyq, \delq, \topq\}$ the \emph{extended} set of
quantities, and $Q = \{\oneq, \cpyq, \delq, \topq\}$ the set of (\emph{nonzero}) quantities. $Q$ also forms a lattice, with $\cpyq \sqcap \delq = \oneq$ (though $Q^0$ does not).

Contexts are a list $\Gamma$ of typed variables $x : A$ along with a list of quantities of equal
length $\mb{q}$, which we write as $\Gamma^{\mb{q}}$. This is equivalent to annotating each variable  with a quantity $x : A^q$. We define the syntax sugars
  $\Gamma^{\mb{q}}, x : A^q := (\Gamma, x : A)^{\mb{q}, q}$ and
  $\Gamma^{\mb{q}}, x : A :=  (\Gamma, x : A)^{\mb{q}, \topq}$.

  Since we already track the usage of variables, it adds little extra
complexity to support substructural types (types whose elements can \emph{only} be used a
certain number of times). Assuming each base type $X \in \mc{X}$ is
equipped with a \emph{linearity} $\alquant(X) \in Q$, the linearity of any type $A$ is defined as
\begin{equation}
  \alquant(A \otimes B) = \alquant(A + B) = \alquant(A) \sqcap \alquant(B) \qquad
  \alquant(\mb{1}) = \alquant(\mb{0}) = \topq
\end{equation}
We now define the linearity of annotated types $A^q$ and contexts $\Gamma$ as follows:
\begin{equation}
  \alquant(\cdot) = \topq \qquad
  \alquant(\Gamma^{\mb{q}}, x : A^q) 
    = \alquant(\Gamma^{\mb{q}}) \sqcap \alquant(A^q) \qquad 
  \alquant(A^q) = \begin{cases}
    \alquant(A) \sqcap q & \text{if } q \neq 0 \\
    \topq & \text{if } q = 0
  \end{cases}
\end{equation}
In particular, note that the linearity of an unused variable is always unrestricted.
%
We will enforce our quantity restrictions through the means of \emph{weakening} and \emph{splitting}
judgements, which will determine how variables may be left unused or apportioned between
subcontexts, respectively. In particular, the judgement $\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}$,
pronounced ``$\Gamma^{\mb{q}}$ weakens $\Delta^{\mb{q'}}$," is defined as follows:
\begin{gather*}
  \prftree[r]{\rle{nil}}{\cwk{\cdot}{\cdot}} \qquad 
  \prftree[r]{\rle{cons}}
    {\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}}
    {q' * \alquant(A) \leq q * \alquant(A)}
    {\cwk{\Gamma^{\mb{q}}, x : A^q}
         {\Delta^{\mb{q}'}, x : A^{q'}}} \qquad
  \prftree[r]{\rle{skip}}
    {\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}}
    {\zeroq \leq q * \alquant(A)}
    {\cwk{\Gamma^{\mb{q}}, x : A^q}{\Delta}^{\mb{q}'}}
\end{gather*}
To define weakening, we extend the meet on $Q$ to a \emph{product} of quantities $q, q' \in Q^0$ as follows:
\begin{equation}
  q * q' = \begin{cases}
    0 & \text{if } q = 0 \text{ or } q' = 0 \\
    q \sqcap q' & \text{if } q, q' \in Q
  \end{cases}
\end{equation}
The rule \brle{skip} says affine variables are discarable, which it encodes via the condition $\zeroq \leq q * \alquant(A)$.  The rule \brle{cons}
says that we may replace a variable quantity $q$ with another quantity $q'$ allowing
less permissive usage \emph{relative to the type's quantity}. For example, for an affine
type $A$ (usable $\delq$), the quantity $\cpyq$ forces linear usage ($\cpyq \ast \delq = 1$), whereas
the quantity $\delq$ still permits deletion ($\delq \ast \delq = \delq$). This induces a \emph{preorder} on
contexts, with two contexts equivalent if their component variables can be used the same way.
%
We now  define \emph{context splitting} $\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}$ as
follows:
\begin{gather*}
  \prftree[r]{\rle{nil}}
    {\qsp{\cdot}{\cdot}{\cdot}{\cdot}} \qquad
  \prftree[r]{\rle{both}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\cpyq \leq q \sqcap \alquant(A)}
    {\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, q)}{(\mb{q}_r, q)}}
    \\
  \prftree[r]{\rle{left}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, q)}{(\mb{q}_r, \zeroq)}} \qquad
  \prftree[r]{\rle{right}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, \zeroq)}{(\mb{q}_r, q)}}
\end{gather*}
The rules \brle{left} and \brle{right} allow us to use a variable, regardless of quantity, in either
subexpression, whereas the rule \brle{both} states that it must be relevant to be used in both branches.

\subsubsection{Effects}
Our language of effects is a bounded\footnote{has a maximum element $\top$ and minimum element
$\bot$} join-semilattice $\mc{E}$. We will represent pure expressions as having the bottom effect
$\bot$, whereas expressions with effect $\top$ have ``arbitrary'' effect, and expressions with
effect $\epsilon \sqcup \epsilon'$ have both effects $\epsilon$ and $\epsilon'$.

Becaise we want to rewrite effectful programs it is not
enough to know which effects a program might have: we also need to know how they
interact. In particular, we need to know:
\begin{enumerate}
  \item Which effects are \emph{iterable}, i.e., stable under loops. 
  \item The \emph{multiplicity} of each effect $\epsilon$ : whether it
  is \emph{duplicable}, \emph{fusable}, \emph{introducible}, or \emph{eliminable}.
  \item If effect $\epsilon$ is a \emph{left-mover} or \emph{right-mover} relative to $\eta$  (i.e. can $\epsilon$ be moved before or after $\eta$) 
\end{enumerate}

Not all effects are stable under arbitrary iteration. For example, a pure, total computation
iterated infinitely often can now exhibit the effect of nontermination. Indeed, any total effect
(such as reading or writing from a location) repeated infinitely often can gain the nontermination
effect. To model stability, we are going to require that there is an upwards-closed subset
$\mc{E}^\infty \subseteq \mc{E}$ of \emph{iterative effects}. The intuition behinds the
upwards-closed requirement is that once nontermination is in the effect $\epsilon$, then it will
continue to be present in any supereffect.

To represent multiplicity, we take advantage of the fact that we already
have a notion of quantitity.  Unlike in ordinary linear type
systems, we are interested in refinement (a directed notion) rather than pure equations.  We
split the property of contraction into the pair of properties
\emph{duplicability} and \emph{fusability}: contraction in each direction of refinement. Likewise
weakening splits into the pair of directed weakening properties of \emph{eliminability} and
\emph{introducability}. To model this, we assign a \emph{pair} of quantities $\alquant^+(e),
\alquant^-(e) \in Q$ to each effect, such that
\begin{itemize}
  \item An effect can be eliminated if $\delq \leq \alquant^+(e)$, and introduced if $\delq \leq
  \alquant^-(e)$
  \item An effect can be duplicated if $\cpyq \leq \alquant^+(e)$, and fused if $\cpyq \leq
  \alquant^-(e)$
\end{itemize}
To be compatible with our notion of sub-effect, such a map should be \emph{antitone} and have
the property that $\alquant^p(\bot) = \topq$ for $p \in \{+, -\}$ (i.e., pure computations can
be used as often as you like).

Finally, we need to know how effects can be reordered. For example, a memory read and an IO write
cannot interfere,  and hence
can be reordered. To model this, we introduce a \emph{directed commutativity
relation} $\rightmove \subseteq \mc{E} \times \mc{E}$. If $\epsilon
\rightmove \epsilon'$, then a computation performing $\epsilon$-effects can be moved past a
computation performing $\epsilon'$-effects without introducing new behaviour. We require that $\bot
\rightmove \epsilon$ and $\epsilon \rightmove \bot$, to ensure that pure computations can be moved
freely, and we also require that the relation is antitone, to model that decreasing the number of
effects never loses rewrites. 
%
We introduce the syntax sugar $\epsilon \leftmove \eta \iff \eta \rightmove \epsilon$, $\epsilon
\slides \eta \iff \epsilon \rightmove \eta \land \epsilon \leftmove \eta$. For polarities $p \in
\{+, -\}$, we define $\rightmove^p$ in the obvious manner, with $\epsilon \rightmove^+ \eta \iff
\epsilon \rightmove \eta$ and $\epsilon \rightmove^- \eta \iff \epsilon \leftmove \eta$.
%
Putting all this together, we may now define an \emph{effect system} as follows:
\begin{definition}[Effect system]
  An \emph{effect system} $\mc{E}$ is a bounded join-semilattice $\mc{E}$
  equipped with:
  \begin{itemize}
  \item an upwards closed subset $\mc{E}^\infty$ of \emph{iterative effects} containing $\top$, and
  \item a pair of antitone maps $\alquant^+, \alquant^- : \mc{E} \to Q$ which map $\bot$ to $\topq$,
  \item a \emph{directed commutativity relation} $\rightmove \subseteq \mc{E} \times \mc{E}$,
  an antitone relation containing $\bot \rightmove \epsilon$ and $\epsilon \rightmove \bot$ for all $\epsilon$. 
  \end{itemize}

\end{definition}


\subsubsection{Typing rules}

We now have all the pieces we need to define a \subiterexp{}-\emph{signature}:
\begin{definition}[\subiterexp-signature]
  A \subiterexp signature $\mc{S} = (\mc{X}, \mc{I}, \mc{E})$ consists of a set of \emph{base types}
  $X \in \mc{X}$, a set of \emph{instructions} $f \in \mc{I}$, and an iterative effect system
  $\mc{E}$ such that we associate:
  \begin{itemize}
    \item Every base type $X$ type to a \emph{quantity} $\ms{q}(X) \in \{1, \delq, \cpyq, \topq\}$.
    \item Every instruction to a \emph{source type} $\ms{src}(f) = A$, a \emph{target type}
    $\ms{trg}(f) = B$, and an \emph{effect} $\ms{eff}(f) = \epsilon$. 
  \end{itemize}
\end{definition}
All the following definitions in this section will be with respect to an arbitrary
\subiterexp{}-signature $\mc{S}$. 
We give the typing rules for \subiterexp{} in Figure~\ref{fig:expr-typing}. Our rules
are syntax directed, with one rule for each production in our grammar. In
particular,
\begin{itemize}
  \item The \brle{var} rule says that a variable $x$ has type $A$ in
  the context $\Gamma^{\mb{q}}$ if $\Gamma^{\mb{q}}$ weakens to the singleton context $x: A^\oneq$,
  i.e., if $x$ has nonzero quantity and all other (unused) variables are affine. Since accessing a
  variable is pure, we can give it an arbitrary effect
  $\epsilon$. 
  \item To type a let-binding $\letexpr{x}{a}{e}$ in $\Gamma^{\mb{q}}$ with \brle{let$_1$} with
  effect $\epsilon$, we must:
  \begin{itemize}
    \item Split the context into a left-component $\mb{q}_l$ and a right-component
    $\mb{q}_r$, such that:
    \item $a$ is well-typed and has effect $\epsilon$ in the \emph{right} component
    $\Gamma^{\mb{q}_r}$, and $b$ is well-typed in $\Gamma^{\mb{q}_l}$ plus an unrestricted parameter $x: A^\top$.
  \end{itemize}
  \item \brle{case} and \brle{let$_2$} are similar, except that \brle{let$_2$}'s body requires two
  parameters (one for each component of the tensor product), while both branches of a case-statement
  share the \emph{same} left-component $\Gamma^{\mb{q}_l}$ (since exactly one branch is executed.)
  \item \brle{unit} is well-typed and pure (and therefore can be assigned an arbitrary effect
  $\epsilon$) in any context composed solely of affine variables, i.e. satisfying
  $\cwk{\Gamma^{\mb{q}}}{\cdot}$.
  \item \brle{pair} splits the context between
  the left and right components and checks each one,
  \item The \brle{iter} rule is the most complex: we split the context into a
  component $\mb{q}_r$ for the initial value and a component $\mb{q}_l$ for the body. The initial
  value is then evaluated and passed in as an additional parameter of type $A$ to the body. 
  $\mb{q}_l$ must be unrestricted, since the loop may execute any number of
  times. Finally, the effect of the loop body must be an iterative effect.
\end{itemize}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma^{\mb{q}}}{x : A^\oneq}}
        {\hasty{\Gamma^{\mb{q}}}{\epsilon}{x}{A}} 
      \qquad
    \prftree[r]{\rle{let$_1$}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}}}{}{\letexpr{x}{a}{b}}{B}}
      \\
    \prftree[r]{\rle{op}}{f : A \to_\epsilon B}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{f\;a}{B}}
      \qquad
    \prftree[r]{\rle{inst}}
      {f \in \mc{I}}
      {\ms{src}(f) = A}
      {\ms{trg}(f) = B}
      {\ms{eff}(f) \leq \epsilon}
      {f : A \to_\epsilon B}
      \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma^{\mb{q}}}{\cdot}}{\hasty{\Gamma^{\mb{q}}}{\epsilon}{()}{\mb{1}}} 
      \qquad
    \prftree[r]{\rle{pair}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{(a, b)}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{}{a}{A \otimes B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{(x, y)}{a}{c}}{C}}
      \\
    \prftree[r]{\rle{inl}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\linl{a}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\linr{b}}{A + B}} \qquad    
    \prftree[r]{\rle{abort}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\labort{a}}{C}}
      \\
    \prftree[r]{\rle{case}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{e}{A + B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}} \\
    \prftree[r]{\rle{iter}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \topq}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\liter{a}{x}{b}}{B}}
  \end{gather*}
  \end{adjustbox}
  \caption{Typing rules for \subiterexp{}}
  \Description{}
  \label{fig:expr-typing}
\end{figure}

\subsection{Syntactic Metatheory}

As a basic sanity check, we can verify that our calculus admits \emph{weakening}:
\begin{lemma}[name=Weakening, restate=synmonwk]
  If ${\cwk{\Gamma'^{\mb{q}'}}{\Gamma^{\mb{q}}}}$ and ${\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}$ then
  ${\hasty{\Gamma'^{\mb{q}'}}{\epsilon}{a}{A}}$. 
%   \begin{equation*}
%     \prftree[r]{\rle{wk}}
%       {\cwk{\Gamma'^{\mb{q}'}}{\Gamma^{\mb{q}}}}
%       {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
%       {\hasty{\Gamma'^{\mb{q}'}}{\epsilon}{a}{A}}
%   \end{equation*}
\end{lemma}

We now define substitution for effectful terms. First, we define a judgement $\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma}{\Delta^{\mb{q}'}}$
for substitutions, with rules in Figure~\ref{fig:expr-subst}. This may be read as ``$\sigma$ takes the
context $\Gamma^{\mb{q}}$ to the context $\Delta^{\mb{q}'}$ with effect $\epsilon$.'' Our rules may
be interpreted as follows:
\begin{itemize}
  \item \brle{nil} says that the empty substitution $\cdot$ takes any affine context
  $\Gamma^{\mb{q}}$ to the empty context $\cdot$. This holds because a
  well-typed term in the empty context is also well-typed in any affine context. The effect is an
  arbitrary $\epsilon$, since the empty substitution is always pure.
  \item  \brle{zero} rule says that if a variable $x : A^0$ is
  unused, then we can map it to an arbitrary (even ill-typed) term $a$. Since $x$ will 
  never appear in a well-typed term, $a$ will never appear in their
  substitutions, and therefore needs no restrictions. The effect $\epsilon$ of
  $\sigma$ is unchanged.
  \item \brle{cons}: to type a substitution $\sigma, x \mapsto a$ taking  $\Gamma^{\mb{q}}$ to
  $\Delta^{\mb{q}'}, x: A^q$ with effect $\epsilon$, we split the input context into a context
  $\Gamma^{\mb{q}_l}$, used to type $\sigma$ with effect $\epsilon_l \leq \epsilon$, and
  $\Gamma^{\mb{q}_r}$, used to type $a$ with effect $\epsilon_r \leq \epsilon$.  $\Gamma^{\mb{q}_r}$
  must be useable with quantity $q$; i.e., is relevant if $q$ is
  relevant and affine if $q$ is affine. Finally, the effect of $\sigma$
  ($\epsilon_l$) and the effect of $a$ ($\epsilon_r$) must commute.
\end{itemize}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{nil}}{\cwk{\Gamma^{\mb{q}}}{\cdot}}
                              {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\cdot}{\cdot}} \qquad 
    \prftree[r]{\rle{zero}}
      {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma}{\Delta}}
      {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma, x \mapsto a}{\Delta^{\mb{q}'}, x : A^0}}
    \\
    \prftree[r]{\rle{cons}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\issubst{\Gamma^{\mb{q_l}}}{\epsilon_l}{\sigma}{\Delta^{\mb{q}}}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon_r}{a}{A}}
      {q \leq \alquant(\Gamma^{\mb{q}_r})}
      {\epsilon_l \slides \epsilon_r}
      {\epsilon_l, \epsilon_r \leq \epsilon}
      {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma, x \mapsto a}
      {\Delta^{\mb{q}'}, x : A^q}}
  \end{gather*}
  \end{adjustbox}
  \caption{Substitution rules for \subiterexp{}}
  \Description{}
  \label{fig:expr-subst}
\end{figure}%
We write $[\sigma]$ for the action of substitution $\sigma$ on term $a$. We can now state
substitution:
\begin{lemma}[name=Substitution, restate=synmonsubst]
  If ${\issubst{\Gamma'^{\mb{q}'}}{\epsilon}{\sigma}{\Gamma^{\mb{q}}}}$
  and ${\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}$
  then ${\hasty{\Gamma'^{\mb{q}'}}{\epsilon}{[\sigma]a}{A}}$. 
%   The following rule is admissible:
%   \begin{equation*}
%     \prftree[r]{\rle{subst}}
%       {\issubst{\Gamma'^{\mb{q}'}}{\epsilon}{\sigma}{\Gamma^{\mb{q}}}}
%       {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
%       {\hasty{\Gamma'^{\mb{q}'}}{\epsilon}{[\sigma]a}{A}}
%   \end{equation*}
\end{lemma}

\subsection{Refinement Theory}

\label{ssec:refinement-theory}

We now define our core notion of refinement. The judgment
\begin{equation*}
  \tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}
\end{equation*}
means  $a$ is refined by $b$ in the context $\Gamma^{\mb{q}}$, modulo rewrites
$\mc{R}$. Intuitively, this expresses that $b$ is at least as defined or deterministic as $a$,
possibly after applying known rewrites in $\mc{R}$. We define equivalence of terms as mutual
refinement:
\begin{equation}
  \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}
  \iff \tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A} 
  \land \tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{a}{A}
\end{equation}
For notational convenience, we also use a polarity-marked notation
for refinement relation:
\begin{equation*}
  \tmlep{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}{+} \iff \tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A} \qquad
  \tmlep{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}{-} \iff \tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{a}{A}
\end{equation*}

A \emph{rewrite system} $\mc{R}$ consists of a set judgments of the form
$\tmle{\Gamma^{\mb{q}}}{}{a}{b}{A}$ closed under pure substitution. That is, given a pure
substitution $\sigma$, we have that
\begin{equation*}
  \prftree[r]{}
    {\issubst{\Gamma^{\mb{q}}}{\bot}{\sigma}{\Delta^{\mb{q}'}}}
    {(\tmle{\Delta^{\mb{q}'}}{}{a}{b}{A}) \in \mc{R}}
    {(\tmle{\Gamma^{\mb{q}}}{}{[\sigma]a}{[\sigma]b}{A}) \in \mc{R}} 
\end{equation*}
We will often describe a rewrite system as that \emph{generated} by a set of equations with free
variables; e.g., the system generated by $\tmle{x : \nats, y : \nats}{}{\ms{add}\;(x,
y)}{\ms{add}\;(y, x)}{\nats}$. Our goal is to construct a refinement relation $\tref$ satisfying the following properties: 
\begin{enumerate}
  \item \textbf{Inclusion of $\mc{R}$:} all given rewrites are valid refinements.
  \label{item:includes-rewrites}
  \item \textbf{Congruence:} $\tref$ is closed under term formers and is a preorder.
  \label{item:is-congruence}
  \item \textbf{Let-normalization:} $\tref$ abstracts away syntactic associativity of let-bindings.
  \label{item:abstracts-syntax}
  \item \textbf{Universal properties:} $\tref$ validates the $\beta$- and $\eta$-laws of the
  language. %; this ensures that our tensor product $\otimes$ and our coproduct $+$ satisfy the   relevant universal properties.
  \label{item:does-computation}
  \item \textbf{Iteration semantics:} $\tref$ captures fixpoint and control-flow behavior of
  iteration.
  \label{item:does-iteration}
\end{enumerate}
We guarantree that $\tref$ contains the (reflexive, transitive closure of) $\mc{R}$, and therefore
satisfies property~\ref{item:includes-rewrites}, by the following rules:
\begin{gather*}
  \prftree[r]{\rle{base}}
    {(\tmle{\Gamma^{\mb{q}}}{}{a}{b}{A}) \in \mc{R}}
    {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}} \qquad
  \prftree[r]{\rle{refl}}
    {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
    {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a}{A}}
  \qquad
  \prftree[r]{\rle{trans}}
    {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}}
    {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{c}{A}}
    {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{c}{A}}
\end{gather*}
The other congruence rules (in the appendix in Figure~\ref{fig:congruence-refinement})
correspond one-to-one with our term formers to ensure property~\ref{item:is-congruence}. Property~\ref{item:is-congruence} means that the induced equivalence $\approx$ is also a congruence.

To satisfy property~\ref{item:abstracts-syntax}, we introduce the binding rules
(Figure~\ref{fig:binding-rules}), which are stated as equivalences. These rules express syntactic
equivalences up to reassociation and let-floating. For instance, nested let-bindings are rearranged
to a canonical form. We do not require binding rules for every constructrules for pairs and sums,
for example, can be derived via $\beta$-reduction.

Property~\ref{item:does-computation} is addressed via the reduction rules
(Figure~\ref{fig:reduction-rules}). Most of these are standard $\beta$- and $\eta$-equivalences.
However, the rule \brle{let$_1$-$\beta^p$} is \emph{directional}: it expresses that
$\letexpr{x}{a}{b}$ refines $[x/a]b$ when the effect $\epsilon$ of $a$ is a right-mover with respect
to the effect $\eta$ of $b$, and when $x$ is used in a way compatible with $\epsilon$ and the
context. We also require that the context $\Gamma^{\mb{q}_r}$ used to type $a$ has a linearity
compatible with the usage of $x$ in $b$, as well as with the effect $\epsilon$ (for example, since
printing is linear, if $a$ performs printing then $x$ must be used linearly in $b$ even if $b$ is
pure). The reverse direction is permitted only under the dual (left-mover) condition. Thus, the
usual $\beta$-equation:
\[
\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{[x/a]b}{B}
\]
is derivable under sufficient purity assumptions, and in particular always holds when $\epsilon =
\bot$. 
%
The rule \brle{elim}, at first glance, can be viewed as a special case of \brle{let$_1$-$\beta^p$}
(combined with \brle{term}), but is introduced as a separate rule since it does \emph{not} require
$\Gamma^{\mb{q}_l}$ to be affine to delete $a$.

In particular, this means that the following more standard typing rule is \emph{derivable}:
\begin{equation}
  \prftree[r]{\rle{let$_1$-$\beta$}}
  {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
  {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
  {\hasty{\Gamma^{\mb{q}_r}, x : A^q}{\eta}{b}{B}}
  {\epsilon \slides \eta}
  {q \leq \alquant(\Gamma^{\mb{q}_r}) \sqcap \alquant(\epsilon)}
  {
    \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{[x/a]b}{B}
  }
\end{equation}
In particular, this obviously holds for pure expressions with $\epsilon = \bot$ (modulo linearity of
$\Gamma^{\mb{q}_r}$), as we would normally expect in an effectful language.

The last thing that remains is to treat iteration. Our rules for iteration, given in
Figure~\ref{fig:iteration-rules}, are based on the properties of a Conway iteration operator as
given in \citet{coinductive-resumption-levy-goncharov-19}. In particular, we require our operator to
satisfy the following properties:
%
\paragraph{Fixpoint} behavior is encoded by the rule \textsf{iter-$\beta$}, which expresses that
iteration behaves as a least fixpoint. That is, $\liter{a}{x}{b}$ evaluates to $a$, then to
$b[a/x]$, and depending on the result of $b$, either exits with a value in the left branch or
continues recursively with a value in the right branch. This unfolds the iteration into a case
split
$
%\liter{a}{x}{b} \equiv 
\letexpr{x}{a}{\caseexpr{b}{y}{y}{z}{\liter{z}{x}{b}}}
$
capturing precisely one unfolding of the loop. This gives rise to an inductive account of iteration
semantics that meshes naturally with refinement.
%
\paragraph{Naturality,} expressed by the rule \textsf{let-iter}, states that sequencing a
computation $c$ after a loop can be interchanged with sequencing $c$ inside the loops exit branch.
This enables reasoning about program structure independent of surface syntax and supports
loop-invariant motion of subsequent code.
%
\paragraph{Codiagonality,} via the rule \textsf{codiag}, states that nested iterations of the same
body can be collapsed into a single iteration by fusing their recursive branches. Operationally,
this justifies flattening nested loops into one with a more complex continuation.
%
\paragraph{Uniformity,} via the rule \textsf{unif$^p$}, allows us to effectively commute certain
effectful operations with the infinite unrolling of a loop body. This is best explained in terms of
control-flow graphs: the precondition of the rule is corresponds to the left-hand-side of the
diagram in Figure~\ref{fig:unif-cfg}, while the postcondition corresponds to the right-hand-side. If
we unroll the loops on both sides ``infinitely many times,'' to obtain an infinite tree, we see that
\textsf{unif$^p$} just says that we can apply the rewrite on the left-hand-side ``infinitely many
times'' to convert a tree of $b$'s into a tree of $b'$'s. The name uniformity is by analogy to
uniformity in analysis, in which an operation can be used to uniformly transmute each term of an
infinite series (rather than only be valid for a finite number of terms).

Note that we \emph{cannot} do this for an arbitrary $s$; we need it to \emph{commute} with the
effect of the loop. For example, if the effect of the loop is (potential) nontermination, and $s$
contains a print-statement, uniformity does \emph{not} apply, since while for any given iteration of
the loop body we have, where $\ms{print}: \mb{1}$ and $\ms{expr}: \mb{1} + \mb{1}$ commutative with
printing (e.g., reading and writing from memory),
$
\ms{print} ; \ms{expr} \approx
\caseexpr{\ms{expr}}
  {x}{{\linl{\ms{print}}}}
  {y}{{\linl{\ms{print}}}}
$
but
$$
\liter{\ms{print}}{\cdot}{\ms{expr}} \not\approx
\liter{()}{\cdot}{\caseexpr{\ms{expr}}
  {x}{\linl{\ms{print}}}{y}{\linl{y}}}
$$
since the latter may delay the print-statement infinitely far into the future, and hence hang before
printing. On the other hand, if we instead have commutative effects (e.g., if $s$ has nondeterminism
and the loop has printing and nontermination), we can safely perform the infinite rewrite.

We will denote the set of refinements generated by a set of base refinements $\mc{R}$ as
$\ms{Th}(\mc{R})$. In particular, we note that $\ms{Th}(\cdot)$ is monotonic, idempotent, and
satisfies $\mc{R} \subseteq \ms{Th}(\mc{R})$, making it a closure operator.


\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{let-op}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {f : A \to_\epsilon B}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{c}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{y}{f\;a}{c}}
        {\letexpr{x}{a}{\letexpr{y}{f\;x}{c}}}
        {C}}
      \\
    \prftree[r]{\rle{let-let$_1$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}}
      {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_m}, x : A}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{c}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{y}{(\letexpr{x}{a}{b})}{c}}
          {\letexpr{x}{a}{\letexpr{y}{b}{c}}}
          {C}
      }
      \\
    \prftree[r]{\rle{let-let$_2$}}
      {
        \prfStackPremises
        {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}}
        {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}}
      }
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
      {\hasty{\Gamma^{\mb{q}_m}, x : A, y : B}{\epsilon}{c}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, z : C}{\epsilon}{d}{D}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{z}{(\letexpr{(x, y)}{a}{c})}{d}}
          {\letexpr{(x, y)}{a}{\letexpr{z}{c}{d}}}
          {D}
      }
      \\
    \prftree[r]{\rle{let-case}}
      {
        \prfStackPremises
        {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}}
        {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}}
      }
      {\hasty{\Gamma^{\mb{q}_m}}{\mc{R}}{e}{A + B}}
      {
        \prfStackPremises
        {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
        {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      }
      {
        {\hasty{\Gamma^{\mb{q}_r}, z : C}{\mc{R}}{d}{D}}
      }
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{z}{\caseexpr{e}{x}{a}{y}{b}}{d}}
        {\caseexpr{e}{x}{\letexpr{z}{a}{d}}{y}{\letexpr{z}{b}{d}}}
        {D}
      } 
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{let$_2$-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{(x, y)}{a}{c}}
          {\letexpr{z}{a}{\letexpr{(x, y)}{z}{c}}}
          {C}
      } \\
    \prftree[r]{\rle{case-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{A + B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{e}{x}{a}{y}{b}}
        {\letexpr{z}{e}{\caseexpr{z}{x}{a}{y}{b}}}
        {C}
      } \\
    \prftree[r]{\rle{iter-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{b}}{\letexpr{y}{a}{\liter{y}{x}{b}}}{B}}
  \end{gather*}
  \end{adjustbox}
  \caption{Binding rules for \subiterexp{}}
  \Description{}
  \label{fig:binding-rules}
\end{figure}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{term}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{\mb{1}}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{()}}{a}{\mb{1}}} \qquad
    \prftree[r]{\rle{elim}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}}}
      {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{\mb{1}}}
      {0 \leq \alquant^p(\epsilon)}
      {\hasty{\Gamma^{\mb{q}}}{\eta}{b}{B}}
      {\tmlep{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{\letexpr{x}{()}{b}}{B}{p}}
    \\
    \prftree[r]{\rle{init}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b'}{B}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{\labort{a}}{b}}{\letexpr{x}{\labort{a}}{b'}}{B}
      } \\
    \prftree[r]{\rle{let$_2$-$\eta$}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A \otimes B}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{(x, y)}{a}{(x, y)}}{a}{A \otimes B}
      } \\
    \prftree[r]{\rle{let$_2$-$\beta$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\qsp{\Gamma}{\mb{q}_l}{\mb{q}_a}{\mb{q}_b}}
      {\hasty{\Gamma^{\mb{q}_a}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_b}}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}_r}, x : A, y : B}{\epsilon}{c}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{(x, y)}{(a, b)}{c}}
          {\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}
      } \\
    \prftree[r]{\rle{case-$\beta_l$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{\linl{e}}{x}{a}{y}{b}}
        {\letexpr{x}{e}{a}}
        {C}
      } \\
    \prftree[r]{\rle{case-$\beta_r$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{\linr{e}}{x}{a}{y}{b}}
        {\letexpr{y}{e}{b}}
        {C}
      } \\
    \prftree[r]{\rle{case-$\eta$}}
      {\hasty{\Gamma^{\mb{q}}}{\mc{R}}{e}{A + B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{e}{x}{\linl{x}}{y}{\linr{y}}}
        {e}
        {A + B}
      } \\
    \prftree[r]{\rle{let$_1$-$\beta^p$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}, x : A^q}{\eta}{b}{B}}
      {\epsilon \rightmove \eta}
      {q \leq \alquant(\Gamma^{\mb{q}_r}) \sqcap \alquant^p(\epsilon)}
      {
        \tmlep{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{[x/a]b}{B}{p}
      }
  \end{gather*}
  \end{adjustbox}
  \caption{Reduction rules for \subiterexp{}}
  \Description{}
  \label{fig:reduction-rules}
\end{figure}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{iter-$\beta$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      {\tmeq
        {\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{b}}
        {\letexpr{x}{a}{\caseexpr{b}{y}{y}{z}{\liter{z}{x}{b}}}}{B}}
    \\
    \prftree[r]{\rle{let-iter}}
      {
      \prfStackPremises
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_c}}
      {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_m}{\mb{q}_r}}
      }
      {
      \prfStackPremises
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\alquant(\Gamma^{\mb{q}_m}) = \top}
      }
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_m}, x : A}{\epsilon}{b}{B + A}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{c}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{y}{\liter{a}{x}{b}}{c}}
        {\liter{a}{x}{\caseexpr{b}{y}{\linl{c}}{z}{\linr{z}}}}
        {C}
      } \\
    \prftree[r]{\rle{codiag}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, y : A}{\epsilon}{b}{(B + A) + A}}
      {\tmeq
        {\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{\liter{x}{y}{b}}}
        {\liter{a}{y}{\caseexpr{b}{x}{x}{y}{\linr{y}}}}{B}} \\
    % \prftree[r]{\rle{dist}}
    %   {
    %   \prfStackPremises
    %   {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_c}}
    %   {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_m}{\mb{q}_r}}
    %   }
    %   {\alquant(\Gamma^{\mb{q}_m}) = \top}
    %   {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
    %   {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{b}{B}}
    %   {\hasty{\Gamma^{\mb{q}_m}, y : B}{\epsilon}{c}{C + B}}
    %   {
    %     % \prfStackPremises
    %     % {\Gamma^{\mb{q}} \vdash_{\mc{R}} (a, \liter{b}{y}{c})}
    %     % {\approx \liter{(a, b)}{(x, y)}{\caseexpr{c}{z}{\linl{(x, z)}}{w}{\linr{(x, w)}}} 
    %     % : A \otimes C}
    %     \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
    %       {(a, \liter{b}{y}{c})}
    %       {\liter{(a, b)}{(x, y)}{\caseexpr{c}{z}{\linl{(x, z)}}{w}{\linr{(x, w)}}}}
    %       {A \otimes C}
    %   }
  \end{gather*}
  % \begin{gather*}
  %   \prftree[r]{\rle{unif$^p$}}
  %     {\eta \rightmove \epsilon}
  %     {\tmlep{\Gamma^{\mb{q}_c}, x : A}{\mc{R}}
  %       {\letexpr{y}{s}{b}}
  %       {\caseexpr{b'}{x}{\linl{x}}{x}{\linr{s}}}{B + S}{p}}
  %     {
  %       \tmlep{\Gamma^{\mb{q}}}
  %         {\mc{R}}
  %         {\letexpr{x}{a}{\liter{s}{y}{b}}}
  %         {\liter{a}{x}{b'}}
  %         {B}
  %         {p}
  %     } \\
  %   \text{where} \qquad {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}} \qquad
  %   {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}} \qquad
  %   \alquant(\Gamma^{\mb{q}_c}) = \top \qquad
  %   \einf{\epsilon}
  %   \\
  %   \qquad {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
  %   \qquad {\hasty{\Gamma^{\mb{q}_m}, x : A}{\eta}{s}{S}}
  %   \qquad {\hasty{\Gamma^{\mb{q}_l}, y : S}{\epsilon}{b}{B + A}}
  %   \qquad {\hasty{\Gamma^{\mb{q}_c}, x : A}{}{b'}{B + A}}
  % \end{gather*} 
  \begin{gather*}
    \prftree[r]{\rle{unif$^p$}}
      {\eta \rightmove \epsilon}
      {\tmlep{\Gamma^{\mb{q}_c}, x : A}{\mc{R}}
        {\letexpr{y}{s}{b}}
        {\caseexpr{b'}{z}{\linl{c}}{x}{\linr{s}}}{C + S}{p}}
      {
        \tmlep{\Gamma^{\mb{q}}}
          {\mc{R}}
          {\letexpr{x}{a}{\liter{s}{y}{b}}}
          {\letexpr{z}{\liter{a}{x}{b'}}{c}}
          {C}
          {p}
      } \\
    \text{where} \qquad {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}} \qquad
    {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_c}} \qquad
    \alquant(\Gamma^{\mb{q}_l}) = \top \qquad
    \einf{\epsilon} \qquad
    {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
    \\
    \qquad {\hasty{\Gamma^{\mb{q}_c}, x : A}{\eta}{s}{S}}
    \qquad {\hasty{\Gamma^{\mb{q}_l}, y : S}{\epsilon}{b}{C + A}}
    \qquad {\hasty{\Gamma^{\mb{q}_l}, x : A}{}{b'}{B + A}}
    \qquad {\hasty{\Gamma^{\mb{q}_c}, z : B}{}{c}{C}}
  \end{gather*} 
  \end{adjustbox}
  \caption{Iteration rules for \subiterexp{}}
  \Description{}
  \label{fig:iteration-rules}
\end{figure}

\begin{figure}
    \centering
    % \begin{tikzpicture}
    %   \node[] (A) at (0, 1.5) {$A$};
    %   \node[box] (s) at (0, 0.5625) {s};
    %   \node[box=2/0/2/0] (b) at (0, -0.5625) {\quad b \quad};
    %   \node[] (B) at (-0.3, -1.5) {$B$};
    %   \node[] (C) at (0.3, -1.5) {$C$};
    %   \node[] (r) at (1.3125, -0.225) {$\tref^p$};
    %   \node[] (A2) at (2.625, 1.5) {$A$};
    %   \node[box=2/0/2/0] (b2) at (2.625, 0.5625) {\quad b' \quad};
    %   \node[box] (s2) at (2.8725, -0.5625) {s};
    %   \node[] (B2) at (2.3, -1.5) {$B$};
    %   \node[] (C2) at (2.8725, -1.5) {$C$};
    %   \node[] (r) at (4.35, -0.225) {$\implies$};
    %   \node[] (A3) at (5.8275, 1.5) {$A$};
    %   \node[box] (s3) at (5.8275, 0.5625) {s};
    %   \node[dot] (fix1) at (5.8275, 0) {};
    %   \coordinate (cap1) at (6.75, -0.4) {};
    %   \coordinate (cup1) at (6.75, -0.9) {};
    %   \node[box=2/0/2/0] (b3) at (5.8275, -0.5625) {\quad b \quad};
    %   \node[] (B3) at (5.8275, -1.5) {$B$};
    %   \node[] (r2) at (7.14, -0.225) {$\tref^p$};
    %   \node[] (A4) at (8.4525, 1.5) {$A$};
    %   \node[dot] (fix2) at (8.4525, 0.3375) {};
    %   \coordinate (cap2) at (9.375, -0.075) {};
    %   \coordinate (cup2) at (9.375, -0.525) {};
    %   \node[box=2/0/2/0] (b4) at (8.4525, -0.225) {\quad b' \quad};
    %   \node[] (B4) at (8.4525, -1.5) {$B$};
    %   \wires{ 
    %     A = { south = s.north },
    %     s = { south = b.north },
    %     b = { south.1 = B.north, south.2 = C.north },
    %     A2 = { south = b2.north },
    %     b2 = { south.1 = B2.north, south.2 = s2.north },
    %     s2 = { south = C2.north },
    %     A3 = { south = s3.north },
    %     s3 = { south = fix1.north },
    %     fix1 = { south = b3.north },
    %     b3 = { south.1 = B3.north, south.2 = cup1.south },
    %     cup1 = { north = cap1.south },
    %     cap1 = { north = fix1.east },
    %     A4 = { south = fix2.north },
    %     fix2 = { south = b4.north },
    %     b4 = { south.1 = B4.north, south.2 = cup2.south },
    %     cup2 = { north = cap2.south },
    %     cap2 = { north = fix2.east },
    %   }{}
    % \end{tikzpicture}
    \begin{tikzpicture}
      \node[] (in1) at (0, 1.5) {$A$};
      \node[box] (s) at (0, 0.5625) {s};
      \node[box=2/0/2/0] (b) at (0, -0.5625) {\quad b \quad};
      \node[] (out11) at (-0.3, -1.5) {$C$};
      \node[] (out21) at (0.3, -1.5) {$A$};
      \node[] (r) at (1.3125, -0.225) {$\tref^p$};
      \node[] (in2) at (2.625, 1.5) {$A$};
      \node[box=2/0/2/0] (b2) at (2.625, 0.5625) {\quad b' \quad};
      \node[box] (c1) at (2.2, -0.5625) {c};
      \node[box] (s2) at (3, -0.5625) {s};
      \node[] (out12) at (2.3, -1.5) {$C$};
      \node[] (out22) at (2.8725, -1.5) {$A$};
      \node[] (r) at (4.35, -0.225) {$\implies$};
      \node[] (in3) at (5.8275, 1.5) {$A$};
      \node[box] (s3) at (5.8275, 0.5625) {s};
      \node[dot] (fix1) at (5.8275, 0) {};
      \coordinate (cap1) at (6.75, -0.4) {};
      \coordinate (cup1) at (6.75, -0.9) {};
      \node[box=2/0/2/0] (b3) at (5.8275, -0.5625) {\quad b \quad};
      \node[] (out13) at (5.8275, -1.5) {$C$};
      \node[] (r2) at (7.14, -0.225) {$\tref^p$};
      \node[] (in4) at (8.4525, 1.5) {$A$};
      \node[dot] (fix2) at (8.4525, 0.9375) {};
      \coordinate (cap2) at (9.375, 0.55) {};
      \coordinate (cup2) at (9.375, 0.1) {};
      \node[box=2/0/2/0] (b4) at (8.4525, 0.4) {\quad b' \quad};
      \node[box=2/0/2/0] (c2) at (8.2, -0.5625) {c};
      \node[] (out14) at (8.4525, -1.5) {$C$};
      \wires{ 
        in1 = { south = s.north },
        s = { south = b.north },
        b = { south.1 = out11.north, south.2 = out21.north },
        in2 = { south = b2.north },
        b2 = { south.1 = c1.north, south.2 = s2.north },
        c1 = { south = out12.north },
        s2 = { south = out22.north },
        in3 = { south = s3.north },
        s3 = { south = fix1.north },
        fix1 = { south = b3.north },
        b3 = { south.1 = out13.north, south.2 = cup1.south },
        cup1 = { north = cap1.south },
        cap1 = { north = fix1.east },
        in4 = { south = fix2.north },
        fix2 = { south = b4.north },
        b4 = { south.1 = c2.north, south.2 = cup2.south },
        c2 = { south = out14.north },
        cup2 = { north = cap2.south },
        cap2 = { north = fix2.east },
      }{}
    \end{tikzpicture}
  \caption{Control-flow graphs for the uniformity rule in Figure~\ref{fig:iteration-rules}}
  \Description{}
  \label{fig:unif-cfg}
\end{figure}

\section{Semantics}

In this section, we will work towards a categorical semantics for \subiterexp{}, which we will later
prove to be sound and complete w.r.t. the refinement theory in Section~\ref{ssec:refinement-theory}.
More precisely, fixing a category $\mc{C}$, we wish to map types $A$ and contexts $\Gamma^{\mb{q}}$
to objects $\dnt{A}$ and $\dnt{\Gamma^{\mb{q}}}$ respectively, and then take the semantics
$\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}$ of a well-typed term to be a morphism
$\mc{C}(\dnt{\Gamma^{\mb{q}}}, \dnt{A})$.

\subsection{Models of \subiterexp{}}

A good categorical semantics is one in which the semantics of a term is constructed in a
straightforward, compositional manner from the semantics of its subterms. Furthermore, we would like
the equational properties of our term formers to correspond closely to the universal properties of
the categorical structure used to interpret them. Thus, our goal is to pick categorical structures
which correspond  one-to-one to the features of \subiterexp{}. In particular, we need to find
categorical structures to model our three primary structured control-flow constructs, which are:
\begin{itemize}
  \item \emph{Sequencing} and \emph{binding}, which we will do using the structure of a
  \emph{premonoidal category}
  \item \emph{Branching}, which we will do using \emph{coproducts}
  \item \emph{Iteration}, which we will do using a \emph{Conway operator}
\end{itemize}
To maintain compositionality, we must additionally require that these structures interact properly 
with each other. Hence, we will also require our category to satisfy
\begin{itemize}
  \item \emph{Distributivity}, which ensures the premonoidal and coproduct structures are compatible
  \item \emph{Strength}, which ensures the Conway operator is compatible with the premonoidal
  structure
  \item \emph{(Directed) Uniformity}, which ensures the Conway operator is compatible with our
  effect and refinement systems.
\end{itemize}
Finally, we'll need to model the features of our type theory; particularly:
\begin{itemize}
  \item \emph{Refinement}, which we will do using \emph{poset-enrichment}
  \item \emph{Effects}, which we will do by introducing the new notion of a \emph{substructural
  effectful category}
\end{itemize}

In ordinary categorical semantics, we want syntactic equivalence to
correspond to equality of morphisms: given $\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}$,
$\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{A}}$. 

However, in our calculus, we do not only have a syntactic notion of equivalence, but we also have
the order structure arising from refinement. Since terms correpond to morphisms, this means we need
to be able to compare morphisms according to an order structure interpreting the refinement
relation. Thus, to interpret $\tref$, we generalize from ordinary categories to
\emph{poset-enriched} categories, in which our hom-sets are partially ordered. In particular, we
define:

\begin{definition}[Poset-enriched category]
  A category $\mc{C}$ is \emph{poset-enriched} if each hom-set $\mc{C}(A, B)$ is equipped with a
  partial order $\cref$ which is compatible with composition, i.e., which satisfies
  $$
  \forall f \cref f' \in \mc{C}(A, B) . \forall g \tref g' \in \mc{C}(B, C) . 
    (f ; g) \tref (f' ; g')
  $$
  A poset-enriched functor between categories $\mc{C}$, $\mc{D}$ is then simply a functor whose
  action on morphisms is monotonic.
\end{definition}

We can now quite naturally intepret soundness of refinement as follows: given
$\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}$, we require that
$\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} \cref \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{A}}$.
Soundness of equivalence follows directly from antisymmetry of partial orders.\footnote{Requiring
$\mc{C}$ to be a poset-enriched category does not in fact rob us of any generality, since \emph{all}
categories are poset-enriched under the identity ordering on hom-sets.}

We now wish to give poset-enriched versions of the models for our three control-flow primitives,
namely, seqencing, branching, and iteration. Premonoidal categories were introduced in
\citet{power-premonoidal-97} to model side-effectful, sequential computations with first-order
binding. A premonoidal category can be viewed as a generalization of a monoidal category, in which
\emph{sliding} does not necessarily hold; i.e., we have that, in general,
$
(f \otimes \ms{id}) ; (\ms{id} \otimes g) \neq
(\ms{id} \otimes g) ; (f \otimes \ms{id})
$.
To better understand this in terms of programming languages, a premonoidal category may also be
viewed as a generalization of the Moggi's \cite{moggi-91-monad} monadic semantics: if we consider a
strong monad over a Cartesian category, then the Kleisli category is premonoidal with the Cartesian
product in the underlying category as tensor product. 

The Kleisli category satisfies sliding when the underlying monad is \emph{commutative}: when the
sequencing of side-effects does not matter (e.g., the reader monad). We need to generalize monoidal
categories to premonoidal categories precisely to support monads for which sequencing does matter,
such as printing or state. For example, given a function $\ms{print}: \ms{str} \to ()$,
$
(\ms{print} \otimes \ms{id}) ; (\ms{id} \otimes \ms{print}) \neq
(\ms{id} \otimes \ms{print}) ; (\ms{print} \otimes \ms{id}) 
$
since, given input $(\mathtt{"hello"}, \mathtt{"world"})$, the left-hand side will print
$\mathtt{hello world}$, while the right-hand side will print $\mathtt{world hello}$. Note that the
sequencing in the induced premonoidal category corresponds precisely to the bind of the underlying
monad.

We give a precise definition of a (\emph{poset-enriched}) premonoidal category below:
\begin{definition}[Symmetric Premonoidal Category]
  We define a \emph{binoidal category} to be a category $\mc{C}$ equipped with a binary operation
  $\otimes : |\mc{C}| \times |\mc{C}| \to |\mc{C}|$ on the objects of $\mc{C}$ and, for each $A, B
  \in |\mc{C}|$, functors $A \otimes -, - \otimes B : \mc{C} \to \mc{C}$. We say a morphism $f : A
  \to A'$ in a binoidal category is \emph{central} if, for all $g : B \to B'$, it satisfies
  \emph{sliding}:
  $$
  f \otimes B ; A' \otimes g = A \otimes g ; f \otimes B' \qquad
  B \otimes f ; g \otimes A' = g \otimes A ; B' \otimes f
  $$
  in which case we may write these morphisms as $f \otimes g : A \otimes B \to A' \otimes B'$ and $g
  \otimes f : B \otimes A \to B' \otimes A'$ respectively. In the poset-enriched setting, we also
  assume that the left and right tensor functors are poset-enriched, i.e. monotonic on morphisms.
  
  A \emph{premonoidal category} is, then, a
  binoidal category equipped with:
  \begin{itemize}
    \item An \emph{identity} object $I \in |\mc{C}|$
    \item For each triple of objects $A, B, C \in |\mc{C}|$, a central, natural isomorphism
    $\alpha_{A, B, C} : (A \otimes B) \otimes C \to A \otimes (B \otimes C)$, the \emph{associator}
    \item For each object $A$, central, natural isomorphisms $\lambda_A : A \otimes I \to A$ and
    $\rho_A : I \otimes A \to A$, the \emph{left} and \emph{right unitors}
  \end{itemize}
  satisfying the \emph{triangle} and \emph{pentagon identity}
  $$
  \alpha_{A, I, B} ; A \otimes \lambda_B = \rho_A \otimes B \qquad
  \alpha_{A \otimes B, C, D} ; \alpha_{A, B, C \otimes D}
  = \alpha_{A, B, C} \otimes D ; \alpha_{A, B \otimes C, D} ; A \otimes \alpha_{A, B, C}
  $$
  We say a premonoidal category is \emph{symmetric} if it is also equipped with a central, natural
  involution $\sigma_{A, B} : A \otimes B \to B \otimes A$, the \textit{symmetry}, satisfying the
  \emph{hexagon identity}
  $$
  \alpha_{A, B, C} ; \sigma_{A, B \otimes C} ; \alpha_{B, C, A}
  = \sigma_{A, B} \otimes C ; \alpha_{B, A, C} ; B \otimes \sigma_{A, C}
  $$
\end{definition}
% This gives us a nice alternate characterization of (poset-enriched) monoidal categories as well:
% \begin{definition}[(Symmetric) Monoidal Category]
%   We say a (symmetric) premonoidal category is \emph{(symmetric) monoidal} if every morphism is
%   central.
% \end{definition}
One theorem of note about premonoidal categories is \emph{coherence}, which we state as follows:
\begin{theorem}
  For any premonoidal category $\mc{C}$, the subcategory $\mc{C}_\mc{A}$ generated by associators,
  unitors, and their tensor products is an equivalence relation, i.e., for all $A, B :
  |\mc{C}_\mc{A}|$, if $f, g : A \to B$ can be constructed using only identity, composition,
  associators, unitors, and their tensor products, then $f = g$, and $f, g$ are isomorphisms in
  $\mc{C}_\mc{A}$.
  \label{thm:monoidal-coherence}
\end{theorem}
We will hence sometimes abuse notation and write $\alpha_B : \mc{C}(A, B)$ or simply $\alpha$ for
the unique morphism in $\mc{C}_\mc{A}$ from $A$ to $B$, where the composition of associators and
unitors is too cumbersome to write out in full. In particular, we note that we always have that
$\alpha: \mc{C}(A, A) := \ms{id}_A$.

We model branching control-flow using the coproduct $A + B$ as a primitive, whose definition is
unchanged in the poset-enriched setting. Given morphisms $f : A \to C$ and $g : B \to C$, their
coproduct $[f, g] : A + B \to C$ quite naturally models a case-statement which executes $f$ given an
$A$ and executes $g$ given a $B$. We can then implement an if-statement as a case-statement on
$\mb{2} = I + I$.

Since coproducts induce a monoidal structure on a category, we will also write $\alpha^+_B :
\mc{C}(A, B)$ or simply $\alpha^+$ to denote the unique morphism from $A$ to $B$ with analogy to the
$\alpha$ notation described above. Similarly, we will write $\sigma^+$ to denote the symmetry for
coproducts.

Coproducts on their own, however, cannot interpret variables captured by the branches of a
case-statement. For example, given $x : \mbb{Z}$, $y : \mbb{Z} + \ms{str}$, consider the following
expression:
$$
\caseexpr{y}{y}{\ms{print}(\texttt{"add: "}, x + y)}{y}{\ms{print}(y, x)}
$$
While our input context corresponds to the object $\mbb{Z} \otimes (\mbb{Z} + \ms{str})$, we need to
somehow get to $(\mbb{Z} \otimes \mbb{Z}) + (\mbb{Z} \otimes \ms{str})$ to be able to evaluate our
branches. Categorically, what we require is that our tensor product \emph{distributes} over our
coproduct; in which case we say our category is \emph{distributive}:
\begin{definition}[Distributive Category]
  We say a premonoidal category is \emph{distributive} if:
  \begin{itemize}
    \item It is equipped with chosen coproducts $A + B$ such that the injections $\iota_l, \iota_r$
    are central
    \item The obvious morphism $\delta : (A \otimes B) + (A \otimes C) \to A \otimes (B + C)$ is an
    isomorphism.
  \end{itemize}
\end{definition}

The last control-flow construct we need to model is looping. A loop with input $A$ will either exit
with output $B$ or recurse with a new input $A$. Consequently, since we model branching control-flow
using coproducts, the \emph{body} of a loop will look like a morphism $A \to B + A$. Therefore, a
natural way to model iteration is to posit the existence of a fixpoint operator $(\cdot)^\dagger$
taking morphisms $f: A \to B + A$ to their fixpoints $f^\dagger: A \to B$. $f^\dagger$ being the
fixpoint of the body $f$ means that executing $f^\dagger$ on an input $A$ is the same as executing
$f$ on an input $A$ and,
\begin{itemize}
  \item If we get an output $B$, return it
  \item If we get an output $A$, feed it as an input to $f^\dagger$ and return the resulting $B$
\end{itemize}
Indeed, in a functional language supporting higher-order functions such as ML or Haskell, we might
write \texttt{iterate :: (A -> B + A) -> A -> B} with definition
\begin{center}
  \begin{minipage}{0.85\textwidth}
    \begin{lstlisting}[language=Haskell]
      iterate f a = case f a of { Left b -> b ; Right a' -> iterate f a' }
    \end{lstlisting}
  \end{minipage}
\end{center}
This corresponds exactly to the notion of a \emph{pre-iterative category} given below:
\begin{definition}[Pre-iterative Category]
  Let $\mc{C}$ be a category with chosen coproducts. We say $\mc{C}$ is \emph{pre-iterative} if it
  is equipped with a fixpoint operator $(-)^\dagger : \mc{C}(A, B + A) \to \mc{C}(A, B)$ satisfying
  the loop unrolling equation $f ; [\ms{id}, f^\dagger] = f$
\end{definition}
Our goal is to have our fixpoint operator's properties correspond precisely to drawing a loop in a
control-flow graph, as in the left-hand side of Figure~\ref{fig:fixpoint-string-diagram}, which
corresponds to $f^\dagger$. In particular, we should be able to reconfigure such diagrams up to
isotopy (i.e., moving boxes and wires around without changing connectivity) without changing the
meaning of our program. To be able to do so soundly, we will need to introduce some additional
equations, which correspond to the graphical transformations in
Figure~\ref{fig:elgot-ax-string-diagrams}; a fixpoint satisfying these equations is called a
\emph{Conway iteration operator}, as defined below:
\begin{definition}[Conway Iteration Operator]
  Given a pre-iterative category $\mc{C}$, we say $(-)^\dagger$ is a \emph{Conway iteration
  operator} if it additionally satisfies
  \begin{itemize}
    \item \emph{Naturality:} given $f : A \to B + A$ and $g : B \to C$, we have
      $
      (f;g + \ms{id})^\dagger = f^\dagger;g : A \to C
      $
    \item \emph{Dinaturality:} given morphisms $g : A \to B + C$ and $h : C \to B + A$, we have that
      $
      (g ; [\iota_l, h])^\dagger = g ; [\ms{id}_B, (h ; [\iota_l, g])^\dagger]
      $
    \item \emph{Codiagonal:} given $f : A \to (B + A) + A$, we have
      $
      (f^\dagger)^\dagger = (f;[\ms{id}, \iota_r])^\dagger : A \to B
      $
  \end{itemize}
\end{definition}

\begin{figure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \node[] (A) at (0, 2) {$A$};
      \node[box=1/0/2/0] (f) at (0, 0) {\quad f \quad};
      \node[] (B) at (0, -2) {$B$};
      \node[dot] (codiag) at (0, 0.75) {};
      \coordinate[] (C) at (1.2, 0) {};
      \coordinate[] (cup) at (0.75, -1) {};
      \coordinate[] (cap) at (0.75, 1) {};
      \node[] (eq) at (1.8, 0) {=};
      \node[] (Ad) at (3.6, 2) {$A$};
      \node[box=1/0/2/0] (fd1) at (3.4, 1) {\quad f \quad};
      \node[dot] (codiagd1) at (3.8, 0.25) {};
      \node[box=1/0/2/0] (fd2) at (3.8, -0.5) {\quad f \quad};
      \node[dot] (codiagd2) at (3.4, -1.25) {};
      \node[] (Bd) at (3.6, -2) {$B$};
      \coordinate[] (cupd) at (4.5, -1.25) {};
      \coordinate[] (capd) at (4.5, 0.5) {};
      \wires{
        A         = { south = codiag.north },
        f         = { south.1 = B, south.2 = cup.west },
        codiag    = { south = f.north, east = cap.west },
        C         = { south = cup.east, north = cap.east },
        Ad        = { south = fd1.north },
        fd1       = { south.1 = codiagd2.west, south.2 = codiagd1.north },
        codiagd1  = { south = fd2.north },
        fd2       = { south.1 = codiagd2.north, south.2 = cupd.west },
        codiagd2  = { south = Bd.north },
        cupd      = { east = capd.east },
        capd      = { west = codiagd1.east }, 
      }{}
    \end{tikzpicture}
    \caption{Fixpoint}
    \label{fig:fixpoint-string-diagram}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \node[] (A) at (0, 2) {$A$};
      \node[box=1/0/2/0] (f) at (0, 0.5) {\quad f \quad};
      \node[box] (g) at (-0.25, -0.5) {g};
      \node[] (B) at (0, -2) {$B$};
      \node[dot] (codiag) at (0, 1.25) {};
      \coordinate[] (C) at (1.2, 0) {};
      \coordinate[] (cup) at (0.75, -1) {};
      \coordinate[] (cap) at (0.75, 1.5) {};
      \coordinate[] (box0) at (1.5, 1.65) {};
      \coordinate[label={[font=\small, text=gray]below:$(f;g + A)^\dagger$}] 
                    (box1) at (1.5, -1.2) {};
      \coordinate[] (box2) at (-1, -1.2) {};
      \coordinate[] (box3) at (-1, 1.65) {};
      \draw [gray, dashed] (box0) -- (box1);
      \draw [gray, dashed] (box1) -- (box2);
      \draw [gray, dashed] (box2) -- (box3);
      \draw [gray, dashed] (box3) -- (box0);
      \node[] (eq) at (1.8, 0) {=};
      \node[] (A2) at (3.6, 2) {$A$};
      \node[box=1/0/2/0] (f2) at (3.6, 0.5) {\quad f \quad};
      \node[box] (g2) at (3.35, -1) {g};
      \node[] (B2) at (3.6, -2) {$B$};
      \node[dot] (codiag2) at (3.6, 1) {};
      \coordinate[] (cup2) at (4.15, -0.2) {};
      \coordinate[] (cap2) at (4.15, 1.25) {};
      \coordinate[] (box02) at (4.8, 1.5) {};
      \coordinate[label={[font=\small, text=gray]below:$f^\dagger$}] 
                    (box12) at (4.8, -0.4) {};
      \coordinate[] (box22) at (2.6, -0.4) {};
      \coordinate[] (box32) at (2.6, 1.5) {};
      \draw [gray, dashed] (box02) -- (box12);
      \draw [gray, dashed] (box12) -- (box22);
      \draw [gray, dashed] (box22) -- (box32);
      \draw [gray, dashed] (box32) -- (box02);
      \wires{
        A         = { south = codiag.north },
        f         = { south.1 = g.north, south.2 = cup.west },
        g         = { south = B.north },
        codiag    = { south = f.north, east = cap.west },
        C         = { south = cup.east, north = cap.east },
        A2         = { south = codiag2.north },
        f2         = { south.1 = g2.north, south.2 = cup2.west },
        g2         = { south = B2.north },
        codiag2    = { south = f2.north, east = cap2.west },
        cup2       = { east = cap2.east },
        cap2       = { west = codiag2.east },
      }{}
    \end{tikzpicture}
    \caption{Naturality}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \node[] (A) at (0, 2) {$A$};
      \node[box=1/0/3/0] (f) at (0, 0) {\quad f \quad};
      \node[] (B) at (0, -2) {$B$};
      \node[dot] (codiag) at (0, 0.75) {};
      \coordinate[] (C) at (1.2, 0) {};
      \coordinate[] (cup) at (0.75, -1) {};
      \coordinate[] (cap) at (0.75, 1) {};
      \node[dot] (codiag2) at (0.225, -0.75) {};
      \node[] (eq) at (1.8, 0) {=};
      \node[] (Ad) at (3.6, 2) {$A$};
      \node[box=1/0/3/0] (fd) at (3.6, 0) {\quad f \quad};
      \node[] (Bd) at (3.6, -2) {$B$};
      \node[dot] (codiagd) at (3.6, 1.25) {};
      \node[dot] (codiagd2) at (3.6, 0.75) {};
      \coordinate[] (Cd) at (4.8, 0) {};
      \coordinate[] (cupd) at (4.35, -1.25) {};
      \coordinate[] (capd) at (4.35, 1.25) {};
      \coordinate[] (cupd2) at (4.25, -0.75) {};
      \coordinate[] (capd2) at (4.25, 0.75) {};
      \wires{
        A         = { south = codiag.north },
        f         = { south.1 = B, south.2 = codiag2.west, south.3 = codiag2.east },
        codiag2   = { south = cup.west },
        codiag    = { south = f.north, east = cap.west },
        C         = { south = cup.east, north = cap.east },
        Ad        = { south = codiagd.north },
        codiagd   = { south = codiagd2.north, east = capd.west },
        codiagd2  = { south = fd.north, east = capd2.west },
        fd        = { south.1 = Bd, south.2 = cupd.west, south.3 = cupd2.west },
        cupd      = { east = capd.east },
        cupd2     = { east = capd2.east },
      }{}
    \end{tikzpicture}
    \caption{Codiagonal}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \node[] (A) at (0, 2) {$A$};
      \node[box] (g) at (0, 1.25) {g};
      \node[box=1/0/2/0] (f) at (0, 0.25) {\quad f \quad};
      \node[] (B) at (0, -2) {$B$};
      \node[dot] (codiag) at (0, 0.75) {};
      \coordinate[] (C) at (1.2, 0) {};
      \coordinate[] (cup) at (0.75, -1.5) {};
      \coordinate[] (cap) at (0.75, 1) {};
      \node[box] (g2) at (0.5, -0.75) {g};
      \node[] (eq) at (1.8, 0) {=};
      \node[] (Ad) at (3.6, 2) {$A$};
      \node[box] (gd) at (3.6, 0.5) {g};
      \node[box=1/0/2/0] (fd) at (3.6, -0.5) {\quad f \quad};
      \node[] (Bd) at (3.6, -2) {$B$};
      \node[dot] (codiagd) at (3.6, 1) {};
      \coordinate[] (Cd) at (4.8, 0) {};
      \coordinate[] (cupd) at (4.35, -1.5) {};
      \coordinate[] (capd) at (4.35, 1.5) {};
      \wires{
        A         = { south = g.north },
        g         = { south = codiag.north },
        f         = { south.1 = B, south.2 = g2.north },
        g2        = { south = cup.west },
        codiag    = { south = f.north, east = cap.west },
        C         = { south = cup.east, north = cap.east },
        Ad        = { south = codiagd.north },
        codiagd   = { south = gd.north, east = capd.west },
        gd        = { south = fd.north },
        fd        = { south.1 = Bd, south.2 = cupd.west },
        cupd      = { east = capd.east },
      }{}
    \end{tikzpicture}
    \caption{Dinaturality}
  \end{subfigure}
  \caption{Representations of the Conway iteration axioms as string diagrams}
  \label{fig:elgot-ax-string-diagrams}
  \Description{Representations of the Conway iteration axioms as string diagrams}
\end{figure}
In particular, we note that naturality and codiagonal correspond directly to our rules
\brle{let-iter} and \brle{codiag} respectively; we will later see that dinaturality is derivable.

Just like for branching control-flow, we also require an additional condition to ensure that our
iteration operator is compatible with our premonoidal structure. Specifically, we would like to be
able to ``thread'' values through our loop bodies; i.e., the following two programs should be
equivalent for \emph{pure} $c$:
$$
(\liter{a}{x}{b}, c) \approx \liter{(a, c)}{(x, y)}
  {\caseexpr{b}{z}{\linl{(z, y)}}{z}{\linr{(z, y)}}}
$$
This corresponds to requiring our Conway iteration operator to be \emph{strong}, defined as follows:
\begin{definition}[Strong Conway Iteration Operator]
  If $\mc{C}$ is distributive, we say an iteration operator $(\cdot)^\dagger$ is \emph{strong} if
  $$
  \forall f: A \to B + A, (C \otimes f ; \delta^{-1})^\dagger = C \otimes f^\dagger
  $$
\end{definition}
We've now got almost everything we need to model pure and arbitrarily effectful \subiterexp{}
programs, but we still need to be able to perform a more fine-grained classification of effects. To
do so, we introduce a generalization of the notion of an \emph{effectful category}, which in the
literature (e.g. \cite{promonad}) only distinguishes between pure and arbitrarily effectful
morphisms.
\begin{definition}[Effectful category]
  An effectful category $\mc{C}$ over an effect system $\mc{E}$ consists of a symmetric premonoidal
  poset-enriched category $\mc{C}$ equipped with a  monotonic mapping from $\epsilon \in \mc{E}$ to
  wide\footnote{A \emph{wide} subcategory is one which has all of the objects of the original
  category.} (symmetric premonoidal) subcategories $\mc{C}_\epsilon \subseteq \mc{E}$ 
  \footnote{
    Note that $\mc{C}_\epsilon(A, B)$ is \emph{not} necessarily closed under refinement:
    we can have $f \in \mc{C}_\epsilon(A, B)$ and $f \cref f'$ with 
    $f' \notin \mc{C}_\epsilon(A, B)$.
  }
  such that,
  given $\epsilon, \eta \in \mc{E}$, $f \in \mc{C}_\epsilon(A, B)$, and $g \in \mc{C}_\eta(A', B')$,
  $\epsilon \rightmove \eta \implies f \ltimes g \cref f \rtimes g$
  and
  $\epsilon \leftmove \eta \implies f \ltimes g \anticref f \rtimes g$.
  We call morphisms with effect $\bot$ \emph{pure}. We say an effectful category is
  \emph{distributive} if the underlying premonoidal category is, and the injections are pure.
\end{definition}
The goal of allowing morphisms with compatible effects to commute is to allow proving substitution
of effectful programs sound. Unfortunately, we don't have quite enough structure to allow
substitution \emph{into} the body of a loop: while commutativity of $a$ and $b$ is enough to justify
that
$
\letexpr{x}{a}{(b, x)} \approx (b, a)
$
proving that
$
\letexpr{x}{a}{\liter{b}{y}{c}} \approx \liter{b}{y}{\letexpr{x}{a}{c}}
$
for $x \notin \ms{fv}(b)$ requires us to be able to move a morphism \emph{into} the body of a loop.
To be able to do that effectively, we need to introduce the concept of a \emph{\mc{K}-uniform
iteration operator} as follows:
\begin{definition}[Uniformity]
  Given a wide subcategory $\mc{K} \subseteq \mc{C}$ of a category equipped with a Conway iteration
  operator, we say $\mc{C}$ is \emph{$\mc{K}^p$-uniform} for $p \in \{+, -\}$ if, for all $h : A
  \to_{\mc{K}} B$, $f : B \to C + B$, and $g : A \to C + A$, we have that
  $
  h ; f \cref^p g ; C + h \implies h ; f^\dagger \cref^p g^\dagger 
  $.
  We say a category $\mc{K}$ is \emph{$\mc{K}$-uniform} if it is both $\mc{K}^+$- and
  $\mc{K}^-$-uniform, which implies in particular that
  $
  h ; f = g ; C + h \implies h ; f^\dagger = g^\dagger 
  $.
\end{definition}
We note that this definition corresponds precisely to the ability to perform the rewrites shown in
Figure~\ref{fig:unif-cfg} (setting $c = \ms{id}_C$) whenever $s$ is in $\mc{K}$ and $b$ is in
$\mc{C}$. Requiring that substitution is compatible with loops is then equivalent to requiring that
the subcategories of morphisms having commutative effects are uniform with respect to each other. We
call this notion an (effectful) Elgot category:
\begin{definition}[Elgot category]
  We say a distributive effectful category $\mc{C}$ is \emph{Elgot} if it has an iterative effect
  system and is equipped with a strong Conway iteration operator, such that, for all effects
  $\epsilon, \eta$ where $\epsilon \in \mc{E}^\infty$, the wide subcategory $\mc{C}_\epsilon$ is
  closed under iteration, and, iff $\epsilon \rightmove^p \eta$, then $\mc{C}_\epsilon$ is
  $\mc{C}_\eta^p$-uniform. 
  %
  In particular, we note that $\mc{C}$ and hence every $\mc{C}_\epsilon$ is
  $\mc{C}_\bot$-uniform.
\end{definition}
The final piece of the puzzle is that we need a way to \emph{duplicate} variables of relevant type,
as well as \emph{discard} variables of affine type. We'll supply families of morphisms $\Delta: A
\to A \otimes A$, $!: A \to I$ for this purpose. We can then handle relevant and affine
\emph{effects} by requiring that the appropriate morphism families are \emph{natural} w.r.t. the
subcategory corresponding to that effect. Following this idea, we can now define a \subiterexp-model
as follows: \subiterexp{}:
\begin{definition}[\subiterexp-model]
  A model $\mc{M} = (\mc{C}, (\cdot)^\dagger, \dnt{\cdot}, \dmor{}, \tmor{})$ of a
  \subiterexp-signature $\mc{S} = (\mc{X}, \mc{I}, \mc{E})$ is:
  \begin{itemize}
    \item An effectful Elgot category ($\mc{C}$, $(\cdot)^\dagger$) over $(\mc{E},
    \mc{E}^\infty)$
    \item For each base type $X \in \mc{X}$, an object $\dnt{X} \in |\mc{C}|$, equipped with
    \begin{itemize}
      \item For $X$ affine, a \emph{discard morphism} $\tmor{X} : \mc{C}_\bot(\dnt{X}, I)$
      \item For $X$ relevant, a \emph{diagonal morphism} $\dmor{X} : \mc{C}_\bot(\dnt{X}, \dnt{X}
      \otimes \dnt{X})$
    \end{itemize}
    \item For each function $f : \ms{Inst}(\mc{S})_\epsilon(A, B)$, a morphism $\dnt{f} :
    \mc{C}_\epsilon(\dnt{A}, \dnt{B})$
  \end{itemize}
  such that, for all $A, B \in |\mc{S}|$, $f : \mc{C}_\epsilon(\dnt{A}, \dnt{B})$ we have
  \begin{itemize}
    \item If $A$ relevant, 
      $\dmor{A} ; \dmor{A} \otimes \dnt{A} ; \alpha = \dmor{A} ; \dnt{A} \otimes \dmor{A}$
      and
      $\dmor{A} ; \sigma_{A, A} = \dmor{A}$
    \item If $\zeroq \leq \alquant^p(\epsilon)$ and $A, B$ affine, $f ; \tmor{B} \cref^p \tmor{A}$
    \item If $\zeroq \leq \alquant^p(\epsilon)$ and $A$ relevant, $B$ affine, 
      $\dmor{A} ; (f ; \tmor{B}) \otimes \dnt{A} \cref^p \rho^{-1}$
    \item If $\cpyq \leq \alquant^p(\epsilon)$ and $A, B$ relevant, 
    $f ; \dmor{B} \cref^p \dmor{A} ; f \ltimes f = \dmor{A} ; f \rtimes f$
  \end{itemize}
  where
  \begin{itemize}
    \item $\dnt{\mb{1}} = I$, $\dnt{A \otimes B} = \dnt{A} \otimes \dnt{B}$, 
          $\tmor{\mb{1}} = \ms{id}_I$, and $\dmor{\mb{1}} = \lambda^{-1} = \rho^{-1}$
    \item For $A, B$ affine, $\tmor{A \otimes B} = \tmor{A} \otimes \tmor{B} ; \lambda$, and for $A,
    B$ relevant, $\dmor{A \otimes B} = \dmor{A} \otimes \dmor{B} ; \sigma^{\ms{mid}}
    $
    where we define
    $
    \sigma^{\ms{mid}}_{A, B, C, D} = 
      \alpha_{A \otimes (B \otimes C) \otimes D}
      ; A \otimes \sigma \otimes D
      ; \alpha
    $
    having type $\mc{C}_\bot(
        (A \otimes B) \otimes (C \otimes D), 
        (A \otimes C) \otimes (B \otimes D)
      )
    $
    \item $\dnt{\mb{0}} = \mb{0}$, $\dnt{A + B} = \dnt{A} + \dnt{B}$, 
          $\tmor{\mb{0}} = 0_{I}$, and $\dmor{\mb{0}} = 0_{0 + 0}$
    \item For $A, B$ affine, $\tmor{A + B} = [\tmor{A}, \tmor{B}]$, and for $A, B$ relevant,
    $\dmor{A + B} = [\dmor{A} ; \iota_l \otimes \iota_l, \dmor{B} ; \iota_r \otimes \iota_r]
    $
  \end{itemize}
\end{definition}
We define the \emph{effective type} of an annotated type $A^q$, $\etoty{A^q}$ to be $\mb{1}$ if
$q = 0$, and $A$ otherwise. We can then proceed to define the effective type of an annotated context
$\Gamma^{\mb{q}}$ to be the tensor product of its variables, i.e., $\etoty{\cdot} = \mb{1}$ and
$\etoty{\Gamma, x : A^q} = \etoty{\Gamma} \otimes \etoty{A^q}$. We will abuse notation slightly and
extend $\dnt{\cdot}$ to quantity annotated types $A^q$ by taking $\dnt{A^q} = \dnt{\etoty{A^q}}$;
likewise, we define $\tmor{A^q} = \tmor{\etoty{A^q}}$ and $\dmor{A^q} = \dmor{\etoty{A^q}}$,
where the \emph{effective type} of an annotated type $A^q$, $\etoty{A^q}$, is $\mb{1}$ if $q = 0$,
and $A$ otherwise. Likewise, we proceed to define the semantics of an annotated context
$\dnt{\Gamma^{\mb{q}}} : |\mc{C}|$ as $\dnt{\etoty{\Gamma^{\mb{q}}}}$.

We can now define the semantics of our structural judgements, weakenings and context splitting, in
Figure~\ref{fig:struct-sem}. In particular, weakenings simply discard unused variables (which are
guaranteed to be of affine type), while context splitting duplicates variables used in both the left
and right component contexts (which are guaranteed to be of relevant type).

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \boxed{\dnt{\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}} 
      : \mc{C}_\bot(\dnt{\Gamma^{\mb{q}}}, \dnt{\Delta^{\mb{q}'}})} \\
    \dnt{\cwk{\cdot}{\cdot}} = \ms{id}_I \qquad
    \dnt{\cwk{\Gamma^{\mb{q}}, x : A^q_\epsilon}{\Delta^{\mb{q}'}}}
      = \dnt{\Gamma^{\mb{q}}} \otimes \tmor{A^q}
      ; \lambda
      ; \dnt{\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}} \\
    \dnt{\cwk{\Gamma^{\mb{q}}, x : A^q_\epsilon}
              {\Delta^{\mb{q}'}, x : A^{q'}_{\epsilon'}}}
      = \dnt{\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}} \otimes \begin{cases}
        \ms{id}_{\dnt{A}} & \text{if } q, q' \neq 0 \\
        \tmor{A^q} & \text{otherwise} \\
      \end{cases}
  \end{gather*}

  \begin{gather*}
    \boxed{\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      : \mc{C}_\bot(\dnt{\Gamma^{\mb{q}}}, 
        \dnt{\Gamma^{\mb{q}_l}_{\mb{e}_l}} \otimes \dnt{\Gamma^{\mb{q}_r}_{\mb{e}_r}})} 
    \\
    \dnt{\qsp{\cdot}{\cdot}{\cdot}{\cdot}} = \rho^{-1}
    \\
    \dnt{\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, q_l)}{(\mb{q}_r, q_r)}}
    = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} \otimes
    \left(\begin{cases}
      \lambda^{-1} & \text{if } q_l = 0 \text{ else} \\
      \rho^{-1} & \text{if } q_r = 0 \text{ else} \\
      \dmor{A} & \text{otherwise}
    \end{cases}\right) 
    ; \sigma^{\ms{mid}}
  \end{gather*}
  \end{adjustbox}
  \caption{Denotational semantics for structural \subiterexp{} judgements}
  \Description{}
  \label{fig:struct-sem}
\end{figure}

\subsection{Semantics of \subiterexp{} Expressions}

We now give the semantics of each of our term formers in Figure~\ref{fig:expr-densem} by induction
on derivations; we write $\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}$ to denote the appropriate
derivation/sub-derivation. Each of them corresponds quite closely to the the underlying categorical
structure. In particular,
\begin{itemize}
  \item We intepret a variable $x$ of type $A$ as the weakening $\cwk{\Gamma^{\mb{q}}}{x : A^1}$;
  this discards all other variables from the input environment.
  \item Let-bindings and pairs are interpreted as sequencing, with, in the former case, the output
  of the first term being passed as an input to the second. In both cases, we use context-splitting
  to apportion the variables between the two terms.
  \item Units are interpreted as the weakening $\cwk{\Gamma^{\mb{q}}}{\cdot}$, i.e., discarding all
  variables.
  \item Case statements are interpreted by passing the result of the discriminator into the
  coproduct of the branches, after context-splitting to apportion the variables between the
  discriminator and branches. We use the distributor to thread the variables into both branches of
  the coproduct, as discussed.
  \item Injections and $\ms{abort}$ are interpreted trivially as the injections and the zero
  morphism respectively, post-composed with their argument.
  \item To interpret iteration, after splitting the context, we interpret the initial value, and
  then feed that into the fixpoint of the body (computed using the Conway iteration operator) along
  with the remainder of the context.
\end{itemize}
We use the $\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}$ notation, rather than specifying a
particular derivation, because \emph{coherence} holds:
\begin{lemma}[Coherence]
  Given derivations $D$ for $\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}$ and $D'$ for
  $\hasty{\Gamma^{\mb{q}}}{\epsilon'}{a}{A}$, we have $\dnt{D} = \dnt{D'}$
\end{lemma}
Observe that the coherence theorem allows us to omit the effect $\epsilon$, because the effect is a
property of the semantics: the same term with two different effect typings will have the same
denotation.

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \boxed{\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} 
      : \mc{C}_\epsilon(\dnt{\Gamma^{\mb{q}}}, \dnt{A})} \\
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{x}{A}} 
      = \dnt{\cwk{\Gamma^{\mb{q}}}{x : A^\oneq_\epsilon}}
    \qquad
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{f\;a}{B}} 
      = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} ; \dnt{f} \\
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{x}{a}{b}}{B}} 
      = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      ; \dnt{\Gamma^{\mb{q}_l}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
    \\
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{(a, b)}{A \otimes B}}
      = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      ; \dnt{\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
      \ltimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{b}{B}}
    \qquad
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{()}{\mb{1}}}
      = \dnt{\cwk{\Gamma^{\mb{q}}}{\cdot}}
  \end{gather*}
  \begin{align*}
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{(x, y)}{a}{c}}{C}}
    = & \; \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      ; \dnt{\Gamma^{\mb{q}_l}}
      \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
    %\\ & 
    %; \alpha_{\Gamma^{\mb{q}_r} \otimes A \otimes B}
    ; \alpha
    ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
  \end{align*}
  \begin{align*}
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}}
    =& \; 
    \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    ; \dnt{\Gamma^{\mb{q}_l}} 
    \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{e}{A + B}}
    ; \delta^{-1} \\ & 
    ; [
      \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}},
      \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
    ]
  \end{align*}
  \begin{gather*}
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\linl{a}}{A + B}}
    = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} ; \iota_l \qquad
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\linr{b}}{A + B}}
    = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{B}} ; \iota_r \\
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\labort{a}}{A}}
    = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{\mb{0}}} ; 0_A
  \end{gather*}
  \begin{align*}
    \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{\liter{a}{x}{b}}{B}}
    &= 
    \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    ; \dnt{\Gamma^{\mb{q}_l}}
      \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} \\ &
    ; (
      \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes \dnt{A} 
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_l}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      ; \delta^{-1}
    )^\dagger \\ &
    ; \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes \dnt{B}
    ; \rho
  \end{align*}
  \end{adjustbox}
  \caption{Denotational semantics for \subiterexp{} expressions}
  \Description{}
  \label{fig:expr-densem}
\end{figure}

\paragraph{Weakening}

As a sanity check on our semantics, we can verify that it satisfies \emph{weakening} by a
straightforward induction, stated as follows:
\begin{lemma}[Weakening]
  Given $\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}$ and
  $\hasty{\Delta^{\mb{q}'}}{\epsilon}{a}{A}$, we have that
  $$
  \dnt{\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}} ; \dnt{\hasty{\Delta^{\mb{q}'}}{\epsilon}{a}{A}}
  = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
  $$
\end{lemma}

\paragraph{Substitution}

We proceed to give a semantics for substitution in Figure~\ref{fig:subst-den}. We split up the input
context into subcontexts for each \emph{used} variable, which are then simply interpreted using
their denotation. Unused variables are simply represented via the left unitor. We can then state
soundness of substitution in the following manner, which is standard except that we prove an
\emph{inequality} whose direction is determined by the commutativity of the effects of the term and
of the substitution. 

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \boxed{\dnt{\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma}{\Delta^{\mb{q}'}}}
      : \mc{C}_\epsilon(\dnt{\Gamma^{\mb{q}}}, \dnt{\Delta^{\mb{q}'}})} \\
    \dnt{\issubst{\cdot}{\epsilon}{\cdot}{\cdot}} = \ms{id}_I
    \\
    \dnt{\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma, x \mapsto a}{\Delta^{\mb{q}'}, x : A^q}}
    = \begin{cases}
      \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\issubst{\Gamma^{\mb{q}_l}_{\mb{e}_l}}{\epsilon}{\sigma}{\Delta^{\mb{q}'}}}
      \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      \text{ if } q \neq 0 \\
      \dnt{\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma}{\Delta^{\mb{q}'}}}
      ; \lambda^{-1} \text{ otherwise}
    \end{cases}
  \end{gather*}
  \end{adjustbox}
  \caption{Semantics of \subiterexp{} substitutions}
  \Description{}
  \label{fig:subst-den}
\end{figure}

\begin{theorem}[Soundness of Substitution]
  Given $\issubst{\Gamma^{\mb{q}}}{\eta}{\sigma}{\Delta^{\mb{q'}}}$ and
  $\hasty{\Delta^{\mb{q}'}}{\epsilon}{a}{A}$, we have
  \begin{align*}
  \eta \rightmove \epsilon \implies
  \dnt{\issubst{\Gamma^{\mb{q}}}{\eta}{\sigma}{\Delta^{\mb{q'}}}} 
    ; \dnt{\hasty{\Delta^{\mb{q}'}}{\epsilon}{a}{A}}
  \cref \dnt{\hasty{\Gamma^{\mb{q}}}{}{[\sigma]a}{A}} \\
  \eta \leftmove \epsilon \implies
  \dnt{\issubst{\Gamma^{\mb{q}}}{\eta}{\sigma}{\Delta^{\mb{q'}}}} 
    ; \dnt{\hasty{\Delta^{\mb{q}'}}{\epsilon}{a}{A}}
  \geq \dnt{\hasty{\Gamma^{\mb{q}}}{}{[\sigma]a}{A}}
  \end{align*}
\end{theorem}

\paragraph{Soundness}

Now that we have given our terms a denotational semantics, we would like to show that our refinement
theory is \emph{sound} w.r.t. this semantics. In particular, as we allow a refinement theory to be
parametrized by set of base refinements $\mc{R}$, we need to be able to express whether a model
$\mc{M}$ satisfies these refinements. To do so, we introduce the notion of a model \emph{validating}
a typed refinement family as follows:
\begin{definition}
  We say a model $\mc{M}$ \emph{validates} a typed refinement family $\mc{R}$, written $\mc{M}
  \models \mc{R}$, if, for all
  $
  (\tmle{\Gamma^{\mb{q}}}{}{a}{b}{A}) \in \mc{R}
  $
  we have that
  $
  \dnt{\hasty{\Gamma}{\epsilon}{a}{A}} \tref \dnt{\hasty{\Gamma}{\epsilon}{b}{A}}
  $
\end{definition}
We note that, for every model $\mc{M}$, $\mc{M} \models \varnothing$. We can then phrase soundness
as follows: if $\mc{M}$ models $\mc{R}$, for every refinement in the \emph{theory} generated by
$\mc{R}$, $\ms{Th}(\mc{R})$, $\mc{M}$ validates that refinement. Or, more formally,
\begin{theorem}[Soundness]
  We have that $\mc{M} \models \mc{R} \iff \mc{M} \models \ms{Th}(\mc{R})$. That is, given $\mc{M}
  \models \mc{R}$ and $\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}$, we have
  $\dnt{\hasty{\Gamma}{\epsilon}{a}{A}}_{\mc{M}} \cref
  \dnt{\hasty{\Gamma}{\epsilon}{b}{A}}_{\mc{M}}$.
\end{theorem}
In particular, we hence have that, for every model $\mc{M}$, $\mc{M} \models \ms{Th}(\varnothing)$,
validating our equational theory.

\paragraph{Syntactic Models and Completeness}

We now wish to show that our equational theory is \emph{complete} with respect to our denotational
semantics; that is, if some refinement holds for every $\mc{M} \models \mc{R}$, then this refinement
is in fact contained in $\ms{Th}(\mc{R})$. We will do this by constructing an \emph{initial} model
$\ms{Tm}(\mc{R})$, the \emph{syntactic model}, such that the following theorem holds:
\begin{theorem}[Completeness]
  If $\dnt{\hasty{\Gamma}{}{a}{A}}_{\ms{Tm}(\mc{R})} \tref
  \dnt{\hasty{\Gamma}{}{b}{A}}_{\ms{Tm}(\mc{R})}$, then
  $
  \tmle{\Gamma}{\mc{R}}{a}{b}{A}
  $
\end{theorem}
It then follows from soundness and the existence of $\ms{Tm}(\mc{R})$ that
$\tmle{\Gamma}{\mc{R}}{a}{b}{A}$ \emph{if and only if} for all models $\mc{M} \models \mc{R}$,
$\dnt{\hasty{\Gamma}{}{a}{A}}_{\mc{M}} \tref \dnt{\hasty{\Gamma}{}{b}{A}}_{\mc{M}}$, as desired.

We now proceed to give a sketch of the construction of $\ms{Tm}(\mc{R})$ and the proof of 
completeness; full details are given in Appendix~\ref{apx:completeness}. As is standard, our 
syntactic model $\ms{Tm}(\mc{R})$ will have types as objects. 
% TODO: rewrite to be purely functional?
To construct morphisms, we start with terms with a single free variable. We stratify these terms by
type and effect as follows:
$$
\ms{Term}(\mc{R})_\epsilon(A, B) := \{(x, a) \mid \hasty{x : A^\top}{\epsilon}{a}{B}\}
$$
We will quotient each $\ms{Term}_\epsilon(\mc{R})$ by term equivalence $\approx_{\mc{R}}$, as well
as by renaming the free variable $x$, to define $\ms{Tm}(\mc{R})_\epsilon$; we will somewhat
suggestively write quotiented pairs $(x, a)$ as lambda-expressions $\lambda x. a$, with $(\lambda x
. a)(y) = [y/x]a$ yielding a term up to equivalence. The identity morphism is simply given as
$\ms{id}_A = (\lambda x. x)$, while composition is given not by substitution (since terms may be
impure!) but rather by let-bindings as follows:
$$
(\lambda x . a) ; (\lambda y . b) := (\lambda x . \letexpr{y}{a}{b})
$$
We can equip $\ms{Tm}(\mc{R})$ with the structure of a poset-enriched category by using the
refinement relation as a partial order; it is trivial to see that this is well-defined. The rest of
the structure of a \subiterexp{}-model is given in Appendix~\ref{apx:syn-model}. To prove
completeness, it then suffices to show that $\dnt{\cdot}_{\ms{Tm}(\mc{R})}$ \emph{reflects}
refinement. The details of how to do so are given in Appendix~\ref{apx:packing}.

% To do so, we note that
% $\dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{B}}_{\ms{Tm}(\mc{R})}$ is, up to equivalence, a term of
% the form $\hasty{x : [\Gamma^{\mb{q}}]}{\epsilon}{\bar{a}}{B}$. Hence, our strategy for proving
% completeness is simply to relate the terms $a$ and $\bar{a}$ such that $\bar{a} \tref \bar{b}
% \implies a \tref b$. We begin by relating the contexts $\Gamma^{\mb{q}}$ and $x : [\Gamma^{\mb{q}}]$
% via the \emph{packing lemma}
% \begin{lemma}[name=Packing, restate=packinglemma]
%   We can define monotone functions $\ms{pack}$, $\ms{unpack}_{\Gamma, x}$ on derivations
%   $$
%   \hasty{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\epsilon}{
%         \ms{pack}(\hasty{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\epsilon}{a}{A})
%   }{A} \qquad
%   \hasty{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\epsilon}{
%         \ms{unpack}_{\Gamma, x}(\hasty{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\epsilon}{b}{A})
%   }{A}
%   $$
%   which are
%   \begin{itemize}
%     \item Semantics-preserving: 
%       \begin{align*}
%       \dnt{\hasty{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\epsilon}{
%         \ms{pack}(\hasty{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\epsilon}{a}{A})
%         }{A}}
%         &= \alpha ; \dnt{\hasty{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\epsilon}{a}{A}}
%       \\
%       \dnt{\hasty{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\epsilon}{
%         \ms{unpack}_{\Gamma, x}(\hasty{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\epsilon}{b}{A})\
%         }{A}}
%         &= \alpha ; \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{A}}
%       \end{align*} 
%     \item Mutually inverse (up to $\approx$):
%         $
%         \tmeq{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\mc{R}}
%         {\ms{unpack}_{\Gamma, x}(\ms{pack}(
%           \hasty{\Gamma^{\mb{q}}, x : \etoty{\Delta^{\mb{q}'}}}{\epsilon}{a}{A}
%         ))}
%         {a}
%         {A}
%         $
%         and
%         $
%         \tmeq{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\mc{R}}
%         {\ms{pack}(\ms{unpack}_{\Gamma, x}(
%           \hasty{\Gamma^{\mb{q}, \Delta^{\mb{q}'}}}{\epsilon}{b}{A}))}
%         {b}
%         {A}
%         $
%   \end{itemize}
%   \label{lem:packing}
% \end{lemma}
% We write $\ms{unpack}_x$ as shorthand for $\ms{unpack}_{\cdot, x}$. We may now state the
% \emph{unpacking lemma} as follows: 
% \begin{lemma}[name=Unpacking, restate=unpackinglemma]
%   Given $\hasty{\Gamma^{\mb{q}}}{}{a}{A}$, 
%   for all $(x, \bar{a}) \in \dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}_{\ms{Tm}(\mc{R})}$
%   we have that
%   $
%     \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
%       {\ms{unpack}_{\cdot, \Gamma}(\hasty{x : [\Gamma^{\mb{q}}])}{}{\bar{a}}{A}}
%       {a}{A}
%   $
%   \label{lem:unpacking}
% \end{lemma}
% Completeness follows directly, since, in this case, by monotonicity, for all $(x, \bar{a}) \tref (y,
% \bar{b})$, we have that
% $
% \tmle{\Gamma^{\mb{q}}}{\mc{R}}
%   {\ms{unpack}_{\cdot, x}(\hasty{x : [\Gamma^{\mb{q}}])}{}{\bar{a}}{A}}
%   {\ms{unpack}_{\cdot, y}(\hasty{y : [\Gamma^{\mb{q}}])}{}{\bar{b}}{A}}{A}
% $
% and hence that 
% $
% a \tref b
% $
% as desired. Details of the definition of $\ms{pack}$ and $\ms{unpack}$ and the proofs of
% Lemmas~\ref{lem:packing} and \ref{lem:unpacking} are given in Appendix~\ref{apx:packing}.

\section{SSA Typing and Semantics}

\subsection{Typing Rules}

We now turn back to the promises at the end of Section~\ref{sec:ssa-intro} and attempt to give 
typing rules and denotational semantics for \isotopessa{}. Recall that the primitive syntactic 
element of an \isotopessa{} program is a \emph{region} $r$, which can be viewed as a program 
fragment with a single entry point and multiple exit points. Consequently, our primitive typing 
judgement will be of the form
$
%\boxed{
  \haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}
%}
$,
which we will read as stating  that ``\emph{if} the variables in $\Gamma$ are live on entry, with
quantity $\mb{q}$, \emph{then} executing the region $r$ jumps to one of the labels in $\ms{L}$, with
\emph{leftover} quantities $\mb{Q}$." Here, $\ms{L}$ is a list of labels $\ell_i$, annotated with a
single parameter type (multiple parameters are implemented as a single tuple parameter), and
$\mb{Q}$ is a list of quantity vectors $\mb{q}_i$ which we call the \emph{quantity matrix}.

We may define a weakening judgement on annotated label contexts using the rules in
Figure~\ref{fig:label-wk}; the judgement is with respect to a particular context $\Gamma$ used to
interpret the quantity vectors in $\mb{Q}$. In particular, weakening allows us to  insert arbitrary
labels using \brle{skip}, as well as weaken the quantities associated with each using \brle{cons}.
As we can see, a label context is interpreted w.r.t. a quantity matrix $\mb{Q}$, which also depends
on the set of live variables $\Gamma$. To extend the set of live variables (e.g. to type a
let-binding), we need to zero-pad the quantity matrix to obtain its \emph{lifting}
$\zeroqv{\mb{Q}}$. In particular, we define this inductively with 
$
  \zeroqv{\cdot} = \cdot
$ and
$
  \zeroqv{(\mb{Q}; \mb{q})} = \zeroqv{\mb{Q}} ; (\mb{q}, 0)
$.
%
% It is easy to prove that label weakening is compatible with lifting, i.e. that the following rule
% is derivable:
%
% \begin{equation*}
%   \prftree[r]{\rle{lift}}
%     {\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}'}}}
%     {\lwk{\Gamma, x : A}{\ms{L}^{\zeroqv{\mb{Q}}}}{\ms{K}^{\zeroqv{\mb{Q}'}}}}
% \end{equation*}
With this, we give typing rules for \isotopessa{}, which we do in Figure~\ref{fig:ssa-typing}.
% We now go over the typing rules for \isotopessa{}, given in Figure~\ref{fig:ssa-typing}. 
% We note that instructions $o$ are simply treated as restricted expressions in \subiterexp{}, and
% typed accordingly.
\begin{itemize}
  \item We begin with the typing rule for branches, \brle{br}. This states that, if $o$ is a pure
  expression of type $A$, and $\ell(A)^{\mb{q}_l}$ weakens to the label context 
  $\ms{L}^{\mb{Q}}$, where $\mb{q}_l$ is the quantities left over after typing $o$, then
  $\brb{\ell}{o}$ is a valid branch into $\ms{L}^{\mb{Q}}$
  \item Let-bindings are typed using \brle{let$_1$} and \brle{let$_2$}, which are exactly the same
  as the corresponding rule for expressions, except that we target a label-context, which needs to
  be lifted (i.e. $\mb{Q}$ replaced with $\zeroqv{\mb{Q}}$) in the premise to deal with the 
  additional variable in the input context.
  \item Case terminators are typed using \brle{case}, which is again the same as the rule for 
  expressions modulo lifting, except for the fact that the discriminator $o$ is required to be
  pure.
  \item \ms{where}-blocks are typed using \brle{where$_\ms{nonrec}$} and \brle{where$_\ms{rec}$},
  which we distinguish since the effect of a \ms{where_{rec}} subtree must be iterative. In
  particular, a  \ms{where_{rec}} subtree is composed of an entry subtree $\kappa$, which we take to
  target the compound label-context $\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}'}$, and, for each
  \emph{sublabel} in $\ell_i(A_i)^{\mb{q_i}}$ in $\ms{R}^{\mb{Q}'}$, an associated \emph{subregion}
  $t_i$ which, with variables $\Gamma^{\mb{q}_i}$ plus an argument $x_i : A_i$ live on entry,
  targets the exit labels $\ms{L}^{\mb{Q}}$ or makes a recursive call to $\ms{R}^{\mb{Q}'}$.
  %
  % This is non-recursive since the $\ms{R}^{\mb{Q}'}$ cannot call themselves, but we can 
  % encode any DAG since the inner subtree $\kappa$ can contain other regions.
  %
  \brle{where$_\ms{nonrec}$} simply removes the requirement that $\epsilon$ be iterative, in
  exchange requiring the $t_i$ to only jump to exit labels in $\ms{L}^{\mb{Q}}$.
\end{itemize}

\begin{figure}
  \hspace{4em}
  \begin{subfigure}[t]{.25\textwidth}
  \begin{grammar}
    <\(\ms{L}\)> ::= \(\cdot\) \;|\; \(\ms{L}, \lhyp{\ell}{A}\)
  \end{grammar}
  \end{subfigure}%
  \begin{subfigure}[t]{.25\textwidth}
  \begin{grammar}
    <\(\mb{Q}\)> ::= \(\cdot\) \;|\; \(\mb{Q}; \mb{q}\)
  \end{grammar}
  \end{subfigure}%
  \caption{Grammar for label contexts}
  \Description{}
  \label{fig:label-grammar}
\end{figure}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{nil}}{\lwk{\Gamma}{\cdot}{\cdot}} \qquad 
    \prftree[r]{\rle{cons}}
      {\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}}}}
      {\cwk{\Gamma^{\mb{q}'}}{\Gamma^{\mb{q}}}}
      {\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \lhyp{\ell}{A}^{\mb{q}}}
      {\ms{K}^{\mb{Q}}, \lhyp{\ell}{A}^{\mb{q}'}}} \qquad
    \prftree[r]{\rle{skip}}
      {\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}}}}
      {|\Gamma| = |\mb{q}|}
      {\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}}, \lhyp{\ell}{A}^{\mb{q}}}}
  \end{gather*}
  \end{adjustbox}
  \caption{Rules for weakening label contexts}
  \Description{}
  \label{fig:label-wk}
\end{figure}


\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{br}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\bot}{o}{A}}
      {\lwk{\Gamma}{\lhyp{\ell}{A}^{\mb{q}_l}}{\ms{L}^{\mb{Q}}}}
      {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell}{o}}{\ms{L}^{\mb{Q}}}}
    \\
    \prftree[r]{\rle{let$_1$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A}}
      {\haslb{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{t}{\ms{L}^{\zeroqv{\mb{Q}}}}}
      {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{x}{o}{t}}{\ms{L}^{\mb{Q}}}}
    \\
    \prftree[r]{\rle{let$_2$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A \otimes B}}
      {\haslb{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{t}
        {\ms{L}^{\zeroqv{(\zeroqv{\mb{Q}})}}}}
      {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{(x, y)}{o}{t}}{\ms{L}^{\mb{Q}}}}
    \\
    \prftree[r]{\rle{case}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\bot}{o}{A + B}}
      {\haslb{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{\tau_l}
        {\ms{L}^{\zeroqv{\mb{Q}}}}}
      {\haslb{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{\tau_r}
        {\ms{L}^{\zeroqv{\mb{Q}}}}}
      {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\casestmt{o}{x}{\tau_l}{y}{\tau_r}}
                                                {\ms{L}^{\mb{Q}}}}
    \\
    \prftree[r]{\rle{where$_{\ms{nonrec}}$}}
      {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}
        {\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}'}}}
      {\forall \lhyp{\ell_i}{A_i}^{\mb{q}_i} \in \ms{R}^{\mb{Q}'} .
        \haslb{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}{\ms{L}^{\zeroqv{\mb{Q}}}}
      }
      {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\awhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
        {\ms{L}^{\mb{Q}}}}
    \\
    \prftree[r]{\rle{where$_{\ms{rec}}$}}
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}
      {\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}'}}}
    {\einf{\epsilon}}
    {\forall \lhyp{\ell_i}{A_i}^{\mb{q}_i} \in \ms{R}^{\mb{Q}'} .
      \haslb{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}{
        \ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}'}}}
    }
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\cwhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}}
  \end{gather*}
  \end{adjustbox}
  \caption{Typing rules for \isotopessa{}}
  \Description{}
  \label{fig:ssa-typing}
\end{figure}

\subsection{Denotational Semantics}

We give a denotational semantics for \isotopessa{}, targeting an arbitrary
\subiterexp{} model. We interpret a derivation
$\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}$ as a morphism from the input state, the set
of live variables $\dnt{\Gamma^{\mb{q}}}$, to the output state, which consists of a label $\ell_i$
in $\ms{L}$, its argument $A_i$, and leftover variables $\mb{q}_i$ in $\mb{Q}$. 

To represent this as a type, we can define the (context-dependent) \emph{effective type}
$\ltoty{\Gamma}{\ms{L}}$ of an annotated label context with $\ltoty{\Gamma}{\cdot} = \mb{0}$ and
$\ltoty{\Gamma}{\ms{L}^{\mb{Q}}, \ell(A)^{\mb{q}}} = \ltoty{\Gamma}{\ms{L}^{\mb{Q}}} +
\etoty{\Gamma^{\mb{q}}} \otimes A$.    
Here, the label is encoded as the branch of the coproduct we end up in, with each branch carrying
the argument and any leftover variables as data. We may now give a denotational semantics for label 
contexts and label weakenings in Figure~\ref{fig:lwk-densem}. 
It is easy to verify that we can reassociate 
$
\alpha^+ : \mc{C}_\bot(
  \dnt{\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}'}}(\Gamma),
  \dnt{\ms{L}^{\mb{Q}}}(\Gamma) + \dnt{\ms{R}^{\mb{Q}'}}(\Gamma)
)
$.
We also note that we can apply the 
associator ``pointwise'' to reassociate
$\alpha^\downarrow: \mc{C}_\bot(
  \dnt{\ltoty{\Gamma, x : A}{\ms{L}^{\zeroqv{\mb{Q}}}}}, 
  \dnt{\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}}
)$. 
%
The semantics for regions is in Figure~\ref{fig:ssa-densem}:
% ; just like for the typing judgements, the semantics of operations is given by the semantics of
% the corresponding \subiterexp{} expressions.
\begin{itemize}
  \item Branches are interpreted by splitting the context, evaluating the argument,
  and then passing the remainder of the context and the result into the appropriate
  label weakening.
  \item The denotation of let- and case-statements is exactly the same as for expressions,
  except that we need to re-associate the output object from 
  $\dnt{\ms{L}^{\zeroqv{Q}}}(\Gamma, -)$ to $\dnt{\ms{L}^{\mb{Q}}}$.
  \item Non-recursive \ms{where}-subtrees are interpreted by the denotation of their entry subtree,
  reassociated to the sum of the exit labels $\ms{L}^{\mb{Q}}$ and sublabels $\ms{R}^{\mb{Q}'}$. The
  exit labels are passed through as-is, and the sublabels $\ell_i$ are piped to the appropriate
  subregion $t_i$.
  \item Recursive \ms{where}-subtree is as above, except that we take the \emph{fixpoint} of the sum
  of the denotations of the subregions viewed as morphisms from $\dnt{\ms{R}^{\mb{Q}}}(\Gamma)$
  to $\dnt{\ms{L}^{\mb{Q}}}(\Gamma) + \dnt{\ms{R}^{\mb{Q}}}(\Gamma)$, feeding recursive
  calls back into the  where-block's body.
\end{itemize}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \boxed{\dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}'}}} 
      : \mc{C}_\bot(\dnt{\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}}, 
                    \dnt{\ltoty{\Gamma}{\ms{K}^{\mb{Q}'}}})} \\
    \dnt{\lwk{\Gamma}{\cdot}{\cdot}} = \ms{id}_{\mb{0}} \qquad
    \dnt
      {\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \lhyp{\ell}{A}^{\mb{q}}}
      {\ms{K}^{\mb{Q}'}, \lhyp{\ell}{A}^{\mb{q}'}}}
    = \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}'}}} 
      + \dnt{\cwk{\Gamma^{\mb{q}}}{\Gamma^{\mb{q}'}}} \otimes \dnt{A} \\
    \dnt
      {\lwk{\Gamma}{\ms{L}^{\mb{Q}}}
      {\ms{K}^{\mb{Q}'}, \lhyp{\ell}{A}^{\mb{q}}}}
    = \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{K}^{\mb{Q}'}}} ; \iota_l
  \end{gather*}
  \end{adjustbox}
  \caption{Denotational semantics for label contexts and label weakenings}
  \Description{}
  \label{fig:lwk-densem}
\end{figure}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \boxed{\dnt{\haslb{\Gamma}{\epsilon}{t}{\ms{L}^{\mb{Q}}}}
    : \mc{C}_\epsilon(\dnt{\Gamma^{\mb{q}}}, \ltoty{\Gamma}{\dnt{\ms{L}^{\mb{Q}}}})} \\
    \dnt
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell}{a}}{\ms{L}^{\mb{Q}}}}
    = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    ; - \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\bot}{a}{A}}
    ; \iota_r
    ; \dnt{\lwk{\Gamma}{\lhyp{\ell}{A}^{\mb{q}_l}}{\ms{L}^{\mb{Q}}}}
    \\
    \dnt
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{x}{o}{t}}{\ms{L}^{\mb{Q}}}}
    =
    \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    ; - \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A}}
    ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{t}{\ms{L}^{\zeroqv{\mb{Q}}}}}
    ; \alpha^\downarrow \\
    \dnt
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{(x, y)}{o}{t}}{\ms{L}^{\mb{Q}}}}
    =
    \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    ; - \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A \otimes B}}
    ; \alpha
    \\
    \qquad 
    ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{t}
      {\ms{L}^{\zeroqv{(\zeroqv{\mb{Q}})}}}}
    ; \alpha^\downarrow ; \alpha^\downarrow
    \\
    \dnt
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\casestmt{o}{x}{\tau_l}{y}{\tau_r}}
      {\ms{L}^{\mb{Q}}}}
    = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    ; - \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\bot}{o}{A + B}}
    ; \delta^{-1}
    \\
    \qquad
    ; [
      \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{\tau_l}{\ms{L}^{\zeroqv{\mb{Q}}}}}
        ; \alpha^\downarrow,
      \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{\tau_r}{\ms{L}^{\zeroqv{\mb{Q}}}}}
        ; \alpha^\downarrow
    ]
    \\
    \dnt
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\awhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}}
    =
    \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}
      {\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}'}}} ; \alpha^+
    \\ 
    \qquad ; [
      \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}}},
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}}} ; \alpha^\downarrow,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}
    ]
    \\
    \dnt
    {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\cwhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}}
    = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}
      {\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}'}}} ; \alpha^+
    \\
    \qquad ; [
      \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}}},
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}'}}}} ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
    ]
  \end{gather*}
  \end{adjustbox}
  \caption{Denotational semantics for \isotopessa{}}
  \Description{}
  \label{fig:ssa-densem}
\end{figure}

\subsection{Interconversion with \subiterexp{}}
\label{ssec:interconversion}

% Given a rewrite system $\mc{R}$, we say an \isotopessa{} region 
% $\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}$ is refined by $r'$, written
% $\lbref{\Gamma^{\mb{q}}}{\mc{R}}{r}{r'}{\ms{L}^{\mb{Q}}}$ if, 
% for all  models $\mc{M} \models \mc{R}$, we have
% $
% \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}}_{\mc{M}} 
% \tref \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{r'}{\ms{L}^{\mb{Q}}}}_{\mc{M}}
% $; in particular, two programs are \emph{equivalent} if their semantics are always equal.

When we say that \isotopessa{} and \subiterexp{} are \emph{equivalent}, what we mean is that there
are \emph{semantics-preserving} functions $\ms{SSA}$, $\ms{Expr}$ on derivations satisfying
\begin{align*}
\dnt{
  \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{ell}{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}}
  {\ell(A)^0}
}_{\mc{M}} &= \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}_{\mc{M}} ; \alpha ; \iota_r \\
\dnt{
  \hasty{\Gamma^{\mb{q}}}{\epsilon}
    {\ms{Expr}(\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}})}
    {\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}}
}_{\mc{M}} &= \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}}_{\mc{M}}
\end{align*}
for arbitrary models $\mc{M}$. 
%
% \footnote{ The astute reader will note that these functions are not \emph{quite} mutually inverse,
%   since the output of a round-trip
%   $\ms{SSA}(\ms{Expr}(\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}))$ now targets a
%   \emph{single} label with an argument of type $\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}$. This is a
%   somewhat thorny problem since the leftover variables in $\mb{Q}$ can be unpacked using an
%   $\ms{L}$-ary case-statement, but cannot \emph{escape} that case-statement. We can't get around
%   this problem, at least naively, by defining a function $\ms{SSA}_{\ms{L}^{\mb{Q}}}$ taking the
%   desired output label context as parameter (and requiring a derivation with output type
%   $\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}$), since a value of type $\ltoty{\Gamma}{\ms{L}^{\mb{Q}}}$ can
%   have the leftover variables filled in by any arbitrary expression, while our SSA typing enforces
%   they can only come from the input live variables $\Gamma^{\mb{q}}$. On the other hand, if we
%   require $\mb{Q} = 0$, then the $n$-ary case-statement works fine. }
%
It is easy enough to construct $\ms{Expr}$: for each derivation,
we simply pick a representative 
$
  (x, a) \in 
  \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}}_{\ms{Th(\cdot)}}
$. Since $\dnt{\Gamma^{\mb{q}}}_{\ms{Th}(\cdot)} = \etoty{\Gamma^{\mb{q}}}$, we may simply define
$
\ms{Expr}(\haslb{\Gamma^{\mb{q}}}{\epsilon}{r}{\ms{L}^{\mb{Q}}}) := 
  \letexpr{\Gamma}{x}{a}
$
where the unpacking of a value $c : \etoty{\Gamma^{\mb{q}}}$ is defined in the obvious recursive
manner (see Appendix~\ref{apx:packing} for details). 
%
% It is straightforward to verify that this indeed satisfies the desired properties. 
%
On the other hand, the function $\ms{SSA}$ is just standard expression compilation presented
inductively (the details are in Appendix~\ref{apx:ssa-roundtrip}). 
% We note in passing that the result of this function will always use only structured control-flow
% (since \subiterexp{} only supports structured control flow).  

\section{Concrete Models}

In this section, we sketch some concrete models. All the given models have types with unrestricted
linearity, and so we will write our typing rules using \emph{un-annotated} contexts and variables
$\Gamma, x: A$, assuming every quantity annotation is $\topq$. 
% Appendix~\ref{apx:sep} gives an example with substructural types.

\subsection{UB}

\label{ssec:ub}

The simplest model exercising all the features of our refinement calculus is the language with
nondeterminism, undefined behavior and nontermination. We represent this using the monad $\ms{UB}\;A
= \mc{P}^+(A \cup \{\infty\}) \cup \{\ubeff\}$ over sets, with $\infty$ a sentinel value for
nontermination and $\ubeff$ for UB. Its ordering is the inclusion order on nonempty sets $\mc{P}^+(A
\cup \{\infty\})$ extended with a top element $\ubeff$. (The full description of this model is in
Appendix~\ref{apx:ub}.) The monadic bind is:
$$
\mbind{\ms{UB}}{\ubeff}{f} = \ubeff \qquad
\mbind{\ms{UB}}{X}{f} = \{f\;a \mid a \in X\} \;\; \text{if } \forall a \in X, f\;a \neq \ubeff
\qquad
\mbind{\ms{UB}}{X}{f} = \ubeff \;\; \text{otherwise}
% \begin{cases}
%   \ubeff & \text{if}\;\exists a \in X, f\;a = \ubeff \\
%   \{f\;a \mid a \in X\} & \text{otherwise}
% \end{cases}
$$
where we define $f\;\infty = \infty$. 
%
The Kleisli category of $\ms{UB}$ has the lattice of effects generated by the nontermination effect
$\infty$, the UB effect $\ubeff$, and the nondeterminism effect $?$. In
Figure~\ref{fig:ub-submonads}, we give the submonad for each effect, along with its linearity and
commutativity with other effects.

This model lets us interpret instructions $\ubeff_A: \mb{1} \to_\ubeff A$ analogous to LLVM's
\texttt{unreachable} intrinsic. We write $\ubeff$ as shorthand for 
$\ubeff_A\;()$. This instruction lets us define \emph{unsafe unwrap} operators
$\rho_l : A + B \to_\ubeff A$ and $\rho_r : A + B \to_\ubeff B$
which take the other branch to $\ubeff$.
%
These satisfy the usual rewrite rules for UB, some of which are given in 
Figure~\ref{fig:ub-rewrites}.

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \centering
  \begin{tabular}{l|ccccccccc}
    & $\infty$ & $\ubeff$ & $?$ & $\infty\ubeff$ & $\infty?$ & $\ubeff?$ & $\infty\ubeff?$ 
    & $\ms{q}^+$ & $\ms{q}^-$ \\
    $\ms{UB}_\infty(A, B) \approx A \to B \cup \{\infty\}$ 
    & $\slides$ & $\leftmove$ & $\slides$ & $\leftmove$ & $\slides$ & $\leftmove$ & $\leftmove$ 
    & $\cpyq$ & $\cpyq$ \\ 
    $\ms{UB}_\ubeff(A, B) \approx A \to B \cup \{\ubeff\}$ 
    & $\rightmove$ & $\slides$ & $\slides$ & $\rightmove$ & $\rightmove$ & $\slides$ & $\rightmove$ 
    & $\topq$ & $\cpyq$ \\
    $\ms{UB}_?(A, B) \approx A \to \mc{P}^+(B)$
    & $\slides$ & $\slides$ & $\slides$ & $\slides$ & $\slides$ & $\slides$ & $\slides$ 
    & $\delq$ & $\topq$ \\
    $\ms{UB}_{\infty\ubeff}(A, B) \approx A \to B \cup \{\infty\} \cup \{\ubeff\}$ 
    & $\rightmove$ & $\leftmove$ & $\slides$ & $\cdot$ & $\rightmove$  & $\leftmove$ & $\cdot$ 
    & $\cpyq$ & $\cpyq$ \\
    $\ms{UB}_{\infty?}(A, B) \approx A \to \mc{P}^+(B \cup \{\infty\})$ 
    & $\slides$ & $\leftmove$ & $\slides$ & $\leftmove$ & $\slides$ & $\leftmove$ & $\leftmove$ 
    & $\oneq$ & $\cpyq$ \\ 
    $\ms{UB}_{\ubeff?}(A, B) \approx A \to \mc{P}^+(B) \cup \{\ubeff\}$ 
    & $\rightmove$ & $\slides$ & $\slides$ & $\rightmove$ & $\rightmove$ & $\slides$ & $\rightmove$ 
    & $\oneq$ & $\cpyq$ \\
  \end{tabular}
  \end{adjustbox}
  \caption{
    Submonads of $\ms{UB}$, along with their commutativity information 
    (i.e. whether they are a left or right mover w.r.t. other effects) and lineary information
    (given as positive and negative quantities $\ms{q}^+, \ms{q}^- \in \ms{Q}$)
  }
  \Description{}
  \label{fig:ub-submonads}
\end{figure}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{ub-then}}
      {\hasty{\Gamma, x : A}{\epsilon}{b}{B}}
      {\tmeq{\Gamma}{}{\letexpr{x}{\ubeff}{b}}{\ubeff}{B}} \qquad
    \prftree[r]{\rle{ub-left}}
      {\hasty{\Gamma}{\epsilon}{a}{A + B}}
      {\hasty{\Gamma, x : A}{\epsilon}{c}{C}}
      {\tmeq{\Gamma}{}{\caseexpr{a}{x}{c}{y}{\ubeff}}{\letexpr{x}{\rho_l\;a}{c}}{C}}
    \\
    \prftree[r]{\rle{ub-right}}
      {\hasty{\Gamma}{\epsilon}{a}{A + B}}
      {\hasty{\Gamma, y : B}{\epsilon}{c}{C}}
      {\tmeq{\Gamma}{}{\caseexpr{a}{x}{\ubeff}{y}{c}}{\letexpr{y}{\rho_r\;a}{c}}{C}}
  \end{gather*}
  \end{adjustbox}
  \caption{
    Some of the usual rewrite rules for undefined behavior.
  }
  \Description{}
  \label{fig:ub-rewrites}
\end{figure}

\subsection{Heaps}

\label{ssec:heaps}

We model a single-threaded heap
as a finitely-supported function of type $S := \nats \fpto \nats$. Using the state transformer on
 $\ms{UB}$, we can define a heap monad 
$\ms{Heap}\;A = S \to \ms{UB}\;(A \times S)$, with the natural pointwise partial order.
(The full description of this model is in Appendix~\ref{apx:ub-st}.)
% 
Our effect system is the bounded lattice generated by 
$\{\infty, \ubeff, ?, \ms{r}, \ms{w}, \ms{a}\}$, with $\ms{r}, \ms{w}$, and $\ms{a}$ corresponding to 
``read'', ``write'', and ``allocate'' respectively. The new primitive operations are:
\begin{itemize}
  \item $\ms{ld} : \ms{Heap}_{\ms{r}\ubeff}(\nats, \nats) := 
    \lambda p\; s.
      \ms{if}\;p \in s\;\ms{then}\;\ms{pure}_{\ms{ND}}(s\;p, s)\;\ms{else}\;\ubeff
    $
  \item $\ms{st} : \ms{Heap}_{\ms{w}\ubeff}(\nats \otimes \nats, \mb{1}) :=
    \lambda (p, x)\; s.
      \ms{if}\;p \in s\;\ms{then}\;\ms{pure}_{\ms{ND}}((), [p \mapsto x]s)\;\ms{else}\;\ubeff
    $
  \item $\ms{mk} : \ms{Heap}_{\ms{a}?}(\nats, \nats) :=
    \lambda x\; s. \{(p, [p \mapsto x]s) \mid p \notin s\}
    $
  \item $\ms{rm} : \ms{Heap}_{\ms{w}\ubeff}(\nats, ()) :=
    \lambda p . \ms{if}\;p \in s\;\ms{then}\;s \setminus p\;\ms{else}\;\ubeff
    $
\end{itemize}
This model validates the usual properties of heaps (see Figure~\ref{fig:heap-eqns}), as well as
that allocation is central, reads and writes are relevant, and reads are eliminable and commutative.
%
% It also supports a simple memory separation model 
%  la \emph{separation logic}, given in Appendix~\ref{apx:sep}.

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{st-ld}}
      {\hasty{\Gamma}{\bot}{p}{\nats}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\tmeq{\Gamma}{}{\ms{st}\;(p, a) ; \ms{ld}\;p}{\ms{st}\;(p, a) ; a}{\nats}}
    \qquad
    \prftree[r]{\rle{mk-ld}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\tmeq{\Gamma}{}{\letexpr{p}{\ms{mk}\;a}{(p, \ms{ld}\;p)}}
                                                 {(\ms{mk}\;a; a)}
                                                 {\nats \otimes \nats}}
    \\
    \prftree[r]{\rle{st-st}}
      {\hasty{\Gamma}{\bot}{p}{\nats}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\hasty{\Gamma}{\bot}{b}{\nats}}
      {\tmeq{\Gamma}{}{\ms{st}\;(p, a) ; \ms{st}\;(p, b)}{\ms{st}\;(p, b)}{\mb{1}}}
    \qquad
    \prftree[r]{\rle{mk-st}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\hasty{\Gamma}{\bot}{b}{\nats}}
      {\tmeq{\Gamma}{}{\letexpr{p}{\ms{mk}\;a}{\ms{st}\;(p, b) ; p}}
                                                  {\ms{mk\;b}}
                                                  {\nats}}
    \\
    \prftree[r]{\rle{mk-rm}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\tmeq{\Gamma}{}{\letexpr{p}{\ms{mk}\;a}{\ms{rm}\;p}}{()}{\mb{1}}}
    \qquad
    \prftree[r]{\rle{st-rm}}
      {\hasty{\Gamma}{\bot}{p}{\nats}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\tmeq{\Gamma}{}{\ms{st}\;(p, a) ; \ms{rm}\;p}{\ms{rm}\;p}{\mb{1}}}
    \\
  \end{gather*}
  \end{adjustbox}
  \caption{Some properties of heaps}
  \label{fig:heap-eqns}
  \Description{}
\end{figure}

\subsection{Concurrency}

In Brookes's \cite{brookes-full-abstraction-96} concurrency semantics, a memory effect
is a trace consisting of a finite sequence of transitions $\langle \mu, \rho \rangle$ 
between memory states $\mu$ and $\rho$.
%
Traces represent \emph{interrupted} program executions: a transition $\langle \mu, \rho
\rangle$ represents a single step in which the program, \emph{relying on} a state $\mu$ from the
environment, \emph{guarantees} it will return a state $\rho$ to the environment.
%
A program's denotation is now a \emph{set} of pairs $\tret{\xi}{r}$ of a trace $\xi$ and
return value $r$. Each pair corresponds to a possible execution of the program
given potential interference (e.g., an external thread reading and writing).

\citet{brookes-full-abstraction-96} observed that to make a denotational model sound with respect to
the operational semantics, the traces need to satisfy certain \emph{closure properties}. Trace sets
should be closed under ``\emph{stuttering}'' (adding transitions of the form $\langle \mu, \mu
\rangle$, corresponding to the program doing nothing) and ``\emph{mumbling}'' (merging $\langle \mu,
\rho \rangle\langle \rho, \theta \rangle \tref \langle \mu, \theta \rangle$, corresponding to the
environment doing nothing).

By choosing appropriate state types, closure properties, and operations on states, we can model a
variety of memory models. In particular,
\citet{release-acquire} show how to define a monad $\mc{I}\;A = \mc{P}(\{\tret{\xi}{r} \mid r \in
A\})$, which they use to guve a denotational semantics for release-acquire weak memory. This monad
has a poset-enriched Kleisli category under the usual subset order, and can be equipped with an
Elgot structure, which we show how to do in
Appendix~\ref{apx:rel-acq}, hence giving us a \subiterexp{}-model.

Just like for heaps, we can define an effect lattice $\{\ms{r}, \ms{w}, \infty\}$, though
for trace models reading is \emph{not} commutative; similarly, we have instructions $\ms{ld}: \nats
\to_{\ms{r}} \nats$ and $\ms{st}: \nats \otimes \nats \to_{\ms{w}} \mb{1}$, as well as an atomic
\emph{fetch-and-add} instruction $\ms{faa}: \nats \otimes \nats \to_{\ms{rw}} \nats$. We may
validate numerous refinements on memory operations in this model, some of which we give in
Figure~\ref{fig:weak-refinements}. Note that all of these are valid \emph{equalities} in the heap
model given above. Both the read and write effects are duplicable in this model, while the read
effect is not only eliminable, but also \emph{introducable}, since we do not have UB.

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{st-ld}}
      {\hasty{\Gamma}{\bot}{p}{\nats}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\tmle{\Gamma}{}{\ms{st}\;(p, a) ; \ms{ld}\;p}{\ms{st}\;(p, a) ; a}{\nats}}
      \qquad
    \prftree[r]{\rle{st-st}}
      {\hasty{\Gamma}{\bot}{p}{\nats}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\hasty{\Gamma}{\bot}{b}{\nats}}
      {\tmle{\Gamma}{}{\ms{st}\;(p, a) ; \ms{st}\;(p, b)}{\ms{st}\;(p, b)}{\mb{1}}}
    \\
    % \prftree[r]{\rle{st-faa}}
    %   {\hasty{\Gamma}{\bot}{p}{\nats}}
    %   {\hasty{\Gamma}{\bot}{a}{\nats}}
    %   {\hasty{\Gamma}{\bot}{b}{\nats}}
    %   {\tmle{\Gamma}{}{\ms{st}\;(p, a) ; \ms{faa}\;(p, b)}{\ms{st}\;(p, a + b) ; a}{\nats}}
    % \\
    \prftree[r]{\rle{ld-st}}
      {\hasty{\Gamma}{\bot}{p}{\nats}}
      {\hasty{\Gamma}{\bot}{a}{\nats}}
      {\tmle{\Gamma}{}{\letexpr{x}{\ms{ld}\;p}{\ms{st}\;p\;(x + a) ; x}}{\ms{faa}\;(p, a)}{\nats}}
  \end{gather*}
  \end{adjustbox}
  \caption{Some refinements valid in the release-acquire \subiterexp{}-model.}
  \label{fig:weak-refinements}
  \Description{}
\end{figure}

\section{Discussion and Related Work}

\textbf{From SSA to FP} SSA was introduced as a compiler IR by
\citet{alpern-ssa-original-88} and \citet{rosen-gvn-1988}, with the
goal of simplifying reasoning about variable values. In three address
code, a variable is mutable and can have a different value at each
program point, whereas in SSA, each variable has a single abstract
value, a fact which greatly simplifies optimizations like global value
numbering. \citet{kelsey-95-cps} demonstrated a correspondence between
SSA and a fragment of continuation-passing style, and
\citet{appel-ssa} simplified this further and showed that an SSA
program can be seen as a group of procedures mutually tail-calling
each other. When the dominance tree is further made explicit in the
syntax, we recover lexical scoping, and
\citet{chakravarty-functional-ssa-2003} used this to show how to
translate SSA programs into ANF. \citet{ghalayini-24-ssa-densem-arxiv}
relaxed the ANF restriction to permit compound (pure)
expressions, which gives a calculus with better substitution
principles, but which still has explicit block definitions. In this
work, we take the final step and give a fully expression-oriented
syntax, which is still completely equivalent to traditional SSA.

\noindent \textbf{Semantics of SSA} \citet{vellvm-12} is a mechanized semantics for LLVM's SSA dialect.
Their syntax closely follows LLVM's, and so their operational semantics must compute
$\phi$-nodes at each step. Furthermore, they give several such semantics and
prove refinements between them. Each semantics is further parameterized
over a memory model, and so execution builds a tree of possible executions, resumption-style,
which can then be made into concrete execution traces with an ``effect handler'' or
free monad interpreter computing the effect of each memory action. 
\citet{garbuzov-structural-cfg-2018} exhibit a correspondence between
an operational semantics for both SSA and a fragment of
call-by-push-value~\cite{cbpv}, and then use the normal form
bisimulations of \citet{lassen-bisim} to derive an equational theory
for justifying optimizations.  This work considers nontermination as
the only effect, and studies equivalence rather than refinement.
\citet{ghalayini-24-ssa-densem-arxiv} give a denotational semantics
similar to this paper's, but their model is not in enriched categories and
hence does not model refinement, nor does it model an effect system or
linear types. 

\noindent \textbf{Effect Systems and Linearity} Effect systems were introduced by \citet{gifford86},
which introduced a type system with a lattice of effects to track which effects a program could
potentially perform, with the idea of gaining reasoning principles by restricting effects.
\citet{fuhrmann-direct-1999} introduced the idea of categorizing effects in terms of linearity
(i.e., whether effects can be moved, duplicated or dropped), which reverses the conceptual priority:
effects are classified not by their intension, but by which equations they validate.
\citet{kammar-effect-12} build on this idea, and give a Gifford-style type-and-effect system for a
variant of call-by-push-value, an effect-dependent equational, and conditions on the semantics monad
to ensure each equation holds.
%
% This can be contrasted with the line of work on algebraic effects pioneered by
% \citet{plotkin-power-2001}, which views the signature of an effect as giving rise to a free monad,
% which can then be interpreted by a suitable monad morphism. Here, the natural emphasis is on
% finding equational theories which completely characterize a given kind of effect; for example, see
% the work of \citet{staton-state-10} on the equational properties of local state. 
%
We build on this work by integrating the idea of linearity of effects with an old idea of
\citet{lipton-mover-75}. By simply classifying effects by whether they can commute to the left or
right of another effect, we gain a very rich (in)equational theory very cheaply. 





% \TODO{ 
%   %  
%   \citet{vellvm-12} is a mechanized semantics for LLVM; SSA-based. They give several operational
%   semantics for it. What they do is prove refinements between their semantics. Doing a lot of
%   painful things: operational semantics computes $\phi$-nodes as part of every step. Operational
%   semantics is also parametrized by a memory model (cite Cerberus and CN lore too, also cite
%   itrees). There's natural structure of work there: their operational semantics is morally a set of
%   traces, which we then interpret by the concrete memory model. 
%   %
%   They use the recipe of a resumption monad w/ continuations. We also pick a monad, get the
%   premonoidal category of interest. So the things they wanted to do are natural, and we prove in
%   some sense that it's the only thing that you can do. So what we're doing is in some sense the
%   limit of their approach; completeness says this style completely characterization SSA, so you
%   don't need to prove any fiddly simulation relations, you just need a monad with the right
%   structure. In some sense, this is ``everything that you could need.''
%   %
% }

% \TODO{\citet{lipton-mover-75} for movers.}
% \TODO{\citet{kammar-effect-12}: you don't need a complete theory for an effect, you can do a lot
% just knowing what commutes with what. A good idea that is under-exploited.}
%
% \TODO{maybe take a peek at \citet{jiang-stack-25}; probably don't need to cite}


% UNCOMMENT THIS AFTER UNBLINDING!!! 

% \subsection*{Acknowledgements}
% 
% This work was supported in part by a European Research Council (ERC) Consolidator Grant for the
% project ``TypeFoundry'', funded under the European Union's Horizon 2020 Framework Programme (grant
% agreement no. 101002277).
% 
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\clearpage 

\appendix

\section{Refinement Rules and Notation}

We begin by giving the congruence rules for \subiterexp{} in Figure~\ref{fig:congruence-refinement},
which completes our presentation of \subiterexp{}'s type theory. We now wish to go over some basic
derivable refinement rules, which we will make use of throughout the rest of the appendix. We begin
with some useful lemmas and notational conventions:
\begin{itemize}
  \item $\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r} \iff \qsp{\Gamma}{\mb{q}}{\mb{q}_r}{\mb{q}_l}$
  \item We will write $\Gamma^\zeroq$ to mean the variable context $\Gamma$ with every variable
  having the zero quantity $\zeroq$. In particular, we note that $\qsp{\Gamma}{\mb{q}}{0}{\mb{q}}$
  and $\qsp{\Gamma}{\mb{q}}{0}{\mb{q}}$ are always derivable.
\end{itemize}
Recall that we define $a ; b := \letexpr{x}{a}{b}$ for $x \notin \ms{fv}(b)$. The following typing
rule is hence trivially derivable:
\begin{equation*}
  \prftree[r]{\rle{seq}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
    {0 \leq \alquant(A)}
    {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{b}{B}}
    {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a ; b}{B}}
\end{equation*}
We can easily convince ourselves that this satisfies some of the basic properties of sequencing; for
example, we have
\begin{equation*}
  \prftree[r]{}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_c}}
    {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_r}{\mb{q}_m}}
    {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
    {\hasty{\Gamma^{\mb{q}_m}}{\epsilon}{b}{B}}
    {0 \leq \alquant(A), \alquant(B)}
    {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{c}{C}}
    {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{(a ; b) ; c}{a ; (b ; c)}{C}}
\end{equation*}

As stated in Section~\ref{ssec:refinement-theory}, binding rules for the rest of our calculus are
derivable from the rest of \subiterexp{}'s refinement rules. We give these explicitly in
Figure~\ref{fig:derivable-binding}, along with the $\eta$-rule for unary let-bindings, which is
similarly derived from \brle{let$_1$-$\beta$}. We note the commutativity requirement for
\brle{pair-right-bind}, since on the left-hand side $a$ executes before $b$, while on the right-hand
side $b$ executes before $a$, hence the requirement that their effects commute. We can also derive a
simplified rule for uniformity, given below, by simply choosing $q_l = q_c$ and $c = z$ in
\brle{unif$^p$}:
  \begin{gather*}
    \prftree[r]{\rle{simp-unif$^p$}}
      {\eta \rightmove \epsilon}
      {\tmlep{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}
        {\letexpr{y}{s}{b}}
        {\caseexpr{b'}{x}{\linl{x}}{x}{\linr{s}}}{B + S}{p}}
      {
        \tmlep{\Gamma^{\mb{q}}}
          {\mc{R}}
          {\letexpr{x}{a}{\liter{s}{y}{b}}}
          {\liter{a}{x}{b'}}
          {B}
          {p}
      } \\
    \text{where} \qquad {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} \qquad
    \alquant(\Gamma^{\mb{q}_l}) = \top \qquad
    \einf{\epsilon} \qquad {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
    \\
    \qquad {\hasty{\Gamma^{\mb{q}_l}, x : A}{\eta}{s}{S}}
    \qquad {\hasty{\Gamma^{\mb{q}_l}, y : S}{\epsilon}{b}{B + A}}
    \qquad {\hasty{\Gamma^{\mb{q}_l}, x : A}{}{b'}{B + A}}
  \end{gather*}

We define \emph{pattern binding} $\letexpr{P}{a}{b}$ of patterns $P ::= x \mid (P, P')$ inductively
as follows (with bindings of variables $x$ and pairs $(x, y)$ defined as normally):
\begin{align*}
  \letexpr{(P, y)}{a}{b} &:= \letexpr{(x, y)}{a}{\letexpr{P}{x}{b}} 
    & \text{for } P \notin \ms{Var}, x \notin \ms{fv}(b) \\
  \letexpr{(x, P)}{a}{b} &:= \letexpr{(x, y)}{a}{\letexpr{P}{y}{b}} 
    & \text{for } P \notin \ms{Var}, y \notin \ms{fv}(b) \\
  \letexpr{(P, P')}{a}{b} &:= \letexpr{(x, y)}{a}{\letexpr{P}{x}{\letexpr{P'}{y}{b}}} 
    & \text{for } P, P' \notin \ms{Var}
\end{align*}
By a straightforward case analysis, we may show that the following rule is admissible:
\begin{equation*}
  \prftree[r]{\rle{pattern-pair'}}
    {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{(P, P')}{x}{a}}{B}}
    {\tmeq{\Gamma^{\mb{q}}}
      {\mc{R}}{\letexpr{(P, P')}{a}{b}}
      {\letexpr{(x, y)}{a}{\letexpr{P}{x}{\letexpr{P'}{y}{b}}}}{B}}
\end{equation*}
We extend pattern binding to other binding forms, for $P \notin \ms{Var}$, in the obvious manner:
\begin{align*}
  \caseexpr{a}{P}{b}{y}{c} &:= \caseexpr{a}{x}{\letexpr{P}{x}{b}}{y}{c} 
  & \text{for } x \notin \ms{fv}(b) \\
  \caseexpr{a}{x}{b}{P}{c} &:= \caseexpr{a}{x}{b}{y}{\letexpr{P}{y}{c}} 
  & \text{for } y \notin \ms{fv}(c) \\
  \liter{a}{P}{b} &:= \liter{a}{x}{\letexpr{P}{x}{b}}
  & \text{for } x \notin \ms{fv}(b)
\end{align*}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma^{\mb{q}}}{x : A^q_\epsilon}}
      {1 \leq q}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{x}{x}{A}} \qquad
    \prftree[r]{\rle{op}}
      {f : A \to_\epsilon B}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{f\;a}{f\;a'}{B}} \\
    \prftree[r]{\rle{let$_1$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{b}{b'}{B}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{\letexpr{x}{a'}{b'}}{B}} \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma^{\mb{q}}}{\cdot}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{()}{()}{\mb{1}}} \qquad
    \prftree[r]{\rle{pair}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_l}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{b}{b'}{B}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{(a, b)}{(a', b')}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{a}{a'}{A \otimes B}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A, y : B}{\mc{R}}{c}{c'}{C}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{(x, y)}{a}{c}}{\letexpr{(x, y)}{a'}{c'}}{C}}
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{inl}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\linl{a}}{\linl{a'}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{b'}{B}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\linr{b}}{\linr{b'}}{A + B}} \\
    \prftree[r]{\rle{case}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{e'}{A + B}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{a'}{C}}
      {\tmle{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{b'}{C}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a'}{y}{b'}}{C}} \\
    \prftree[r]{\rle{abort}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a'}{\mb{0}}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\labort{a}}{\labort{a'}}{C}}
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{iter}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{b}{b'}{B + A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{b}}{\liter{a'}{x}{b'}}{B}}
  \end{gather*}
  \end{adjustbox}
  \caption{\subiterexp{} congruence rules}
  \Description{}
  \label{fig:congruence-refinement}
\end{figure}

\begin{figure}
  \begin{adjustbox}{minipage=1.1\textwidth,scale=0.9}
  \begin{gather*}
    \prftree[r]{\rle{op-bind}}
      {f : A \to B}
      {\hasty{\Gamma}{}{a}{A}}
      {\tmeq{\Gamma}{\mc{R}}{f\;a}{\letexpr{x}{a}{f\;x}}{B}} 
      \\
    \prftree[r]{\rle{pair-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}}{}{b}{B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{(a, b)}{\letexpr{x}{a}{\letexpr{y}{b}{(x, y)}}}{A \otimes B}} 
      \\
    \prftree[r]{\rle{pair-left-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}}{}{b}{B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{(a, b)}{\letexpr{x}{a}{(x, b)}}{A \otimes B}} 
      \\
    \prftree[r]{\rle{pair-right-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}}{\eta}{b}{B}}
      {\epsilon \slides \eta}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{(a, b)}{\letexpr{y}{b}{(a, y)}}{A \otimes B}} 
      \\
    \prftree[r]{\rle{inl-bind}}
      {\hasty{\Gamma^{\mb{q}}}{}{a}{A}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\linl{a}}{\letexpr{x}{a}{\linl{x}}}{A + B}} \qquad
    \prftree[r]{\rle{inr-bind}}
      {\hasty{\Gamma^{\mb{q}}}{}{b}{B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
      {\linr{b}}{\letexpr{y}{b}{\linr{y}}}{A + B}} 
      \\
    \prftree[r]{\rle{abort-bind}}
      {\hasty{\Gamma^{\mb{q}}}{}{a}{\mb{0}}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\labort{a}}{\letexpr{x}{a}{\labort{x}}}{C}} 
      \\
  \end{gather*}
  \end{adjustbox}
  \caption{Derivable binding rules for \subiterexp{}}
  \Description{}
  \label{fig:derivable-binding}
\end{figure}

% \section{Formalization}

% In this section, we go over some of the lemmas and theorems in the paper which we have formally
% verified in Lean 4. Some of these are used in the paper proofs in later sections of the appendix.

% \TODO{checkmark everything, and talk about it?}

% \TODO{restate: weakening, substitution, weakening composition, splitting, coherence, soundness of
% (weakening/substitution)}

\section{Completeness}

\label{apx:completeness}

In this section, we give the details of the proof of completeness of our refinement calculus w.r.t.
our denotational semantics.

\subsection{Syntactic Model}

\label{apx:syn-model}


We begin by defining the syntactic category $\ms{Tm}(\mc{R})$ of \subiterexp{}-models of a signature
$\mc{S}$ quotiented by a set of primitive rewrites $\mc{R}$ as follows:
\begin{itemize}
  \item Objects types $A, B, C \in \ms{Ty}(\mc{X})$
  \item Morphisms $\ms{Tm}_\epsilon(A, B) := \{(x, a) \mid \hasty{x : A}{\epsilon}{a}{B}\} /
  \approx$, with quotiented pairs written as $\lambda$-expressions $\lambda x . a$, where $(\lambda
  x . a) \approx (\lambda x . b)$ if and only if $\tmeq{x : A}{\mc{R}}{a}{[x/y]b}{B}$. 

  Equivalently, morphisms in $\ms{Tm}_\epsilon(A, B)$ may be viewed as \emph{functions} $f :
  \ms{Var} \to \ms{Term}$, with $(x, a)(y) := [y/x]a$, satisfying the property that, for all $x, y
  \in \ms{Var}$, $\hasty{x : A}{\epsilon}{f(x)}{B}$ $f(y) = [y/x]f(x)$, quotiented up to equivalence
  $f \approx g \iff \tmeq{x : A}{\mc{R}}{f(x)}{g(x)}{B}$. The equivalence between these two
  representations is given by the $\eta$-law $f \approx \lambda x. f(x)$.

  \item Refinement on morphisms $f \tref g$ if and only if $\tmle{x : A}{\mc{R}}{f(x)}{g(x)}{B}$
  (this is well-defined since, by definition, we quotient precisely the equivalence clases of
  $\tref_{\mc{R}}$)
  \item Identity morphisms $\ms{id}_A := (\lambda x . x)$
  \item 
    Composition $(\lambda x. a) ; (\lambda y. b) := (\lambda x. \letexpr{y}{a}{b})$.
    We note that, for $a$ \emph{pure}, this reduces to the usual substitution-based definition
    $(\lambda x. a) ; (\lambda y. b) = (\lambda x . [a/y]b)$.
  \item Tensor products $A \otimes B$ with monoidal unit $\mb{1}$, and tensor functors
  $$
  (\lambda x. a) \otimes A := (\lambda z. \letexpr{(x, y)}{z}{(a, y)})
  \qquad
  A \otimes (z, b)
  := (\lambda x. \letexpr{(y, z)}{x}{(y, b)}))
  $$
  In general, we extend pattern binding to $\lambda$-expressions, writing 
  (for $x \notin \ms{fv}(a)$),
  $$
  (\lambda P . a) := (\lambda x. \letexpr{P}{x}{a})
  $$
  in which case we may rewrite the above as
  $$
  (\lambda x. a) \otimes A := (\lambda (x, y). (a, y))
  \qquad
  A \otimes (\lambda z. b) := (\lambda (y, z). (y, b)))
  $$
  In partiuclar, we hence have that
  $$
  (\lambda x.a) \ltimes (\lambda y.b) = (\lambda (x, y) . (a, b)) \qquad
  (\lambda x.a) \rtimes (\lambda y.b) = (\lambda (x, y) . 
    \letexpr{y'}{b}{\letexpr{x'}{a}{(x', y')}})
  $$
  \item Associators, unitors, and symmetries
  \begin{gather*}
    \alpha := (\lambda ((x, y), z) . (x, (y, z))) \qquad
    \alpha^{-1} := (\lambda (x, (y, z)) . ((x, y), z)) \qquad
    \sigma := (\lambda (x, y) . (y, x))
    \\
    \lambda := (\lambda (x, y) . x) \qquad
    \lambda^{-1} := (\lambda x. (x, ())) \qquad
    \rho := (\lambda (x, y) . y) \qquad
    \rho^{-1} := (\lambda y. ((), y))
  \end{gather*}
  \item Coproducts \(A + B\) with initial object $\mb{0}$, zero morphisms $0 := (x, \labort{x})$,
  and injections and distributors
  \begin{gather*}
    \iota_l := (\lambda x. \linl{x}) \qquad \iota_r := (\lambda x. \linr{x}) \qquad
    [(\lambda x. a), (\lambda y. b)] := (\lambda z. \caseexpr{z}{x}{a}{y}{b}) \\
    \delta := [- \otimes \iota_l, - \otimes \iota_r] = (\lambda x. \caseexpr{x}
                          {(y_l, y_r)}{(y_l, \linl{y_r})}
                          {(z_l, z_r)}{(z_l, \linr{z_r})}) \\
    \delta^{-1} := (\lambda (x_l, x_r). \caseexpr{x_r}{y}{\linl{(x_l, y)}}{z}{\linr{(x_r, z)}})
  \end{gather*}
  In particular, this means that we have
  \begin{align*}
    (\lambda x . a) ; [(\lambda y . b), (\lambda z . c)]
      &= (\lambda x . \caseexpr{a}{y}{b}{z}{c})
      \\
    (\lambda x . a) + (\lambda y . b) &= (\lambda z. \caseexpr{z}{x}{\linl{a}}{y}{\linr{b}})
      \\
    (\lambda x . a) ; (\lambda y . b) + (\lambda z . c)
      &= (\lambda x . \caseexpr{a}{y}{\linl{b}}{z}{\linr{c}})
  \end{align*}
  \item Iteration operator
  $
    (\lambda x. a)^\dagger := (\lambda y. \liter{y}{x}{a})
  $
  \item Discard and diagonal morphisms $\tmor{A} := (\lambda x. ())$ and $\dmor{A} := (\lambda x.
  (x, x))$
\end{itemize}
We aim to prove the following lemma:
\begin{lemma}
  $\ms{Tm}(\mc{R})$ is a \subiterexp{}-model.
\end{lemma}
\begin{proof}
We begin by noting that
\begin{gather*}
  (\lambda x . a) ; (\lambda P . b) = (\lambda x . \letexpr{P}{a}{b})
\end{gather*}
In particular, this allows us to deduce the following useful identities:
\begin{gather*}
  (\lambda x. a) ; \alpha = (\lambda x. \letexpr{((y, z), w)}{a}{(y, (z, w))}) \\
  (\lambda x. a) ; \alpha^{-1} = (\lambda x. \letexpr{(y, (z, w))}{a}{((y, z), w)}) \\
  (\lambda x. a) ; \sigma = (\lambda x. \letexpr{(y, z)}{a}{(z, y)}) \\
  (\lambda x. a) ; \lambda = (\lambda x. \letexpr{(y, z)}{a}{y}) \qquad
  (\lambda x. a) ; \lambda^{-1} = (\lambda x. (a, ())) \\
  (\lambda x. a) ; \rho = (\lambda x. \letexpr{(y, z)}{a}{z}) \qquad
  (\lambda x. a) ; \rho^{-1} = (\lambda x. ((), a))
\end{gather*}
We also note that
\begin{align*}
  (\lambda P . a) \otimes A 
    &= (\lambda (x, y) . (\letexpr{P}{x}{a}, y))
    = (\lambda (x, y) . \letexpr{P}{x}{(a, y)})
    = (\lambda (P, y) . (a, y)) \\
  A \otimes (\lambda P . b)
    &= (\lambda (x, y) . (x, \letexpr{P}{y}{b}))
    = (\lambda (x, y) . \letexpr{P}{y}{(x, b)})
    = (\lambda (x, P) . (x, b))
\end{align*}
We now verify that:
\begin{itemize}
  \item $\ms{Tm}_\epsilon(\mc{R})$ is a category: we have that
  % for arbitrary $(\lambda x . a) : \ms{Tm}_\epsilon(\mc{R})(A, B)$, $(\lambda y . b) :
  % \ms{Tm}_\epsilon(\mc{R})(B, C)$, $(\lambda z . c) : \ms{Tm}_\epsilon(\mc{R})(C, D)$, that
  \begin{align*}
    (\lambda x . x) ; (\lambda y . a) &= (\lambda x . \letexpr{y}{x}{a}) 
    = (\lambda x . [x/y]a) = (\lambda y . a) \\
    (\lambda x . a) ; (\lambda y . y) &= (\lambda x . \letexpr{y}{a}{y}) = (\lambda x . a) \\
    ((\lambda x . a) ; (\lambda y . b)) ; (\lambda z . c)
    &= (\lambda x . \letexpr{z}{(\letexpr{y}{a}{b})}{c})
    = (\lambda x . \letexpr{y}{a}{\letexpr{z}{b}{c}}) \\
    &= (\lambda x . a) ; (\lambda y . \letexpr{z}{b}{c})
    = (\lambda x . a) ; ((\lambda y . b) ; (\lambda z . c))
  \end{align*}
  \item $\ms{Tm}_\epsilon(\mc{R})$ is binoidal: we have that
  \begin{align*}
    (\lambda x . x) \otimes A 
    &= (\lambda z . \letexpr{(x, y)}{z}{(x, y)}) = (\lambda z . z)\
    \\
    ((\lambda x . a) ; (\lambda y . b)) \otimes A
    &= (\lambda (x, z) . (\letexpr{y}{a}{b}, z))
    = (\lambda (x, z) . \letexpr{y}{a}{(b, z)}) \\
    &= (\lambda (x, z) . \letexpr{(y, z')}{(a, z)}{(b, z')}) \\
    &= (\lambda (x, z) . (a, z)) ; (\lambda (y, z') . (b, z')) \\
    &= ((\lambda x . a) \otimes A) ; ((\lambda y  . b) \otimes A) \\
    A \otimes (\lambda y . y)
    &= (\lambda z . \letexpr{(x, y)}{z}{(x, y)}) = (\lambda z . z) \\
    A \otimes ((\lambda y . a) ; (\lambda z . b))
    &= (\lambda (x, y) . (x, \letexpr{z}{a}{b}))
    = (\lambda (x, y) . \letexpr{z}{a}{(x, b)}) \\
    &= (\lambda (x, y) . \letexpr{(x', z)}{(x, a)}{(x', b)}) \\
    &= (\lambda (x, y) . (x, a)) ; (\lambda (x', z) . (x', b)) \\
    &= (A \otimes (\lambda y . a)) ; (A \otimes (\lambda z . b)) 
  \end{align*}
  \item $\ms{Tm}_\epsilon(\mc{R})$ is symmetric premonoidal: 
  \begin{itemize}
    \item Pentagon equation: we have that
    \begin{align*}
      &\alpha_{(A \otimes B), C, D} ; \alpha_{A, B, (C \otimes D)} \\
      &= (\lambda ((x_{12}, x_3), x_4) . (x_{12}, (x_3, x_4))) ; 
         (\lambda ((x_1, x_2), x_{34}) . (x_1, (x_2, x_{34}))) \\
      &= (\lambda ((x_{12}, x_3), x_4) . 
        \letexpr{((x_1, x_2), x_{34})}{(x_{12}, (x_3, x_4))}{(x_1, (x_2, x_{34}))}) \\
      &= (\lambda ((x_{12}, x_3), x_4) . 
        \letexpr{(x_1, x_2)}{x_{12}}{(x_1, (x_2, (x_3, x_4)))}) \\
      &= (\lambda (((x_1, x_2), x_3), x_4) . (x_1, (x_2, (x_3, x_4)))) \\
      &= (\lambda (((x_1, x_2), x_3), x_4) . 
        \letexpr{(z_1, ((z_2, z_3), z_4))}{(x_1, ((x_2, x_3), x_4))}{(z_1, (z_2, (z_3, z_4)))})
      \\
      &= (\lambda (((x_1, x_2), x_3), x_4) . (x_1, ((x_2, x_3), x_4))) ;
      (\lambda (z_1, ((z_2, z_3), z_4)) . (z_1, (z_2, (z_3, z_4))))
      \\
      &= (\lambda (((x_1, x_2), x_3), x_4) . 
        \letexpr{((y_1, y_{23}), y_4)}{((x_1, (x_2, x_3)), x_4)}{(y_1, (y_{23}, y_4))}) ; 
        \\ & \qquad 
      (\lambda (z_1, ((z_2, z_3), z_4)) . (z_1, (z_2, (z_3, z_4))))
      \\
      &= (\lambda (((x_1, x_2), x_3), x_4) . ((x_1, (x_2, x_3)), x_4)) ; 
      (\lambda ((y_1, y_{23}), y_4) . (y_1, (y_{23}, y_4))) ; \\ & \qquad 
      (\lambda (z_1, ((z_2, z_3), z_4)) . (z_1, (z_2, (z_3, z_4))))
      \\
      &= \alpha_{A, B, C} \otimes D ; \alpha_{A, B \otimes C, D} ; A \otimes \alpha_{B, C, D}
    \end{align*}
    \item Triangle equation: we have that
    \begin{align*}
      \alpha_{A, \mb{1}, B} ; X \otimes \lambda_B
      &= (\lambda ((x, y), z) . (x, (y, z))) ; (\lambda (x', y') . y') \\
      &= (\lambda ((x, y), z) . \letexpr{(x', y')}{(x, (y, z))}{y'}) \\
      &= (\lambda ((x, y), z) . (y, z)) 
        = (\lambda (x, y) . y) \otimes B
        \\
      &= \rho_A \otimes B
    \end{align*}
    \item Hexagon equation: we have that
    \begin{align*}
      &\alpha_{A, B, C} ; \sigma_{A, B \otimes C} ; \alpha_{B, C, A} \\
      &= (\lambda ((x_1, x_2), x_3) . (x_1, (x_2, x_3))) 
        ; (\lambda (y_1, y_{23}) . (y_{23}, y_1))
        ; (\lambda ((z_2, z_3), z_1) . (z_2, (z_3, z_1)))
      \\
      &= (\lambda ((x_1, x_2), x_3) . ((x_2, x_3), x_1)) 
        ;  (\lambda ((z_2, z_3), z_1) . (z_2, (z_3, z_1))) 
      \\
      &= (\lambda ((x_1, x_2), x_3) . (x_2, (x_3, x_1))) \\
      &= (\lambda ((x_1, x_2), x_3) . (x_2, (x_1, x_3)))
        ; (\lambda (z_2, (z_1, z_3)) . (z_2, (z_3, z_1)))
      \\
      &= (\lambda ((x_1, x_2), x_3) . ((x_2, x_1), x_3)) 
        ; (\lambda ((y_2, y_1), y_3) . (y_2, (y_1, y_3)))
        ; (\lambda (z_2, (z_1, z_3)) . (z_2, (z_3, z_1)))
      \\
      &= \sigma_{A, B} \otimes C ; \alpha_{B, A, C} ; B \otimes \sigma_{A, C}
    \end{align*}
  \end{itemize}
  \item $\ms{Tm}_\epsilon(\mc{R})$ has chosen coproducts and an initial object: see formalization.
  \item $\ms{Tm}_\epsilon(\mc{R})$ is distributive: we have that
  \begin{align*}
    \delta_{X, Y, Z} ; \delta^{-1}_{X, Y, Z}
    &= [X \otimes \iota_l, X \otimes \iota_r] ; (\lambda (x, w) . 
      \caseexpr{w}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}}) \\
    &= [
      (\lambda (x, y) . (x, \linl{y})) 
      ; (\lambda (x, w) . \caseexpr{w}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}}), \\ & \quad\;\;
      (\lambda (x, z) . (x, \linr{z})) 
      ; (\lambda (x, w) . \caseexpr{w}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}})
    ] \\
    &= [
      (\lambda (x, y) . \caseexpr{\linl{y}}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}}), \\ & \quad\;\;
      (\lambda (x, z) . \caseexpr{\linr{z}}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}})
    ] \\
    &= [
      (\lambda (x, y) . \linl{(x, y)}),
      (\lambda (x, z) . \linr{(x, z)})
    ] = [\iota_l, \iota_r] = \ms{id}_{(X \otimes Y) + (X \otimes Z)}
  \end{align*}
  and
  \begin{align*}
    \delta^{-1}_{X, Y, Z} ; \delta_{X, Y, Z}
    &= (\lambda (x, w) .  \caseexpr{w}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}})
      ; [X \otimes \iota_l, X \otimes \iota_r] \\
    &= (\lambda (x, w) . \letexpr{w'}{\caseexpr{w}{y}{\linl{(x, y)}}{z}{\linr{(x, z)}}}{ 
      \\ & \quad\;\;
      \caseexpr{w'}{(x, y)}{(x, \linl{y})}{(x, z)}{(x, \linr{z})}}) \\
    &= (\lambda (x, w) . \caseexpr{w}
      {y}{\caseexpr{\linl{(x, y)}}{(x, y)}{(x, \linl{y})}{(x, z)}{(x, \linr{z})} \\ & \quad\;\;}
      {z}{\caseexpr{\linr{(x, z)}}{(x, y)}{(x, \linl{y})}{(x, z)}{(x, \linr{z})}}
    ) \\
    &= (\lambda (x, w) . \caseexpr{w}{y}{(x, \linl{y})}{z}{(x, \linr{z})}) \\
    &= (\lambda (x, w) . (x, \caseexpr{w}{y}{\linl{y}}{z}{\linr{z}}))
    = (\lambda (x, w) . (x, w)) = \ms{id}_{X \otimes (Y + Z)}
  \end{align*}
  \item $\ms{Tm}_\epsilon(\mc{R})$ has an iteration operator: we have that
  \begin{align*}
    (\lambda x . a)^\dagger
    &= (\lambda y . \liter{y}{x}{a}) \\
    &= (\lambda y . \letexpr{x}{y}{\caseexpr{a}{z}{z}{y}{\liter{y}{x}{a}}}) \\
    &= (\lambda x . \caseexpr{a}{z}{z}{y}{\liter{y}{x}{a}}) \\
    &= (\lambda x . \letexpr{w}{a}{\caseexpr{w}{z}{z}{y}{\liter{y}{x}{a}}}) \\
    &= (\lambda x . a) ; (\lambda w . \caseexpr{w}{z}{z}{y}{\liter{y}{x}{a}}) \\
    &= (\lambda x . a) ; [(\lambda z.z), (\lambda x.a)^\dagger]
    = (\lambda x.a) ; [\ms{id}, (\lambda x.a)^\dagger] \\
  \end{align*}
  \item $\ms{Tm}_\epsilon(\mc{R})$ is an Elgot category: it suffices to show that our iteration
  operator satisfies:
  \begin{itemize}
    \item Naturality: we have that
    \begin{align*}
    ((\lambda x.a) ; (\lambda y.b) + (\lambda z.z))^\dagger 
    &= (\lambda x.\caseexpr{a}{y}{\linl{b}}{z}{\linr{z}})^\dagger \\
    &= (\lambda w.\liter{w}{x}{\caseexpr{a}{y}{\linl{b}}{z}{\linr{z}}}) \\
    &= (\lambda w.\liter{w}{x}{\caseexpr{a}{y}{\linl{b}}{z}{\linr{z}}}) \\
    &= (\lambda w.\letexpr{y}{\liter{w}{x}{a}}{b}) \\
    &= (\lambda x.a)^\dagger ; (\lambda y.b)
    \end{align*} 
    \item Codiagonal: we have that
    \begin{align*}
    ((\lambda x.a)^\dagger)^\dagger
    &= (\lambda z.\liter{z}{y}{\liter{y}{x}{a}}) \\
    &= (\lambda z.\liter{z}{x}{\caseexpr{a}{y}{y}{w}{\linr{w}}}) \\
    &= (\lambda x.\caseexpr{a}{y}{y}{w}{\linr{w}})^\dagger \\
    &= ((\lambda x.a) ; [(\lambda y.y), (\lambda w.\linr{w})])^\dagger
      = ((\lambda x.a) ; [\ms{id}, \iota_r])^\dagger
    \end{align*}
    \item Directed Uniformity: assume that
    \begin{align*}
    (\lambda x . a) ; (\lambda y . b) \cref^p (\lambda y . b') ; \ms{id} + (\lambda x . a)
    \end{align*}
    Unfolding both sides of this refinement, we hence have that
    \begin{align*}
    (\lambda x . \letexpr{y}{a}{b}) \cref^p
    (\lambda y . \caseexpr{b'}{z}{\linl{z}}{x}{\linr{a}})
    \end{align*}
    We therefore, by \brle{unif$^p$}, have that
    \begin{align*}
    (\lambda x . a) ; (\lambda y . b)^\dagger 
    &= (\lambda x. \liter{a}{y}{b}) 
     = (\lambda z. \letexpr{x}{z}{\liter{a}{y}{b}})
    \\
    &\cref^p (\lambda z. \liter{z}{y}{b'}) = (\lambda y . b')^\dagger
    \end{align*}
    as desired.
    \item Dinaturality: we have that
    \begin{proposition}
      If $(-)^\dagger$ is an iteration operator which satisfies naturality and codiagonal and is
      $\mc{K}$-uniform for $\mc{K}$ cocartesian, then it also satisfies dinaturality.
    \end{proposition}
    \begin{proof}
      See Lemma 31 of \citet{goncharov-18-guarded-traced}
    \end{proof}
    Since all $\ms{Tm}_\epsilon(\mc{R})$ for $\einf{\epsilon}$ are $\ms{Tm}_\bot(\mc{R})$-uniform,
    and $\ms{Tm}_\bot(\mc{R})$ is cocartesian, $\ms{Tm}_\epsilon(\mc{R})$ must in fact satisfy
    dinaturality as desired.
  \end{itemize}
  \item Strength: fix $\hasty{z : A}{}{a}{B + A}$. We have that
  \begin{align*}
    x : C, y : A &
      \vdash_{\mc{R}} 
      \letexpr{(x, z)}{(x, y)}{\caseexpr{a}{w_l}{\linl{(x, w_l)}}{w_r}{\linr{(x, w_r)}}} \\
      &\approx \caseexpr{(\letexpr{z}{y}{a})}{w_l}{\linl{(x, w_l)}}{w_r}{\linr{(x, w_r)}} \\
      &\approx \caseexpr{(\letexpr{z}{y}{a})}{w_l}{\linl{(x, w_l)}}{y}{\linr{(x, y)}}
  \end{align*}
  Hence, by uniformity, as $(v_l, v_r')$ is pure, we have
  \begin{align*}
    &(C \otimes (\lambda z . a) ; \delta^{-1})^\dagger \\
    &= (\lambda (x, z) . \letexpr{(x', w)}{(x, a)}
      {\caseexpr{w}{w_l}{\linl{(x', w_l)}}{w_r}{\linr{(x', w_r)}}})^\dagger
    \\
    &= (\lambda (x, z) . \caseexpr{a}{w_l}{\linl{(x, w_l)}}{w_r}{\linr{(x, w_r)}})^\dagger
    \\
    &= (\lambda v . \liter{v}{(x, z)}{\caseexpr{a}{w_l}{\linl{(x, w_l)}}{w_r}{\linr{(x, w_r)}}})
    \\
    &= (\lambda (x, y) . \letexpr{y}{y}{\liter{(x, y)}{(x, z)}{\caseexpr{a}{w_l}
      {\linl{(x, w_l)}}{w_r}{\linr{(x, w_r)}}}}) \\
    &= (\lambda (x, y) . \letexpr{w}{\liter{y}{y}{\letexpr{z}{y}{a}}}{(x, w)}) \\
    &= (\lambda (x, y) . \letexpr{w}{\liter{y}{z}{a}}{(x, w)}) \\
    &= (\lambda (x, y) . (x, \liter{y}{z}{a})) \\
    &= C \otimes (\lambda z . a)^\dagger
  \end{align*}
\end{itemize}
Hence, to show that we have a valid \subiterexp{}-model, it suffices to prove that, given $(\lambda
x.a) : \ms{Tm}_\epsilon(\mc{R})(A, B)$
\begin{itemize}
  \item If $A$ is relevant,
  \begin{align*}
  \dmor{A} ; \dmor{A} \otimes A ; \alpha
  &= (\lambda x. (x, x)) 
    ; (\lambda (y, z) . ((y, y), z) 
    ; (\lambda ((w_1, w_2), w_3) . (w_1, (w_2, w_3))) \\
  &= (\lambda x. ((x, x), x)) ; (\lambda ((w_1, w_2), w_3) . (w_1, (w_2, w_3))) \\
  &= (\lambda x. (x, (x, x))) = (\lambda x. (x, x)) ; (\lambda (y, z) . (y, (z, z))) \\
  &= \dmor{A} ; A \otimes \dmor{A}
  \end{align*}
  and
  \begin{align*}
  \dmor{A} ; \sigma_{A, A} &= (\lambda x. (x, x)) ; (\lambda (y, z) . (z, y)) \\
  &= (\lambda x. \letexpr{(y, z)}{(x, x)}{(z, y)}) = (\lambda x.(x, x)) = \dmor{A}
  \end{align*}
  as desired
  \item If $0 \leq \alquant^p(\epsilon)$ and $A, B$ affine, by \brle{let$_1$-$\beta^p$}, 
  \begin{align*}
  (\lambda x.a) ; {!}_B &= (\lambda x. \letexpr{y}{a}{()}) \cref^p (\lambda x.()) = {!}_A
  \end{align*}
  \item If $0 \leq \alquant^p(\epsilon)$ and $A$ relevant, $B$ affine, by \brle{elim$^p$}, 
  \begin{align*}
  \dmor{A} ; (f ; \tmor{B}) \otimes A &= (\lambda x. 
    \letexpr{(y, z)}{(x, x)}{(\letexpr{w}{f(y)}{()}, z)})
    \\
    &= (\lambda x. (f(x) ; (), x)) = (\lambda x . \letexpr{y}{(f(x) ; ())}{((), x)}) \\
    & \cref^p (\lambda x. \letexpr{y}{()}{((), x)})
      = (\lambda x. ((), x)) = \rho^{-1}
  \end{align*}
  \item If $\omega^+ \leq \alquant^p(\epsilon)$ and $A, B$ relevant, by \brle{let$_1$-$\beta^p$}, 
  \begin{align*}
    (\lambda x.a) ; \dmor{B} &= (\lambda x.a) ; (\lambda y.(y, y)) 
    = (\lambda x.\letexpr{y}{a}{(y, y)})
    = (\lambda x. (a, a)) \\
    &= (\lambda x. (\letexpr{y}{x}{[y/x]a}, \letexpr{z}{x}{[z/x]a})) \\
    &= (\lambda x. \letexpr{y}{x}{\letexpr{z}{x}{([y/x]a, [z/x]a)}}) \\
    &= (\lambda x . \letexpr{(y, z)}{(x, x)}{([y/x]a, [z/x]a)}) \\
    &= (\lambda x. (x, x)) ; (\lambda (y, z). ([y/x]a, [z/x]a)) 
     = \dmor{A} ; (\lambda x.a) \ltimes (\lambda x.a)
  \end{align*}
\end{itemize}
\end{proof}
% Now that we have shown that $\ms{Tm}(\mc{R})$ is a valid \subiterexp{}-model, we proceed to list
% some further useful identities:
% \begin{itemize}
%   \item $\sigma^{\ms{mid}}_{A, B, C, D} = (\lambda ((x, y), (z, w)) . ((x, z), (y, w)))$
% \end{itemize}

\subsection{Packing and Unpacking}

\label{apx:packing}

Given an annotated context $\Gamma^{\mb{q}}$, we can recursively define the \emph{packing}
$\hasty{\Gamma^{\mb{q}}}{\bot}{\ms{pack}(\Gamma^{\mb{q}})}{\etoty{\Gamma^{\mb{q}}}}$ of its
variables in the obvious manner; namely
\begin{equation*}
  \ms{pack}(\cdot) := () \qquad
  \ms{pack}(\Gamma^{\mb{q}}, x : A^q) = (\ms{pack}(\Gamma^{\mb{q}}), x^q) \qquad
  x^q :=
  \begin{cases}
    x & \text{if } q \neq 0 \\
    () & \text{otherwise}
  \end{cases}
\end{equation*}
We can similarly \emph{unpack} a context's effective type $a : [\ms{\Gamma}^{\mb{q}}]$, which we
write $\letexpr{\Gamma}{a}{b}$, inductively in the obvious manner:
\begin{equation*}
  (\letexpr{\cdot}{a}{b}) := (a ; b) \qquad
  (\letexpr{\Gamma, x : A}{a}{b}) :=
  (\letexpr{(g, x)}{a}{\letexpr{\Gamma}{g}{b}}) 
\end{equation*}
We can show this satisfies the following typing rule by induction on $\Delta^{\mb{q}'}$.
\begin{equation*}
  \prftree[r]{\rle{unpack}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{[\Delta^{\mb{q}'}]}}
    {\hasty{\Gamma^{\mb{q}_r}, \Delta^{\mb{q}'}}{\epsilon}{b}{B}}
    {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{\Gamma}{a}{b}}{B}}
\end{equation*}
In particular, we proceed as follows:
\begin{itemize}
  \item Given $a : \etoty{\cdot}$, this follows directly from the derived rule
  \brle{seq}.
  \item Given $a : \etoty{\Delta^{\mb{q}'}, x : A^q}$, we have that
  $\hasty{\Gamma^{\mb{q}_r}, x : A^q, \Delta^{\mb{q}'}}{\epsilon}{b}{B}$. Hence,
  \begin{itemize}
    \item If $q \neq 0$, then $[A^q] = A$, so by weakening $\hasty{\Gamma^{\mb{q}}, x :
    A}{\epsilon}{\letexpr{\Gamma}{a'}{b}}{B}$ and therefore $\hasty{\Gamma^{\mb{q}}, g:
    [\Delta^{\mb{q}'}]^0, x : [A^q]}{\epsilon}{\letexpr{\Gamma}{a'}{b}}{B}$
    \item If $q = 0$, then $x$ cannot be used in $b$, so
    $\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{\Gamma}{a'}{b}}{B}$, and hence, as $[A^0] = \mb{1}$
    has unrestricted linearity, $\hasty{\Gamma^{\mb{q}}, g: [\Delta^{\mb{q}'}]^0, x :
    [A^q]}{\epsilon}{\letexpr{\Gamma}{a'}{b}}{B}$ by weakening.
  \end{itemize}
  By induction, we may hence derive
  \begin{equation*}
  \prftree[r]{\rle{unpack}}
    {\hasty{\Gamma^0, g: [\Delta^{\mb{q}'}], x : [A^q]^0}{\epsilon}{g}{[\Delta^{\mb{q}'}]}}
    {\hasty{\Gamma^{\mb{q}_l}, g: [\Delta^{\mb{q}'}]^0, x : [A^q], \Delta^{\mb{q}'}}{\epsilon}{b}{B}}
    {\hasty{\Gamma^{\mb{q}_l}, g: [\Delta^{\mb{q}'}], x : [A^q]}{\epsilon}{\letexpr{\Gamma}{g}{b}}{B}}
  \end{equation*}
  Therefore, since $[\Delta^{\mb{q}'}, x : A^q] = [\Delta^{\mb{q}'}] \otimes [A^q]$, we may derive
  \begin{equation*}
  \prftree[r]{\rle{let$_2$}}
    {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{[\Delta^{\mb{q}'}, x : A^q]}}
    {\hasty{\Gamma^{\mb{q}_l}, g: [\Delta^{\mb{q}'}], x : [A^q]}{\epsilon}{\letexpr{\Gamma}{g}{b}}{B}}
    {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{(g, x)}{a}{\letexpr{\Gamma}{g}{b}}}{B}}
  \end{equation*}
  as desired.
\end{itemize}
We prove that packing and unpacking are mutually inverse up to $\approx$ by induction:
\begin{lemma}
  The following rules are derivable:
  \begin{gather*}
  \prftree[r]{\rle{unpack-pack}}
    {\hasty{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\epsilon}{a}{A}}
    {\tmeq{\Gamma^{\mb{q}}, \Delta^{\mb{q}'}}{\mc{R}} 
      {\letexpr{\Delta}{\ms{pack}(\Delta^{\mb{q}'})}{a}}{a}{A}}
    \\
  \prftree[r]{\rle{pack-unpack}}
    {\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{[\Delta^{\mb{q}'}]}}
    {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{\Delta}{b}{\ms{pack}(\Delta^{\mb{q}'})}}{b}
      {[\Delta^{\mb{q}'}]}}
  \end{gather*}
\end{lemma}
\begin{proof}
  We proceed by $\Delta^{\mb{q}'}$
  \begin{itemize}
    \item $(\cdot)$: the results follow by \brle{elim} and \brle{term}, respectively.
    \item $(\Gamma^{\mb{q}}, x : B^q)$: we have by induction that
    \begin{itemize}
      \item We have
      \begin{align*}
      \Gamma^{\mb{q}}, \Delta^{\mb{q}'}, x : B^q 
      & \vdash_{\mc{R}} \letexpr{\Delta^{\mb{q}'}, x : B^q}
        {\ms{pack}((\Delta^{\mb{q}'}, x : B^q)}{a} \\
      & \approx \letexpr{(g, y)}{(\ms{pack}(\Delta^{\mb{q}'}), x^q)}{[y/x]a} \\
      & \approx \letexpr{g}{\ms{pack}(\Delta^{\mb{q}'})}{\letexpr{y}{x^q}{[y/x]a}} \\
      & \approx \letexpr{y}{x^q}{[y/x]a} \approx a : A
      \end{align*}
      since if $q \neq 0$, $\letexpr{y}{x^q}{[y/x]a} \approx \letexpr{y}{x}{[y/x]a} \approx a$,
      whereas if $q = 0$ $x \notin \ms{fv}(a)$ so $\letexpr{y}{x^q}{[y/x]a} \approx
      \letexpr{y}{x}{a} \approx a$.
      \item We have
      \begin{align*}
      \Gamma^{\mb{q}}
      & \vdash_{\mc{R}} \letexpr{\Delta^{\mb{q}'}, x : A^q}{b}{\ms{pack}(\Delta^{\mb{q}'}, x : B^q)} 
      \\
      & \approx \letexpr{(g, x)}{b}{\letexpr{\Delta^{\mb{q}'}}{g}
        {(\ms{pack}(\Delta^{\mb{q}'}), x^q)}} \\
      & \approx \letexpr{(g, x)}{b}{\letexpr{w}{
          (\letexpr{\Delta^{\mb{q}'}}{g}{\ms{pack}(\Delta^{\mb{q}'})})
        }{(w, x^q)}} \\
      & \approx \letexpr{(g, x)}{b}{\letexpr{w}{g}{(w, x^q)}} \approx \letexpr{(g, x)}{b}{(g, x^q)}
      & \approx (g, x)
      \end{align*}
      since if $q \neq 0$ $(g, x^q) := (g, x)$, whereas if $q = 0$ since $x$ is pure and of type
      $\mb{1}$, by $\mb{term}$, $(g, x^q) := (g, ()) \approx (g, x)$.
    \end{itemize}
  \end{itemize}
\end{proof}
To show completeness, it hence suffices to prove the following lemma:
\begin{lemma}
  Given $\hasty{\Gamma^{\mb{q}}}{}{a}{A}$, we have that, for all $(\lambda x. a_x) \in
  \dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}_{\ms{Tm}(\mc{R})}$,
  \begin{equation*}
    \tmeq{\Gamma^{\mb{q}}}{\mc{R
    }}{\letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{a_x}}{a}{A}
  \end{equation*}
\end{lemma}
\begin{proof}
  Throughout this proof, given morphism $f \in \ms{Tm}(\mc{R})(A, B)$, we will use $f(x)$ as a
  stand-in for an arbitrary member of the appropriate equivalence class. We note that (for arbitrary
  types)
  \begin{equation*}
  \letexpr{x}{a}{(f ; g)(x)} \approx \letexpr{y}{(\letexpr{x}{a}{f(x)})}{g(y)}
  \end{equation*}
  and hence that, if $\letexpr{x}{a}{f(x)} \approx a'$, $\letexpr{x}{a}{(f ; g)(x)} =
  \letexpr{x}{a'}{g(x)}$. In particular, we hence have that 
  \begin{itemize}
    \item Given $b$ pure and $\letexpr{x}{a}{f(x)} = a'$,
    $\letexpr{y}{b}{g(y)} = b'$, we have
    \begin{equation*}
      \letexpr{z}{(a, b)}{((f \otimes g) ; h)(z)} \approx \letexpr{z}{(a', b')}{h(z)}
    \end{equation*}
    \item Given $a$ pure,
    \begin{align*} 
    &\letexpr{z}{(a, b)}{(\delta^{-1} ; f)(z)} 
    \\ &\approx \caseexpr{b}
      {y_l}{\letexpr{z_l}{\linl{(a, y_l)}}{f(z_l)}}
      {y_r}{\letexpr{z_r}{\linr{(a, y_r)}}{f(z_r)}}
    \\ &\approx \caseexpr{b}
      {y_l}{\letexpr{z_l}{(a, y_l)}{\iota_l ; f(z_l)}}
      {y_r}{\letexpr{z_r}{(a, y_r)}{\iota_r ; f(z_r)}}
    \end{align*}
    In particular, this implies that
    \begin{align*} 
    &\letexpr{z}{(a, b)}{(\delta^{-1} ; [f, g])(z)} 
    \\ &\approx \caseexpr{b}
      {y_l}{\letexpr{z_l}{(a, y_l)}{f(z_l)}}
      {y_r}{\letexpr{z_r}{(a, y_r)}{g(z_r)}}
    \end{align*}
  \end{itemize} 
  We begin by showing that
  \begin{equation*}
    \dnt{\cwk{\Gamma^{\mb{q}}}{\cdot}} \approx (\lambda x. ())
  \end{equation*}
  which we do by a straightforward induction on the derivation $\cwk{\Gamma^{\mb{q}}}{\cdot}$:
  \begin{itemize}
    \item ($\cwk{\cdot}{\cdot}$): we have $\dnt{\cwk{\cdot}{\cdot}} = \ms{id}_{\mb{1}} = (\lambda x
    : \mb{1}.x) = (\lambda x.())$ as desired.
    \item ($\cwk{\Gamma^{\mb{q}}, x : A^q}{\cdot}$): we have that
    \begin{align*}
      \dnt{\cwk{\Gamma^{\mb{q}}, x : A^q}{\cdot}}
      &= [\Gamma^{\mb{q}}] \otimes \tmor{A^q} ; \rho ; \dnt{\cwk{\Gamma^{\mb{q}}}{\cdot}} 
       = (\lambda (x, y) . ((), ())) ; (\lambda (z, w) . z) ; (\lambda u . ()) \\
      &= (\lambda (x, y) . ()) ; (\lambda u . ()) = (\lambda (x, y) . ()) = (\lambda u . ())
    \end{align*}
  \end{itemize}
  It follows immediately that
  \begin{equation*}
  \Gamma^{\mb{q}} \vdash_\bot 
    \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\cwk{\Gamma^{\mb{q}}}{\cdot}}(x)}
    \approx \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{()}
    \approx ()
    : \mb{1}
  \end{equation*}
  We may therefore show that
  \begin{equation*}
  \Gamma^{\mb{q}} \vdash_\bot 
    \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}}(x)}
    \approx ((), y))
    : [y : A^1]
  \end{equation*}
  We proceed by induction on the derivation $\cwk{\Gamma^{\mb{q}}}{y : A^1}$:
  \begin{itemize}
    \item ($\cwk{\Gamma^{\mb{q}}, y : A^q}{y : A^1}$): we have that
    \begin{align*}
    \dnt{\cwk{\Gamma^{\mb{q}}, y : A^q}{y : A^1}}
    &= \dnt{\cwk{\Gamma^{\mb{q}}}{\cdot}} \otimes \ms{id}
     = (\lambda x.()) \otimes (\lambda y.y)
     = (\lambda (x, y) . ((), y))
    \end{align*}
    It follows that
    \begin{align*}
    \Gamma^{\mb{q}}, y : A^q & \vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}}, y : A^q)}  
        {\dnt{\cwk{\Gamma^{\mb{q}}, y : A^q}{y : A^1}}(x)} \\
      &\approx \letexpr{x}{(\ms{pack}(\Gamma^{\mb{q}}, y))}{(\lambda (z, w) . ((), w))(x)} \\
      &\approx \letexpr{(z, w)}{(\ms{pack}(\Gamma^{\mb{q}}, y))}{((), w)} \\
      &\approx ((), y)
      : [y : A^1]
    \end{align*}
    \item ($\cwk{\Gamma^{\mb{q}}, z : B^q}{y : A^1}$): we have that
    \begin{align*}
    \dnt{\cwk{\Gamma^{\mb{q}}, z : B^q}{y : A^1}}
    &= [\Gamma^{\mb{q}}] \otimes \tmor{B^q} ; \rho ; \dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}} \\
    &= (\lambda (x, y) . (x, ())) ; (\lambda (z, w) . z) ; \dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}} \\
    &= (\lambda (x, y) . x) ; \dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}} \\
    &= (\lambda (x, y) . \dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}}(x))
    \end{align*}
    It follows by induction that
    \begin{align*}
    \Gamma^{\mb{q}}, z : B^q & \vdash_\bot
    \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}}, z : B^q)}  
      {\dnt{\cwk{\Gamma^{\mb{q}}, y : A^q}{y : A^1}}(x)} \\
    &\approx \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}}, z^q)}  
        {\lambda (w, u) . \dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}}(w)} \\
    &\approx \letexpr{w}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\cwk{\Gamma^{\mb{q}}}{y : A^1}}(w)}
      \approx ((), y)
      : [y : A^1]
    \end{align*}
  \end{itemize}
  Similarly, we have that
  \begin{equation*}
  \Gamma^{\mb{q}} \vdash_\bot 
    \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q_r}}}(x)}
    \approx (\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r}))
    : [\Gamma^{\mb{q}_l}] \otimes [\Gamma^{\mb{q}_r}]
  \end{equation*}
  We proceed by induction on the derivation $\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q_r}}$:
  \begin{itemize}
    \item $(\qsp{\cdot}{\cdot}{\cdot}{\cdot})$: we have that
    \begin{align*}
      \cdot &\vdash_\bot 
        \letexpr{x}{\ms{pack}(\cdot)}{\dnt{\qsp{\cdot}{\cdot}{\cdot}{\cdot}}(x)} 
        \approx \letexpr{x}{()}{\rho^{-1}(x)} \\
        &\approx \letexpr{x}{()}{(x, ())}
        \approx ((), ())
        \approx (\ms{pack}(\cdot), \ms{pack}(\cdot))
        : [\ms{pack}(\cdot)] \otimes [\ms{pack}(\cdot)]
    \end{align*}
    as desired.
    \item $(\qsp{\Gamma, x : A}{\mb{q}, q}{\mb{q}_l, q}{\mb{q}_r, 0})$: we have that
    \begin{align*}
      \Gamma^{\mb{q}}, x : A^q &\vdash_\bot
        \letexpr{w}{\ms{pack}(\Gamma^{\mb{q}}, x : A^q)}
          {\dnt{\qsp{\Gamma, x : A}{\mb{q}, q}{\mb{q}_l, q}{\mb{q}_r, 0}}(w)} \\
        &\approx
        \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}}), x^q)}{
          (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} \otimes \rho^{-1} ; \sigma^{\ms{mid}})(w)
        } \\
        &\approx
        \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}}), x^q)}{
          ((\lambda (y, z) . (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), (z, ()))) 
            ; \sigma^{\ms{mid}})(w)
        } \\
        &\approx
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
          \letexpr{z}{x^q}{
            \letexpr{u}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), (z, ()))}
              {\sigma^{\ms{mid}}(u)}
          }
        }
        \\
        &\approx
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
          \letexpr{u}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), (x^q, ()))}
            {\sigma^{\ms{mid}}(u)}
        }
        \\
        &\approx
        \letexpr{u}{
          ((\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}
            {(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y)}), (x^q, ()))
          }
          {\sigma^{\ms{mid}}(u)}
        \\
        &\approx
        \letexpr{((u_1, u_2), (u_3, u_4)}{
          ((\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r})), (x^q, ()))
          }
          {((u_1, u_3), (u_2, u_4))}
        \\
        &\approx
          (\ms{pack}(\Gamma^{\mb{q}_l}), x^q), (\ms{pack}(\Gamma^{\mb{q}_r}), ()))
        \\
        &\approx
          (\ms{pack}(\Gamma^{\mb{q}_l}, x : A^q), \ms{pack}(\Gamma^{\mb{q}_r}, x : A^0))
        : [\Gamma^{\mb{q}_l}, x : A^q] \otimes [\Gamma^{\mb{q}_r}, x : A^0]
    \end{align*}
    as desired.
    \item $(\qsp{\Gamma, x : A}{\mb{q}, q}{\mb{q}_l, 0}{\mb{q}_r, q})$: we have that
    \begin{align*}
      \Gamma^{\mb{q}}, x : A^q &\vdash_\bot
        \letexpr{w}{\ms{pack}(\Gamma^{\mb{q}}, x : A^q)}
          {\dnt{\qsp{\Gamma, x : A}{\mb{q}, q}{\mb{q}_l, 0}{\mb{q}_r, q}}(w)} \\
        &\approx
        \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}}), x^q)}{
          (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} \otimes \lambda^{-1} 
            ; \sigma^{\ms{mid}})(w)
        } \\
        &\approx
        \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}}), x^q)}{
          ((\lambda (y, z) . (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), ((), z))) 
            ; \sigma^{\ms{mid}})(w)
        } \\
        &\approx
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
          \letexpr{z}{x^q}{
            \letexpr{u}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), ((), z))}
              {\sigma^{\ms{mid}}(u)}
          }
        }
        \\
        &\approx
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
          \letexpr{u}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), ((), x^q))}
            {\sigma^{\ms{mid}}(u)}
        }
        \\
        &\approx
        \letexpr{u}{
          ((\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}
            {(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y)}), ((), x^q))
          }
          {\sigma^{\ms{mid}}(u)}
        \\
        &\approx
        \letexpr{((u_1, u_2), (u_3, u_4)}{
          ((\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r})), ((), x^q))
          }
          {((u_1, u_3), (u_2, u_4))}
        \\
        &\approx
          (\ms{pack}(\Gamma^{\mb{q}_l}), ()), (\ms{pack}(\Gamma^{\mb{q}_r}), x^q))
        \\
        &\approx
          (\ms{pack}(\Gamma^{\mb{q}_l}, x : A^0), \ms{pack}(\Gamma^{\mb{q}_r}, x : A^q))
        : [\Gamma^{\mb{q}_l}, x : A^0] \otimes [\Gamma^{\mb{q}_r}, x : A^q]
    \end{align*}
    as desired.
    \item $(\qsp{\Gamma, x : A}{\mb{q}, q}{\mb{q}_l, q}{\mb{q}_r, q})$: we have that
    \begin{align*}
      \Gamma^{\mb{q}}, x : A^q &\vdash_\bot
        \letexpr{w}{\ms{pack}(\Gamma^{\mb{q}}, x : A^q)}
          {\dnt{\qsp{\Gamma, x : A}{\mb{q}, q}{\mb{q}_l, q}{\mb{q}_r, q}}(w)} \\
        &\approx
        \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}}), x^q)}{
          (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} \otimes \dmor{}
            ; \sigma^{\ms{mid}})(w)
        } \\
        &\approx
        \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}}), x^q)}{
          ((\lambda (y, z) . (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), (z, z))) 
            ; \sigma^{\ms{mid}})(w)
        } \\
        &\approx
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
          \letexpr{z}{x^q}{
            \letexpr{u}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), (z, z))}
              {\sigma^{\ms{mid}}(u)}
          }
        }
        \\
        &\approx
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
          \letexpr{u}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y), (x^q, x^q))}
            {\sigma^{\ms{mid}}(u)}
        }
        \\
        &\approx
        \letexpr{u}{
          ((\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}
            {(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}(y)}), (x^q, x^q))
          }
          {\sigma^{\ms{mid}}(u)}
        \\
        &\approx
        \letexpr{((u_1, u_2), (u_3, u_4)}{
          ((\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r})), (x^q, x^q))
          }
          {((u_1, u_3), (u_2, u_4))}
        \\
        &\approx
          (\ms{pack}(\Gamma^{\mb{q}_l}), x^q), (\ms{pack}(\Gamma^{\mb{q}_r}), x^q))
        \\
        &\approx
          (\ms{pack}(\Gamma^{\mb{q}_l}, x : A^q), \ms{pack}(\Gamma^{\mb{q}_r}, x : A^q))
        : [\Gamma^{\mb{q}_l}, x : A^q] \otimes [\Gamma^{\mb{q}_r}, x : A^q]
    \end{align*}
    as desired.
  \end{itemize}
  We now wish to show that, given $f \in \ms{Tm}(\mc{R})(A, B)$,
  \begin{equation*}
    \tmeq{\Gamma^{\mb{q}}}{\mc{R
    }}{\letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}
                  {\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}_{\ms{Tm}(\mc{R})}(x)}}{a}{A}
  \end{equation*}
  We proceed by induction on the derivation $\hasty{\Gamma^{\mb{q}}}{}{a}{A}$:
  \begin{itemize}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{x}{A})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot 
      \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{x}{A}}(y)} \\
      &\approx 
      \letexpr{y}{\ms{pack}(\Gamma)^{\mb{q}}}{(\dnt{\cwk{\Gamma^{\mb{q}}}{x : A^1}} ; \lambda)(y)} \\
      &\approx
      \letexpr{y}{
        (\letexpr{z}
          {\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\cwk{\Gamma^{\mb{q}}}{x : A^1}}(z)})}
        {(\lambda (w, u) . u)(y)} \\
      &\approx
      \letexpr{(w, u)}{(x, ())}{u} \approx x : A
    \end{align*}
    as desired.
    \item ($\hasty{\Gamma^{\mb{q}}}{\epsilon}{f\;a}{B}$): we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{f\;a}{B}}(x)}
      \\ &\approx 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}
        {(\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}} ; (\lambda y.f\;y))(x)}
      \\ &\approx
      \letexpr{x}{(\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}})}
        {f\;x} 
      \\ &\approx
      \letexpr{x}{a}{f\;x} \approx f\;a : B
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\letexpr{x}{a}{b}}{B})$: we have
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot 
      \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}
        {\dnt{\hasty{\Gamma^{\mb{q}}}{}{\letexpr{x}{a}{b}}{B}}(y)} \\
      &\approx
      \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{
        (
          \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
          ; [\Gamma^{\mb{q}_l}] \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
          ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
        )(y)
      } \\
      &\approx
      \letexpr{y}{(\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r}))}{
        (
          [\Gamma^{\mb{q}_l}] \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
          ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
        )(y)
      }
      \\
      &\approx
      \letexpr{y}{(\ms{pack}(\Gamma^{\mb{q}_l}), a))}{
        (
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
        )(y)
      }
      \\
      &\approx
      \letexpr{x}{a}{\letexpr{y}{(\ms{pack}(\Gamma^{\mb{q}_l}), x))}{
        (
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
        )(y)
      }}
      \\
      &\approx
      \letexpr{x}{a}{\letexpr{y}{(\ms{pack}(\Gamma^{\mb{q}_l}, x : A)))}{
        (
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
        )(y)
      }}
      \\
      &\approx \letexpr{x}{a}{b} : B
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{()}{\mb{1}})$: we have
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{()}{\mb{1}}}(x)} \\
      &\approx 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{(\dnt{\cwk{\Gamma^{\mb{q}}}{\cdot}})(x)} \\
      &\approx
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{()}
      \approx ()
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{(a, b)}{A \otimes B})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}
        {(a, b)}{A \otimes B}}(x)} \\
      &\approx 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{(
        \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
        ; \dnt{\hasty{\Gamma^{\mb{q}_l}}{}{a}{A}} \ltimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{}{b}{B}}
      )(x)
      } \\
      &\approx
      \letexpr{x}
      {(\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}})}
      {(\dnt{\hasty{\Gamma^{\mb{q}_l}}{}{a}{A}} \ltimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{}{b}{B}})(x)}
      \\
      &\approx
      \letexpr{x}
      {(\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r}))}
      {(\dnt{\hasty{\Gamma^{\mb{q}_l}}{}{a}{A}} \ltimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{}{b}{B}})(x)}
      \\
      &\approx
      (
        \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}_l})}{\dnt{\hasty{\Gamma^{\mb{q}_l}}{}{a}{A}}(x)},
        \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}_r})}{\dnt{\hasty{\Gamma^{\mb{q}_r}}{}{b}{B}}(y)}
      )
      \approx (a, b) : A \otimes B
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\letexpr{(x, y)}{a}{c}}{C})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{z}{\ms{pack}(\Gamma^{\mb{q}})}
        {\dnt{\hasty{\Gamma^{\mb{q}}}{}{\letexpr{(x, y)}{a}{c}}{C}}(z)} \\
      &\approx
      \letexpr{z}{\ms{pack}(\Gamma^{\mb{q}})}{ \\ & \qquad 
        (\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
        ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
        ; \alpha
        ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
        )(z)
      } \\
      &\approx
      \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r}))}{\\ & \qquad ( 
        \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
        ; \alpha
        ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
        )(z)
      } \\
      &\approx
      \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), 
        \letexpr{w}{\ms{pack}(\Gamma^{\mb{q}_r})}
          {
            \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}(w)}
          }
        )
        }{\\ & \qquad (
        \alpha
        ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
        )(z)
      } \\
      &\approx
      \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), a)
        }{(
        \alpha
        ; \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
        )(z)
      }\\
      &\approx
      \letexpr{(z_1, (z_2, z_3))}{(\ms{pack}(\Gamma^{\mb{q}_l}), a)
        }{\letexpr{z}{((z_1, z_2), z_3)}  
          {\dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}(z)}
      } \\
      &\approx
      \letexpr{(z_2, z_3)}{a}{\letexpr{z}{((\ms{pack}(\Gamma^{\mb{q}_l}), z_2), z_3)}  
          {\dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}(z)}
      } \\
      &\approx
      \letexpr{(z_2, z_3)}{a}{\letexpr{z}{\ms{pack}(\Gamma^{\mb{q}_l}, z_2 : A, z_3 : B)}  
          {\dnt{\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}(z)}
      }\\
      &\approx
      \letexpr{(z_2, z_3)}{a}{[z_3/y][z_2/x]c}
      \approx
      \letexpr{(x, y)}{a}{c} : C
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\linl{a}}{A + B})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{\linl{a}}{A + B}}(x)}
      \\ &\approx 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}
        {(\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}} ; \iota_l)(x)}
      \\ &\approx
      \letexpr{x}{(\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}})}
        {\linl{x}} 
      \\ &\approx
      \letexpr{x}{a}{\linl{x}} \approx \linl{a} : A + B
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\linr{b}}{A + B})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{\linr{b}}{A + B}}(x)}
      \\ &\approx 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}
        {(\dnt{\hasty{\Gamma^{\mb{q}}}{}{b}{B}} ; \iota_r)(x)}
      \\ &\approx
      \letexpr{x}{(\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{b}{B}}})}
        {\linr{x}} 
      \\ &\approx
      \letexpr{x}{b}{\linr{x}} \approx \linr{b} : A + B
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\caseexpr{e}{x}{a}{y}{b}}{C})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{z}{\ms{pack}(\Gamma^{\mb{q}})}
        {\dnt{\hasty{\Gamma^{\mb{q}}}{}{\caseexpr{e}{x}{a}{y}{b}}{C}}(z)}
      \\ &\approx 
      \letexpr{z}{\ms{pack}(\Gamma^{\mb{q}})}{(\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
        ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{e}{A + B}}
        ; \delta^{-1} \\ & \qquad
        ; [
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}},
          \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
        ])(z)}
      \\ &\approx
      \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r}))}{(
        \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{e}{A + B}}
        ; \delta^{-1} \\ & \qquad
        ; [
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}},
          \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
        ])(z)}
      \\ &\approx
      \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), 
        \letexpr{w}{\ms{pack}(\Gamma^{\mb{q}_r})}{
          \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{e}{A + B}}(w)})}{(  \\ & \qquad
        \delta^{-1}
        ; [
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}},
          \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
        ])(z)}
      \\ &\approx
      \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), e)}{(
        \delta^{-1}
        ; [
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}},
          \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
        ])(z)}
      \\ &\approx
      \caseexpr{e \\ & \qquad\;}
        {x}{\letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}_l}), x)}{
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}}(w)} \\ & \qquad}
        {y}{\letexpr{}{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}{
          \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}}}
      \\ &\approx
      \caseexpr{e \\ & \qquad}
        {x}{\letexpr{w}{\ms{pack}(\Gamma^{\mb{q}_l}, x : A))}{
          \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}}(w)} \\ & \qquad}
        {y}{\letexpr{}{\ms{pack}(\Gamma^{\mb{q}_l}), y : B)}{
          \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}}}
      \\ &\approx
      \caseexpr{e}{x}{a}{y}{b} : C
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\labort{a}}{A})$: we have that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{\labort{a}}{A}}(x)}
      \\ &\approx 
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}
        {(\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{\mb{0}}} ; 0_A)(x)}
      \\ &\approx
      \letexpr{x}{(\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}
          {\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{\mb{0}}}})}
        {\labort{x}} 
      \\ &\approx
      \letexpr{x}{a}{\labort{x}} \approx \labort{a} : A
    \end{align*}
    \item $(\hasty{\Gamma^{\mb{q}}}{}{\liter{a}{x}{b}}{B})$: we begin by noting that
    \begin{align*}
    \Gamma^{\mb{q}_l}, y : A &\vdash_\bot
      \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}{ \\ & \qquad
        (
          \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
          ; \alpha
          ; [\Gamma^{\mb{q}_l}] 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
          ; \delta^{-1}
        )(w)
      } \\
      % &\approx
      % \letexpr{w}{(\letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}
      %   {(\dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A)(z)})}{ \\ & \qquad (
      %   \alpha
      %   ; [\Gamma^{\mb{q}_l}] 
      %     \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      %   ; \delta^{-1}
      % )(w)} \\      
      &\approx
      \letexpr{w}{((\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_l})), y)}{ (
        \alpha
        ; [\Gamma^{\mb{q}_l}] 
          \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
        ; \delta^{-1}
      )(w)} \\  
      &\approx
      \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}_l}), (\ms{pack}(\Gamma^{\mb{q}_l}), y))}{ (
        [\Gamma^{\mb{q}_l}] \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
        ; \delta^{-1}
      )(w)} \\  
      &\approx
      \letexpr{w}{(\ms{pack}(\Gamma^{\mb{q}_l}), 
          \letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}
            {\dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}(z)}
        )}{\delta^{-1}(w)} \\
      &\approx
      \caseexpr{(\letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}
            {\dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}(z)}
        )) \\ & \qquad}{w_l}{\linl{(\ms{pack}(\Gamma^{\mb{q}_l}), w_l)}}
                       {w_r}{(\ms{pack}(\Gamma^{\mb{q}_l}), w_r)} \\
      &\approx
      \caseexpr{(\letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}, y : A^q)}
            {\dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}(z)}
        )) \\ & \qquad}{w_l}{\linl{(\ms{pack}(\Gamma^{\mb{q}_l}), w_l)}}
                       {w_r}{(\ms{pack}(\Gamma^{\mb{q}_l}), w_r)} \\
      &\approx
      \caseexpr{[y/x]b}{w_l}{\linl{(\ms{pack}(\Gamma^{\mb{q}_l}), w_l)}}
                       {w_r}{(\ms{pack}(\Gamma^{\mb{q}_l}), w_r)}
    \end{align*}
    It follows by uniformity, since $(\ms{pack}(\Gamma^{\mb{q}_l}), y)$ is pure, that
    \begin{align*}
      \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{y}{a}{\liter{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}{w}{ \\ & \qquad
        (
          \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
          ; \alpha
          ; [\Gamma^{\mb{q}_l}] 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
          ; \delta^{-1}
        )(w)
      }} \\
      &\approx
      \letexpr{u}{\liter{a}{x}{b}}{(\ms{pack}(\Gamma^{\mb{q}_l}), u)}
    \end{align*}
    and therefore that
    \begin{align*}
    \Gamma^{\mb{q}} &\vdash_\bot
      \letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{\dnt{\hasty{\Gamma^{\mb{q}}}{}{\liter{a}{x}{b}}{B}}(x)}
      \\ &\approx 
      \letexpr{z}{\ms{pack}(\Gamma^{\mb{q}})}
        {(
          \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
          ; [\Gamma^{\mb{q}_l}] \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
          ;
      \\ & \qquad    
        (
          \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
          ; \alpha
          ; [\Gamma^{\mb{q}_l}] 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
          ; \delta^{-1}
        )^\dagger  
        ;
      \\ & \qquad
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}
      % \\ &\approx 
      % \letexpr{z}{
      %     (\letexpr{y}{\ms{pack}(\Gamma^{\mb{q}})}
      %        {\dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}})}
      %   {(
      %     [\Gamma^{\mb{q}_l}] \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} ;
      % \\ & \qquad    
      %   (
      %     \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
      %     ; \alpha
      %     ; [\Gamma^{\mb{q}_l}] 
      %       \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      %     ; \delta^{-1}
      %   )^\dagger  
      %   ;
      % \\ & \qquad
      %   \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
      %   ; \rho
      % )(z)}
      \\ &\approx 
      \letexpr{z}{
          (\ms{pack}(\Gamma^{\mb{q}_l}), \ms{pack}(\Gamma^{\mb{q}_r}))}
        {(
          [\Gamma^{\mb{q}_l}] \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} ;
      \\ & \qquad    
        (
          \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
          ; \alpha
          ; [\Gamma^{\mb{q}_l}] 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
          ; \delta^{-1}
        )^\dagger  
        ;
      \\ & \qquad
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}
      % \\ &\approx 
      % \letexpr{z}{
      %     (\ms{pack}(\Gamma^{\mb{q}_l}), 
      %       \letexpr{y}{\ms{pack}(\Gamma^{\mb{q}_r})}
      %         {\dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}})}
      %   {(
      % \\ & \qquad    
      %   (
      %     \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
      %     ; \alpha
      %     ; [\Gamma^{\mb{q}_l}] 
      %       \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      %     ; \delta^{-1}
      %   )^\dagger  
      %   ;
      % \\ & \qquad
      %   \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
      %   ; \rho
      % )(z)}
      \\ &\approx 
      \letexpr{z}{
          (\ms{pack}(\Gamma^{\mb{q}_l}), a)}
        {(
      \\ & \qquad    
        (
          \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
          ; \alpha
          ; [\Gamma^{\mb{q}_l}] 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
          ; \delta^{-1}
        )^\dagger  
        ;
      \\ & \qquad
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}
      \\ &\approx 
      \letexpr{z}{(
          \letexpr{y}{(\ms{pack}(\Gamma^{\mb{q}_l}), a)}{
            \\ & \qquad \qquad
            (
              \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
              ; \alpha
              ; [\Gamma^{\mb{q}_l}] 
                \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
              ; \delta^{-1}
            )^\dagger(y)
          }
        )}
        { \\ & \qquad (
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}
      \\ &\approx 
      \letexpr{z}{(
          \letexpr{y}{a}{\liter{(\ms{pack}(\Gamma^{\mb{q}_l}), y)}{w}{ \\ & \qquad \qquad
            (
              \dnt{\qsp{\Gamma}{\mb{q}_l}{\mb{q}_l}{\mb{q}_l}} \otimes A 
              ; \alpha
              ; [\Gamma^{\mb{q}_l}] 
                \otimes \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
              ; \delta^{-1}
            )(w)
          }}
        )}
        { \\ & \qquad (
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}
      \\ &\approx 
      \letexpr{z}{(
          \letexpr{u}{\liter{a}{x}{b}}{(\ms{pack}(\Gamma^{\mb{q}_l}), u)}
        )}
        {(
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}
      \\ &\approx 
      \letexpr{u}{\liter{a}{x}{b}}{\letexpr{z}{(\ms{pack}(\Gamma^{\mb{q}_l}), u)}{(
        \dnt{\cwk{\Gamma^{\mb{q}_l}}{\cdot}} \otimes B
        ; \rho
      )(z)}}
      \\ &\approx 
      \letexpr{u}{\liter{a}{x}{b}}{\letexpr{z}{((), u)}{\rho(z)}}
      \\ &\approx 
      \letexpr{u}{\liter{a}{x}{b}}{u}
      \approx \liter{a}{x}{b} : B
    \end{align*}
    as desired.
  \end{itemize}
\end{proof}
Completeness follows directly from the above lemma, since, given 
\begin{align*}
  &\dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}_{\ms{Tm}(\mc{R})} \tref 
  \dnt{\hasty{\Gamma^{\mb{q}}}{}{b}{A}}_{\ms{Tm}(\mc{R})} \\
  &\implies
  \forall (\lambda x. a_x) \in \dnt{\hasty{\Gamma^{\mb{q}}}{}{a}{A}}_{\ms{Tm}(\mc{R})},
  (\lambda x. b_x) \in \dnt{\hasty{\Gamma^{\mb{q}}}{}{b}{A}}_{\ms{Tm}(\mc{R})} . 
  \tmle{x : [\Gamma^{\mb{q}}]}{\mc{R}}{a_x}{b_x}{A} \\
  &\implies \tmle{\Gamma^{\mb{q}}}{\mc{R}}
    {\letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{a_x}}
    {\letexpr{x}{\ms{pack}(\Gamma^{\mb{q}})}{b_x}}
    {A} \\
  &\implies \tmle{\Gamma^{\mb{q}}}{\mc{R}}
    {a}
    {b}
    {A}
\end{align*}
as desired.

% \section{Model Category}

% \label{apx:model-cats}

% In this section, we will build up the theory of the category of \subiterexp{} models and signatures,
% which allows us to frame other results, such as completeness, much more cleanly. In particular, we
% will define and prove some properties about:
% \begin{itemize}
%   \item The category of \subiterexp{} signatures
%   \item The category of \subiterexp{} refinement theories, and the full subcategory of refinement
%   theories of a signature $\mc{S}$
%   \item The category of \subiterexp{} models, and the full subcategories of models of a given
%   signature $\mc{S}$ and a given refinement theory $\mc{R}$
% \end{itemize}
% \TODO{names}

% \subsection{Category of Signatures}

% \TODO{definition:}

% \TODO{a morphism of signatures maps base types to types, instructions to programs, which are arrows
% in the syntactic model}

% \TODO{a morphism is type preserving if it is the identity on types (injection); this is a
% subcategory}

% \TODO{a morphism is strict or something if it's just instructions to instructions; this is a wide
% subcategory}

% \TODO{initial object is the empty signature}

% \TODO{coproduct of signatures is just coproduct on types and on instructions}

% \TODO{type preserving subcategory has union on types, coproduct on instructions; initial object is
% again empty signature}

% \subsection{Category of Refinement Theories}

% \TODO{definition}

% \TODO{
%   a morphism is a refinement preserving morphism of signatures; 
%   TODO: is it enough to see if $T$ preserves $\mc{R}$?
% }

% \TODO{initial object for any/all signatures is the empty theory}

% \TODO{coproducts of refinement theories?}

% \subsection{Category of Models}

% \TODO{definition; obvious morphism of models}

% \TODO{initial objects (syntactic models) for each wide subcategory of a given rewrite theory
% $(\mc{S}, \mc{R})$}

% \TODO{functor from category of refinement theories to initial objects; \textit{question: is this
% faithful? full?}}

% \TODO{\emph{the} initial model of SSA: tfw is it just partial functions on bitvectors?}

% \section{SSA Metatheory}

% In this section, we give some basic metatheoretic properties of SSA used in
% Appendix~\ref{apx:ssa-roundtrip}. We begin by introducing syntax for \emph{generalized
% \isotopessa{}} in Figure~\ref{fig:gen-ssa-syntax}, which has the same syntax as \isotopessa{} except
% that: 
% \begin{itemize}
%   \item The syntactic categories of regions, where-blocks, and terminators are collapsed
%   \item Instructions are replaced with arbitrary expressions
% \end{itemize}
% A quick glance at the grammar in Figure~\ref{fig:ssa-syntax} shows that this is a strict superset of
% SSA. We simply give generalized \isotopessa{} the same typing rules (namely, those in
% Figure~\ref{fig:ssa-typing}) and semantics as \isotopessa{} (namely, that in
% Figure~\ref{fig:ssa-densem}).

% All our metatheoretic results about \isotopessa{} carry over to generalized \isotopessa{}; we will
% make use of this fact to 

% \begin{figure}
%   \begin{grammar}
%     <\(r, s, t, \kappa, \tau\)> ::=
%       \;|\; \(\letstmt{x}{a}{t}\)
%       \;|\; \(\letstmt{(x, y)}{a}{t}\)
%       \alt \(\awhere{s}{L}\) \;|\; \(\cwhere{s}{L}\)
%       \alt \(\brb{\ell}{a}\)
%       \;|\; \(\casestmt{a}{y}{s}{z}{t}\)

%     <\(L\)> ::= \(\cdot\) \;|\; \(L, \wbranch{\ell}{x}{A}\)
%   \end{grammar}
%   \caption{Grammar for generalized \isotopessa{} programs.}
%   \Description{}
%   \label{fig:gen-ssa-syntax}
% \end{figure}

% \TODO{SSA weakening}

% \TODO{SSA semantic weakening}

\section{Compiling Expressions to SSA}

\label{apx:ssa-roundtrip}

In this section, we give a compilation function $\ms{SSA}_\ell$ that compiles a \subiterexp{} terms 
to an SSA program returning its result as an argument to output label $\ell$. We will then show
that this function is \emph{semantics-preserving}, i.e. that it satisfies the following property:
$$
\dnt{
  \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}}
  {\ell(A)^{\mb{0}}}
} = \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} ; \alpha ; \iota_r
$$
Here, the associator $\alpha$ takes $\dnt{A}$ to $\dnt{\Gamma^{\mb{0}}} \otimes \dnt{A}$ (the latter
being a tensor product of monoidal units), which $\iota_r$ then takes to
$\dnt{\ltoty{\Gamma}{\ell(A)^{\mb{0}}}} = \mb{0} + \dnt{\Gamma^{\mb{0}}} \otimes \dnt{A}$. We will
do so by requiring the slightly stronger property that, for all
$\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}$, we have
$$
  \dnt{
    \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}}
    {\ell(A)^{\mb{q}_l}}
  } 
  = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
  ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} 
  ; \iota_r
$$ 
As this transformation is complicated to state and verify for general expressions, we will instead
define \emph{ANF}, and, after showing how every expression can be compiled to an equivalent
expression in ANF, define $\ms{SSA}_\ell$ by induction over such expressions.

\subsection{ANF Expressions}

We begin by defining ANF expressions $P, Q, R$ using the grammar in Figure~\ref{fig:anf-syntax};
these are treated as a subset of \subiterexp{} expressions. In particular, an ANF program consists
of a sequence of instructions of the form $\letexpr{x}{I}{P}$ (along with destructurings
$\letexpr{(x, y)}{o}{P}$), where each instruction $I$ either calls into a sub-program or returns the
value of an operation $o$. Our goal is to define a function $\toanf{a}$ on terms such that, for
all well-typed terms $a$,
\begin{equation*}
  \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\toanf{a}}{a}{A}
\end{equation*}
Rather than do so directly, we will instead define a transformation $\anflet{x}{a}{P}$ which, given
an ANF program $P$ and a term $a$, returns an ANF program such that
\begin{equation*}
  \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\anflet{x}{a}{P}}{\letexpr{x}{a}{P}}{A}
\end{equation*}
We can then define $\toanf{a} := \anflet{x}{a}{x}$; note that we trivially have that, for any $a$,
$\anflet{x}{a}{x} \approx \letexpr{x}{a}{x} \approx a \implies \toanf{x} \approx a$ by definition.
We can now proceed to define $\anflet{x}{a}{P}$ by induction on terms $a$ as follows:
\begin{align*}
  (\anflet{x}{o}{P}) &:= (\letexpr{x}{o}{P}) \text{ where } o \text{ is a valid instruction} \\
  (\anflet{x}{f\;a}{P}) &:= (\anflet{x_a}{a}{\letexpr{x}{f\;x}{P}}) \\
  (\anflet{x}{\letexpr{y}{a}{b}}{P}) &:= (\anflet{y}{a}{\anflet{x}{b}{P}}) \\
  (\anflet{x}{(a, b)}{P}) &:= (\anflet{x_a}{a}{\anflet{x_b}{b}{\letexpr{x}{(a, b)}{P}}}) \\
  (\anflet{x}{\linl{a}}{P}) &:= (\anflet{x_a}{a}{\letexpr{x}{\linl{x_a}}{P}}) \\
  (\anflet{x}{\linr{a}}{P}) &:= (\anflet{x_a}{a}{\letexpr{x}{\linr{x_a}}{P}}) \\
  (\anflet{x}{\caseexpr{e}{y}{a}{z}{b}}{P}) 
    &:= (\anflet{x_e}{e}{\letexpr{x}{\caseexpr{x_e \\ & \qquad}{y}{\toanf{a}}{z}{\toanf{b}}}}{P}) \\
  (\anflet{x}{\labort{a}}{P}) &:= (\anflet{x_a}{a}{\letexpr{x}{\labort{x_a}}{P}}) \\
  (\anflet{x}{\liter{a}{y}{b}}{P}) 
    &:= (\anflet{x_a}{a}{\letexpr{x}{\liter{x_a}{y}{\toanf{b}}}{P}})
\end{align*}
We can trivially verify each case by simply applying the binding rule for each term-former, followed
by the inductive hypothesis. For example, we have that
\begin{align*}
  \Gamma^{\mb{q}} & \vdash_\bot
    \letexpr{x}{\liter{a}{y}{b}}{P} \approx \letexpr{x}{(\letexpr{x_a}{a}{\liter{x_a}{y}{b}})}{P} 
      & (\brle{iter-bind}) \\
    &\approx \letexpr{x_a}{a}{\letexpr{x}{\liter{x_a}{y}{b}}{P}}
      & (\brle{let-let$_1$}) \\
    & \approx \anflet{x_a}{a}{\letexpr{x}{\liter{x_a}{y}{b}}{P}} & (\text{by induction}) \\
    & \approx \anflet{x_a}{a}{\letexpr{x}{\liter{x_a}{y}{\toanf{b}}}{P}} & (\text{by induction}) \\
    & \approx \anflet{x}{\liter{a}{y}{b}}{P} & (\text{by definition})
\end{align*}

\begin{figure}
  \begin{grammar}
    <\(I, J\)> ::= 
    \(o\)
    \;|\; \(\caseexpr{o}{x}{P}{y}{Q}\)
    \;|\; \(\liter{o}{x}{P}\)

    <\(P, Q, R\)> ::=
    \(o\)
    \;|\; \(\letexpr{x}{I}{P}\)
    \;|\; \(\letexpr{(x, y)}{o}{P}\)
    
    <\(q\)> ::= \(\zeroq\) | \(\oneq\) | \(\cpyq\) | \(\delq\) | \(\topq\)

    <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, x : A\)

    <\(\mb{q}\)> ::= \(\cdot\) \;|\; \(\mb{q}, q\)
  \end{grammar}
  \caption{Syntax for \subiterexp{} terms in ANF} \Description{}
  \label{fig:anf-syntax}
\end{figure}

\subsection{ANF to SSA}

We begin by stating a few metatheoretic results:
\begin{lemma}[Label Weakening]
  Given a label-weakening $\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}$,
  \begin{itemize}
    \item If $\lwk{\Gamma}{\ms{L}'^{\mb{Q}'}}{\ms{L}''^{\mb{Q}''}}$, then 
      $\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}''^{\mb{Q}''}}$ with
      $$
      \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}''^{\mb{Q}''}}}
      = \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
      ; \dnt{lwk{\Gamma}{\ms{L}'^{\mb{Q}'}}{\ms{L}''^{\mb{Q}''}}}
      $$
    \item If $\haslb{\Gamma^{\mb{q}}}{\epsilon}{s}{\ms{L}^{\mb{Q}}}$ and , we have that
    $\haslb{\Gamma^{\mb{q}}}{\epsilon}{s}{\ms{L}'^{\mb{Q}'}}$ with
    $$
    \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{s}{\ms{L}'^{\mb{Q}'}}}
    = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{s}{\ms{L}^{\mb{Q}}}}
    ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    $$
  \end{itemize}
  
\end{lemma}
\begin{proof}
  We begin by noting that, via a straightforward induction, we have that
  $$
      \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}''^{\mb{Q}''}}}
      = \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
      ; \dnt{lwk{\Gamma}{\ms{L}'^{\mb{Q}'}}{\ms{L}''^{\mb{Q}''}}}
  $$
  and
  \begin{equation*}
  \dnt{\lwk{\Gamma, x : A}{\ms{L}^{\zeroqv{\mb{Q}}}}{\ms{L}'^{\zeroqv{\mb{Q}'}}}} 
  ; \alpha^\downarrow
  =
  \alpha^\downarrow ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
  \end{equation*}
  We now proceed by induction on the derivation of
  $\haslb{\Gamma^{\mb{q}}}{\epsilon}{s}{\ms{L}^{\mb{Q}}}$:
  \begin{itemize}
    \item ($\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell}{a}}{\ms{L}^{\mb{Q}}}$):
    we have
    \begin{align*}
    &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell}{a}}{\ms{L}'^{\mb{Q}'}}} \\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} 
      ; \iota_r
      ; \dnt{\lwk{\Gamma}{\ell(A)^{\mb{q}_l}}{\ms{L}'^{\mb{q'}}}} \\ 
    &\approx \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} 
      ; \iota_r
      ; \dnt{\lwk{\Gamma}{\ell(A)^{\mb{q}_l}}{\ms{L}^{\mb{q}}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} \\
    &\approx \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell}{a}}{\ms{L}^{\mb{Q}}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    \end{align*}
    \item ($\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{x}{o}{t}}{\ms{L}^{\mb{Q}}}$):
    we have by induction that
    \begin{align*}
    &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{x}{o}{t}}{\ms{L}'^{\mb{Q}'}}} \\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A}}
      ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{t}{\ms{L}'^{\mb{Q}'}}}\\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A}}
      ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{t}{\ms{L}^{\mb{Q}}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} \\
    &= \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{x}{o}{t}}{\ms{L}^{\mb{Q}}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    \end{align*}
    \item ($\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{(x, y)}{o}{t}}{\ms{L}^{\mb{Q}}}$):
    we have by induction that
    \begin{align*}
    &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{x}{o}{t}}{\ms{L}'^{\mb{Q}'}}} \\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A \otimes B}}
      ; \alpha ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{t}{\ms{L}'^{\mb{Q}'}}}\\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A \otimes B}}
      ; \alpha ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{t}{\ms{L}^{\mb{Q}}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} \\
    &= \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letstmt{(x, y)}{o}{t}}{\ms{L}^{\mb{Q}}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    \end{align*}
    \item
    ($\haslb{\Gamma^{\mb{q}}}{\epsilon}{\casestmt{o}{x}{\tau_l}{y}{\tau_r}}{\ms{L}^{\mb{Q}}}$):
    we have by induction that
    \begin{align*}
    &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\casestmt{o}{x}{\tau_l}{y}{\tau_r}}{\ms{L}'^{\mb{Q}'}}} 
      \\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A + B}}
      ; \\ & \qquad [
      \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{\tau_l}{\ms{L}'^{\zeroqv{\mb{Q}'}}}}
        ; \alpha^\downarrow,
      \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{\tau_r}{\ms{L}'^{\zeroqv{\mb{Q}'}}}}
        ; \alpha^\downarrow
    ] \\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A + B}}
      ; [ \\ & \qquad
      \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{\tau_l}{\ms{L}^{\zeroqv{\mb{Q}}}}}
        ; \dnt{\lwk{\Gamma, x : A}{\ms{L}^{\zeroqv{\mb{Q}}}}{{\ms{L}'^{\zeroqv{\mb{Q}'}}}}}
        ; \alpha^\downarrow, \\ & \qquad
      \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{\tau_r}{\ms{L}^{\zeroqv{\mb{Q}}}}}
        ; \dnt{\lwk{\Gamma, y : B}{\ms{L}^{\zeroqv{\mb{Q}}}}{{\ms{L}'^{\zeroqv{\mb{Q}'}}}}}
        ; \alpha^\downarrow
    ]\\
    &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A + B}}
      ; [ \\ & \qquad
      \dnt{\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{\tau_l}{\ms{L}^{\zeroqv{\mb{Q}}}}}
        ; \alpha^\downarrow
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\zeroqv{\mb{Q}}}}{{\ms{L}^{\zeroqv{\mb{Q}'}}}}}, 
      \dnt{\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{\tau_r}{\ms{L}^{\zeroqv{\mb{Q}}}}}
        ; \alpha^\downarrow
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{{\ms{L}'^{\mb{Q}'}}}}
    ] \\
    &= \dnt{
      \haslb{\Gamma^{\mb{q}}}{\epsilon}{\casestmt{o}{x}{\tau_l}{y}{\tau_r}}{\ms{L}^{\mb{Q}}}
    } ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{{\ms{L}'^{\mb{Q}'}}}}
    \end{align*}
    \item ($\haslb{\Gamma^{\mb{q}}}{\epsilon}{\awhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}$): we have
    \begin{align*}
    &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\awhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}'^{\mb{Q}'}}} \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}} 
      ; \alpha^+
      ; [
        \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}},
        [
          \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
            {\ms{L}'^{\zeroqv{\mb{Q}'}}}} ; \alpha^\downarrow,
        ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}''}}
      ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}''}}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; \\ &\qquad [
        \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}},
        [
          \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
            {\ms{L}^{\zeroqv{\mb{Q}}}}} 
          ; \dnt{\lwk{\Gamma, x_i : A_i}{\ms{L}^{\zeroqv{\mb{Q}}}}{\ms{L}'^{\zeroqv{\mb{Q}'}}}}
          ; \alpha^\downarrow,
        ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}''}}
      ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} 
        + \dnt{\ltoty{\Gamma}{\ms{R}^{\mb{Q}''}}}
      ; \\ &\qquad [
        \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}},
        [
          \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
            {\ms{L}^{\zeroqv{\mb{Q}}}}}
          ; \alpha^\downarrow
          ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} ,
        ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}''}}
      ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; \\ &\qquad [
        \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} ,
        [
          \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
            {\ms{L}^{\zeroqv{\mb{Q}}}}}
          ; \alpha^\downarrow
          ,
        ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}''}}
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
      ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; [
        \dnt{\ms{id} ,
        [
          \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
            {\ms{L}^{\zeroqv{\mb{Q}}}}}
          ; \alpha^\downarrow
          ,
        ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}''}}
      ] ; \lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
      \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\awhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}} ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    \end{align*}
    as desired.
    \item ($\haslb{\Gamma^{\mb{q}}}{\epsilon}{\cwhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}$):
    we have
    \begin{align*}
    & \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\cwhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}'^{\mb{Q}'}}} \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}
      {\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}} ; \alpha^+ ; [
      \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}},
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}'^{\zeroqv{\mb{Q}'}}, \ms{R}^{\zeroqv{\mb{Q}''}}}} ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
    ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}''}}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; \\ & \qquad [
      \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}},
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}''}}}} 
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}''}}
            {\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
        ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
    ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}''}}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; \\ & \qquad [
      \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}},
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}''}}}} 
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}, \ms{R}^{\mb{Q}''}}
            {\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
        ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
    ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} 
        + \dnt{\ltoty{\Gamma}{\ms{R}^{\mb{Q}''}}}
      ; [
      \ms{id}_{\dnt{\ltoty{\Gamma}{\ms{L}'^{\mb{Q}'}}}}, \\ & \qquad
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}''}}}}
        ; \alpha^\downarrow ; \alpha^+,
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} 
        + \dnt{\ltoty{\Gamma}{\ms{R}^{\mb{Q}''}}}
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
    ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; [
      \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} , \\ & \qquad
      ([
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}''}}}}
        ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}} 
        ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} 
        + \dnt{\ltoty{\Gamma}{\ms{R}^{\mb{Q}''}}})^\dagger
    ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; [
      \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} , \\ & \qquad
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}''}}}}
        ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
      ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    ] \\
    & = \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\kappa}{\ms{L}'^{\mb{Q}'}, \ms{R}^{\mb{Q}''}}}
      ; \alpha^+
      ; [
      \ms{id} ,
      [
        \dnt{\hasty{\Gamma^{\mb{q}_i}, x_i : A_i}{\epsilon}{t_i}
          {\ms{L}^{\zeroqv{\mb{Q}}}, \ms{R}^{\zeroqv{\mb{Q}''}}}}
        ; \alpha^\downarrow ; \alpha^+,
      ]_{\ell_i(A_i)^{\mb{q}_i} \in \ms{R}^{\mb{Q}'}}^\dagger
    ] ; \\ & \qquad \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}} \\
    &= \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\cwhere{\kappa}{(\wbranch{\ell_i}{x_i}{t_i},)_i}}
      {\ms{L}^{\mb{Q}}}} ; \dnt{\lwk{\Gamma}{\ms{L}^{\mb{Q}}}{\ms{L}'^{\mb{Q}'}}}
    \end{align*}
    as desired.
  \end{itemize}
\end{proof}
% We now note a few identities:
% \begin{itemize}
%   \item Given $\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{P}{A}$ with
%   $$
%   \dnt{
%     \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}}
%     {\ell(A)^{\mb{q}_l}}
%   } 
%   = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
%   ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} 
%   ; \iota_r
%   $$ 
%   and
%   \begin{multline*}
%   \dnt{
%     \haslb{\Gamma^{\mb{q}}, y : B^0}{\epsilon}
%       {\tossa{\ell}{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}}
%     {\ell(A)^{\mb{q}_l, 0}}
%   } 
%   \\ = \dnt{\qsp{\Gamma}{\mb{q}, y: B^0}{\mb{q}_l, 0}{\mb{q}_r, 0}}
%   ; (\dnt{\Gamma^{\mb{q}_l}} \otimes I) 
%     \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y: B^0}{\epsilon}{a}{A}} 
%   ; \iota_r
%   \end{multline*}
%   we have that
%   \begin{align*}
%   & \dnt{
%     \haslb{\Gamma^{\mb{q}}, y : B^0}{\epsilon}
%       {\tossa{\ell}{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}}
%     {\ell(A)^{\mb{q}_l, 0}}
%   } ; \alpha^\downarrow \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}, y: B^0}{\mb{q}_l, 0}{\mb{q}_r, 0}}
%   ; (\dnt{\Gamma^{\mb{q}_l}} \otimes I) 
%     \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y: B^0}{\epsilon}{a}{A}} 
%   ; \iota_r ; \alpha^\downarrow \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}, y: B^0}{\mb{q}_l, 0}{\mb{q}_r, 0}}
%   ; \alpha 
%     \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y: B^0}{\epsilon}{a}{A}} 
%   ; \iota_r \\
%   &= \alpha
%   ; \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
%   ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} 
%   ; \iota_r \\
%   &= \alpha ; \dnt{
%     \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}}
%     {\ell(A)^{\mb{q}_l}}
%   }
%   \end{align*}
% \end{itemize}
We may now define $\tossa{\ell}{P}$ by induction on ANF programs $P$ as follows:
\begin{itemize}
  \item (Valid operations $o$): we define
  $(\tossa{\ell}{o}) := \brb{\ell}{o}$. This has the desired semantics, since
  \begin{align*}
    \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell}{o}}{\ell(A)^{\mb{0}}}}
    & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
      ; \dnt{\Gamma^{\mb{q}_r}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{o}{A}} 
      ; \iota_r
      ; \cancel{\dnt{\lwk{\Gamma}{\ell(A)^{\mb{q}_l}}{\ell(A)^{\mb{q}_l}}}}
  \end{align*}
  \item ($\letexpr{x}{o}{P}$): we define
  $(\tossa{\ell}{\letexpr{x}{o}{P}}) := \letstmt{x}{o}{\tossa{\ell}{P}}$; we verify this has
  the correct semantics by induction as follows:
  \begin{align*}
  & \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\letexpr{x}{o}{P}}}{\ell(B)^{\mb{q}_1}}} \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}} 
    ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
    ; \dnt{\haslb{\Gamma^{\mb{q}_{12}}, x : A}{\epsilon}{\tossa{\ell}{P}}{\ell(B)^{\mb{q}_1, 0}}}
    ; \alpha^\downarrow \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}} 
    ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}\
    ; \dnt{\qsp{\Gamma}{\mb{q}_{12}, x : A}{\mb{q}_1, 0}{\mb{q}_2, \omega}}
  \\ & \quad
    ; (\dnt{\Gamma^{\mb{q}_1}} \otimes I) \otimes 
      \dnt{\hasty{\Gamma^{\mb{q}_2}, x : A}{\epsilon}{P}{B}}
    ; \iota_r
    ; \alpha^\downarrow \\ 
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}} 
    ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} 
      \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
    ; \alpha
    ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : A}{\epsilon}{P}{B}}
    ; \iota_r \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_1}{\mb{q}_{23}}}
    ; \dnt{\Gamma^{\mb{q}_1}} \otimes (
      \dnt{\qsp{\Gamma}{\mb{q}_{23}}{\mb{q}_2}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{3}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; \dnt{\hasty{\Gamma^{\mb{q}_2}, x : A}{\epsilon}{P}{B}}
    )
    ; \iota_r \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_1}{\mb{q}_{23}}}
    ; \dnt{\Gamma^{\mb{q}_1}} \otimes (
      \dnt{\hasty{\Gamma^{\mb{q}_{23}}}{\epsilon}{\letexpr{x}{o}{P}}{B}}
    )
    ; \iota_r
  \end{align*}
  as desired.
  \item ($\letexpr{(x, y)}{o}{P}$): we define
  $(\tossa{\ell}{\letexpr{(x, y)}{o}{P}}) := \letstmt{(x, y)}{o}{\tossa{\ell}{P}}$; we verify this
  has the correct semantics by induction as follows:
  \begin{align*}
  & \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}
    {\tossa{\ell}{\letexpr{(x, y)}{o}{P}}}{\ell(B)^{\mb{q}_1}}} \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}} 
    ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A \otimes B}}
    ; \dnt{\haslb{\Gamma^{\mb{q}_{12}}, x : A, y : B}{\epsilon}{\tossa{\ell}{P}}
      {\ell(C)^{\mb{q}_1, 0, 0}}}
    ; \alpha^\downarrow ; \alpha^\downarrow \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}} 
    ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A \otimes B}}\
    ; \dnt{\qsp{\Gamma}{\mb{q}_{12}, x : A, y : B}{\mb{q}_1, 0, 0}{\mb{q}_2, \omega, \omega}}
  \\ & \quad
    ; (\dnt{\Gamma^{\mb{q}_1}} \otimes I \otimes I) \otimes 
      \dnt{\hasty{\Gamma^{\mb{q}_2}, x : A, y : B}{\epsilon}{P}{C}}
    ; \iota_r
    ; \alpha^\downarrow
    ; \alpha^\downarrow \\ 
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}} 
    ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} 
      \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A \otimes B}}
    ; \alpha  \\ & \quad
    ; \dnt{\Gamma^{\mb{q}_1}} \otimes 
      \dnt{\hasty{\Gamma^{\mb{q}_2}, x : A, y : B}{\epsilon}{P}{C}}
    ; \iota_r \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_1}{\mb{q}_{23}}}
    ; \dnt{\Gamma^{\mb{q}_1}} \otimes \\ & \qquad (
      \dnt{\qsp{\Gamma}{\mb{q}_{23}}{\mb{q}_2}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{3}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A \otimes B}}
      ; \alpha
      ; \dnt{\hasty{\Gamma^{\mb{q}_2}, x : A, y : B}{\epsilon}{P}{C}}
    )
    ; \iota_r \\
  & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_1}{\mb{q}_{23}}}
    ; \dnt{\Gamma^{\mb{q}_1}} \otimes (
      \dnt{\hasty{\Gamma^{\mb{q}_{23}}}{\epsilon}{\letexpr{x}{o}{P}}{C}}
    )
    ; \iota_r
  \end{align*}
  \item ($\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{x}{\caseexpr{o}{y}{P}{z}{Q}}{R}}{D}$): we
  define
  \begin{align*}
    (\tossa{\ell}{\letexpr{x}{\caseexpr{o}{y}{P}{z}{Q}}{R}})
    & := \awhere{(\awhere{\casestmt{o}{y}{\brb{\ell_l}{y}}{z}{\brb{\ell_r}{z}} \\ & \qquad }{
      \\ & \quad \qquad
      \wbranch{\ell_l}{y}{\tossa{\ell_o}{P}},
      \\ & \quad \qquad
      \wbranch{\ell_r}{z}{\tossa{\ell_o}{Q}})
    } \\ & \quad }{
      \\ & \qquad
      \wbranch{\ell_o}{x}{\tossa{\ell}{R}}
    }
  \end{align*}
  We verify the semantics by induction as follows:
  \begin{align*}
    & \dnt{
      \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\letexpr{x}{\caseexpr{o}{y}{P}{z}{Q}}{R}}}
      {\ell(D)^{\mb{q}_1}}
    } \\
    & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{123}}{\mb{q}_4}} 
      ; \dnt{\Gamma^{\mb{q}_{123}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_4}}{\epsilon}{o}{A + B}}
      ; \delta^{-1} ; [
      \\ & \quad \qquad
        \dnt{\haslb{\Gamma^{\mb{q}_{123}}, y : A}{\epsilon}{\brb{\ell_l}{y}}
          {
            \ell(D)^{\mb{q}_1, 0}, \ell_o(C)^{\mb{q}_{12}, 0}, 
            \ell_l(A)^{\mb{q}_{123}, 0}}, \ell_r(B)^{\mb{q}_{123}, 0}} 
          ; \alpha^\downarrow,
      \\ & \quad \qquad
        \dnt{\haslb{\Gamma^{\mb{q}_{123}}, z : B}{\epsilon}{\brb{\ell_r}{z}}
          {
            \ell(D)^{\mb{q}_1, 0}, \ell_o(C)^{\mb{q}_{12}, 0}, 
            \ell_l(A)^{\mb{q}_{123}, 0}}, \ell_r(B)^{\mb{q}_{123}, 0}} 
          ; \alpha^\downarrow
      \\ & \quad
      ];[
        \ms{id}, \\ & \qquad
        \dnt{
          \haslb{\Gamma^{\mb{q}_{123}}, y : A}{\epsilon}{\tossa{\ell_o}{P}}
                {\ell(D)^{\mb{q}_1, 0}, \ell_o(C)^{\mb{q}_{12}, 0}}
        } ; \alpha^\downarrow, \\ & \qquad
        \dnt{
          \haslb{\Gamma^{\mb{q}_{123}}, z : B}{\epsilon}{\tossa{\ell_o}{Q}}
                {\ell(D)^{\mb{q}_1, 0}, \ell_o(C)^{\mb{q}_{12}, 0}} 
        } ; \alpha^\downarrow
      \\ & \quad
      ];[
        \ms{id}, 
        \dnt{\haslb{\Gamma^{\mb{q}_{12}}, x : C}{\epsilon}{\tossa{\ell}{R}}
              {\ell(D)^{\mb{q}_1, 0}}} ; \alpha^\downarrow
      ] \\
    & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{123}}{\mb{q}_4}} 
      ; \dnt{\Gamma^{\mb{q}_{123}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_4}}{\epsilon}{o}{A + B}}
      ; \delta^{-1} ; [
        \iota_l ; \iota_r,
        \iota_r
      ];[
        \ms{id}, \\ & \qquad
          \dnt{
            \haslb{\Gamma^{\mb{q}_{123}}, y : A}{\epsilon}{\tossa{\ell_o}{P}}
                  {\ell_o(C)^{\mb{q}_{12}, 0}}
          } 
          ; \dnt{\lwk{\Gamma}
              {\ell_o(C)^{\mb{q}_{12}, 0}}{\ell(D)^{\mb{q}_1, 0}, \ell_o(C)^{\mb{q}_{12}, 0}}}
          ; \alpha^\downarrow, \\ & \qquad
          \dnt{
            \haslb{\Gamma^{\mb{q}_{123}}, z : B}{\epsilon}{\tossa{\ell_o}{Q}}
                  {\ell_o(C)^{\mb{q}_{12}, 0}} 
          }
          ; \dnt{\lwk{\Gamma}
              {\ell_o(C)^{\mb{q}_{12}, 0}}{\ell(D)^{\mb{q}_1, 0}, \ell_o(C)^{\mb{q}_{12}, 0}}}
          ; \alpha^\downarrow
      \\ & \quad
      ];[
        \ms{id}, 
        \dnt{\qsp{\Gamma^{\mb{q}_{12}}, x : C}{\mb{q}_1, \omega}{\mb{q}_1, 0}{\mb{q}_2, \omega}}
            ; (\dnt{\Gamma^{\mb{q}_1}} \otimes I) 
              \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : C}{\epsilon}{R}{D}}
            ; \iota_r
            ; \alpha^\downarrow
      ] \\
    & = \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{123}}{\mb{q}_4}} 
      ; \dnt{\Gamma^{\mb{q}_{123}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_4}}{\epsilon}{o}{A + B}}
      ; \delta^{-1} ;[ \\ & \qquad
          \dnt{\qsp{\Gamma, y : A}{\mb{q}_{123}, \omega}{\mb{q}_{12}, 0}{\mb{q}_3, \omega}}
          ; (\dnt{\Gamma^{\mb{q}_{12}}} \otimes I) 
              \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}, y : A}{\epsilon}{P}{C}}
          ; \iota_r
          ; \alpha^\downarrow, \\ & \qquad
          \dnt{\qsp{\Gamma, z : B}{\mb{q}_{123}, \omega}{\mb{q}_{12}, 0}{\mb{q}_3, \omega}}
          ; (\dnt{\Gamma^{\mb{q}_{12}}} \otimes I) 
              \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}, z : B}{\epsilon}{Q}{C}}
          ; \iota_r
          ; \alpha^\downarrow
      \\ & \quad
      ];[
        \ms{id}, 
        \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{C}
            ; \alpha
            ; \dnt{\Gamma^{\mb{q}_1}} 
              \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : C}{\epsilon}{R}{D}}
            ; \iota_r
      ] \\
      &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{123}}{\mb{q}_4}} 
      ; \dnt{\Gamma^{\mb{q}_{123}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_4}}{\epsilon}{o}{A + B}}
      ; \delta^{-1} ;[ \\ & \qquad
          \dnt{\qsp{\Gamma}{\mb{q}_{123}}{\mb{q}_{12}}{\mb{q}_3}} \otimes \dnt{A}
          ; \alpha
          ; \dnt{\Gamma^{\mb{q}_{12}}} 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}, y : A}{\epsilon}{P}{C}}, \\ & \qquad
          \dnt{\qsp{\Gamma}{\mb{q}_{123}}{\mb{q}_{12}}{\mb{q}_3}} \otimes \dnt{B}
          ; \alpha
          ; \dnt{\Gamma^{\mb{q}_{12}}} 
            \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}, z : B}{\epsilon}{Q}{C}}
      \\ & \quad
      ]
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{C}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : C}{\epsilon}{R}{D}}
      ; \iota_r
      \\
      &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{123}}{\mb{q}_4}} 
      ; \dnt{\qsp{\Gamma}{\mb{q}_{123}}{\mb{q}_{12}}{\mb{q}_3}} 
        \otimes \dnt{\Gamma^{\mb{q}_4}}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes ( \\ & \qquad
          \dnt{\Gamma^{\mb{q}_3}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_4}}{\epsilon}{o}{A + B}}
          ; \delta^{-1} ; [
          \dnt{\hasty{\Gamma^{\mb{q}_3}, y : A}{\epsilon}{P}{C}},
          \dnt{\hasty{\Gamma^{\mb{q}_3}, z : B}{\epsilon}{Q}{C}}
      \\ & \quad
      ])
      ; \dnt{\qsp{\Gamma^{\mb{q}_{12}}}{\mb{q}_1}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{C}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : C}{\epsilon}{R}{D}}
      ; \iota_r
      \\
      &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{34}}} 
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes ( 
          \dnt{\qsp{\Gamma}{\mb{q}_{34}}{\mb{q}_3}{\mb{q}_4}} ;
          \dnt{\Gamma^{\mb{q}_3}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_4}}{\epsilon}{o}{A + B}}
          ; \\ & \qquad \delta^{-1} ; [
          \dnt{\hasty{\Gamma^{\mb{q}_3}, y : A}{\epsilon}{P}{C}},
          \dnt{\hasty{\Gamma^{\mb{q}_3}, z : B}{\epsilon}{Q}{C}}
      ])
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : C}{\epsilon}{R}{D}}
      ; \iota_r
      \\
      &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{234}}}
      ; (\dnt{\Gamma^{\mb{q}_1}} \otimes (
          \dnt{\qsp{\Gamma}{\mb{q}_{234}}{\mb{q}_{2}}{\mb{q}_{34}}}  
          ; \\ & \qquad 
            \dnt{\Gamma^{\mb{q}_2}} 
            \otimes (\dnt{\hasty{\Gamma^{\mb{q}_{34}}}{\epsilon}{\caseexpr{o}{y}{P}{z}{Q}}{C}}
          ; \dnt{\hasty{\Gamma^{\mb{q}_2}, x : C}{\epsilon}{R}{D}}
      ))) 
      ; \iota_r
      \\
      &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{234}}}
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{
        \hasty{\Gamma^{\mb{q}_{234}}}{\epsilon}{\letexpr{x}{\caseexpr{o}{y}{P}{z}{Q}}{R}}{D}
      } ; \iota_r
  \end{align*}
  as desired.
  \item ($\letexpr{x}{\liter{o}{x}{P}}{Q}$): 
  \begin{align*}
    (\tossa{\ell}{\letexpr{x}{\liter{o}{y}{P}}{Q}})
    & := \cwhere{\brb{\ell_b}{o}}{ \\ & \qquad
      \wbranch{\ell_b}{y}{\tossa{\ell_h}{P}}, \\ & \qquad
      \wbranch{\ell_h}{w}{\caseexpr{w}{x}{\brb{\ell_o}{x}}{y}{\brb{\ell_b}{y}}}, \\ & \qquad
      \wbranch{\ell_o}{x}{\tossa{\ell}{Q}}
    }
  \end{align*}
  We verify the semantics by induction as follows, where $\ms{R}^{\mb{Q}} := 
  \ell_r(A)^{\mb{q}_{12}}, \ell_h(B + A)^{\mb{q}_{12}}, \ell_o(B)^{\mb{q}_{12}}$:
  \begin{align*}
  & \dnt{
    \haslb{\Gamma^{\mb{q}}}{\epsilon}{\tossa{\ell}{\letexpr{x}{\liter{o}{y}{P}}{Q}}}
    {\ell(C)^{\mb{q}_1}}
  } \\
  &= \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\brb{\ell_r}{o}}
        { 
          \ell(C)^{\mb{q}_1}, 
          \ms{R}^{\zeroqv{\mb{Q}}}
        }
      } ; [\ms{id}_{\dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{C}}, [\\ & \qquad
      \dnt{\haslb{\Gamma^{\mb{q}_{12}}, y : A}{\epsilon}{\tossa{\ell_h}{P}}
        {
          \ell(C)^{\mb{q}_1, 0}, 
          \ms{R}^{\zeroqv{\mb{Q}}}
        }
      } ; \alpha^\downarrow ; \alpha^+, \\ & \qquad
      \dnt{\haslb{\Gamma^{\mb{q}_{12}}, w : A + B}{\epsilon}
        {\caseexpr{w}{x}{\brb{\ell_o}{x}}{y}{\brb{\ell_b}{y}}}
        {
          \ell(C)^{\mb{q}_1, 0}, 
          \ms{R}^{\zeroqv{\mb{Q}}}
        }
      } ; \alpha^\downarrow ; \alpha^+, \\ & \qquad
      \dnt{\haslb{\Gamma^{\mb{q}_{12}}, x : B}{\epsilon}
        {\tossa{\ell}{Q}}
        {
          \ell(C)^{\mb{q}_1, 0}, 
          \ms{R}^{\zeroqv{\mb{Q}}}
        }
      } ; \alpha^\downarrow ; \alpha^+
    ]^\dagger] \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{12}}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; \iota_l ; \iota_l ; \iota_r
      ; [\ms{id}_{\dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{C}}, [\\ & \qquad
      \dnt{\haslb{\Gamma^{\mb{q}_{12}}, y : A}{\epsilon}{\tossa{\ell_h}{P}}
        {
          \ell(C)^{\mb{q}_1, 0}, 
          \ms{R}^{\mb{Q}}
        }
      } ; \alpha^\downarrow ; \alpha^+, \\ & \qquad
      \delta^{-1} ; [\iota_r, \iota_r ; \iota_l] ; \iota_r, \\ & \qquad
      \dnt{\haslb{\Gamma^{\mb{q}_{12}}, x : B}{\epsilon}
        {\tossa{\ell}{Q}}
        {
          \ell(C)^{\mb{q}_1, 0}, 
          \ms{R}^{\zeroqv{\mb{Q}}}
        }
      } ; \alpha^\downarrow ; \alpha^+
    ]^\dagger] \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{12}}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; \iota_l ; \iota_l
      ; [\\ & \qquad
      \dnt{
        \haslb{\Gamma^{\mb{q}_{12}}, y : A}{\epsilon}{\tossa{\ell_h}{P}}
          {\ell_h(B + A)^{\mb{q}_{12}, 0}}
      }
      ; \dnt{\lwk{\Gamma}{\ell_h(B + A)^{\mb{q}_{12}, 0}}
              {\ell(C)^{\mb{q}_1, 0}, \ms{R}^{\zeroqv{\mb{Q}}}}} 
      ; \alpha^\downarrow ; \alpha^+,
      \\ & \qquad
      \delta^{-1} ; [\iota_r, \iota_r ; \iota_l] ; \iota_r, \\ & \qquad
      \dnt{
        \haslb{\Gamma^{\mb{q}_{12}}, z : B}{\epsilon}{\tossa{\ell_h}{Q}}{\ell(C)^{\mb{q}_1, 0}}
      }
      ; \dnt{\lwk{\Gamma}{\ell(C)^{\mb{q}_1, 0}}\ell(C)^{\mb{q}_1, 0}, {\ms{R}^{\zeroqv{\mb{Q}}}}} 
      ; \alpha^\downarrow ; \alpha^+
    ]^\dagger \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{12}}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; \iota_l ; \iota_l
      ; [\\ & \qquad
      \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_{12}}{\mb{q}_r}} \otimes \dnt{A}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y : A}{\epsilon}
            {P}{B + A}}
      ; \iota_r ; \iota_r
      ,
      \\ & \qquad
      \delta^{-1} ; [\iota_r, \iota_r ; \iota_l] ; \iota_r, \\ & \qquad
      \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{B}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      ; \iota_r ; \iota_l
    ]^\dagger \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{12}}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; ( \\ & \qquad
        \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_{12}}{\mb{q}_r}} \otimes \dnt{A}
        ; \alpha
        ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y : A}{\epsilon}
              {P}{B + A}}
        ; \delta^{-1} ; 
        \\ & \qquad 
        ( 
          \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{B}
          ; \alpha
          ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}
          ; \iota_r}
        ) + (\dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{A})
      )^\dagger \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}}
      ; \dnt{\Gamma^{\mb{q}_{12}}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; ( \\ & \qquad
        \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_{12}}{\mb{q}_r}} \otimes \dnt{A}
        ; \alpha
        ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y : A}{\epsilon}
              {P}{B + A}}
        ; \delta^{-1}
        \\ & \quad 
      )^\dagger 
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{B}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      ; \iota_r \\
  % TODO: justify a spot more?
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}}
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_{12}}{\mb{q}_r}} 
        \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{o}{A}}
      ; \alpha 
      ; (\dnt{\Gamma^{\mb{q}_{12}}} \otimes ( \\ & \qquad
        \dnt{\qsp{\Gamma}{\mb{q}_r}{\mb{q}_r}{\mb{q}_r}} \otimes \dnt{A}
        ; \alpha
        ; \dnt{\Gamma^{\mb{q}_r}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y : A}{\epsilon}
              {P}{B + A}}
        ; \\ & \qquad \delta^{-1}
        ; (\dnt{\cwk{\Gamma^{\mb{q}_r}}{\cdot}} \otimes \dnt{B} ; \lambda) 
          + \dnt{\Gamma^{\mb{q}_r}} \otimes \dnt{A}
        \\ & \quad 
      )^\dagger)
      ; \alpha
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{B}
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      ; \iota_r \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3r}}}
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes (
        \dnt{\qsp{\Gamma}{\mb{q}_{3r}}{\mb{q}_r}{\mb{q}_3}}
        ; \dnt{\Gamma^{\mb{q}_r}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_{3}}}{\epsilon}{o}{A}}
        ; ( \\ & \qquad
          \dnt{\qsp{\Gamma}{\mb{q}_r}{\mb{q}_r}{\mb{q}_r}} \otimes \dnt{A}
          ; \alpha
          ; \dnt{\Gamma^{\mb{q}_r}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}, y : A}{\epsilon}
                {P}{B + A}}
        )^\dagger
        ; \dnt{\cwk{\Gamma^{\mb{q}_r}}{\cdot}} \otimes \dnt{B} ; \lambda \\ &\quad
      ) 
      ; \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      ; \iota_r \\
  \end{align*}
  \begin{align*}
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3r}}}
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes
        \dnt{\hasty{\Gamma^{\mb{q}_{3r}}}{\epsilon}{\liter{o}{y}{P}}{B}}
      ; \\ &\quad \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      ; \iota_r \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3r}}}
      ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes
        \dnt{\hasty{\Gamma^{\mb{q}_{3r}}}{\epsilon}{\liter{o}{y}{P}}{B}}
      ; \\ &\quad \alpha
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      ; \iota_r \\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{23r}}}
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes ( \\ & \qquad
        \dnt{\qsp{\Gamma}{\mb{q}_{23r}}{\mb{q}_{2}}{\mb{q}_{3r}}} 
        ; \dnt{\Gamma^{\mb{q}_2}} 
          \otimes \dnt{\hasty{\Gamma^{\mb{q}_{3r}}}{\epsilon}{\liter{o}{y}{P}}{B}}
        ; \dnt{\hasty{\Gamma^{\mb{q}_2}, x : B}{\epsilon}{Q}{C}}
      )
      ; \iota_r\\
  &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{23r}}}
      ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{
        \hasty{\Gamma^{\mb{q}_{23r}}}{\epsilon}{\letexpr{x}{\liter{o}{y}{P}}{Q}}{C}
      }
      ; \iota_r
  \end{align*}
  as desired.
\end{itemize}

% Rather than define this function directly, it is simpler to define an operation on terms
% $\ssalet{x}{a}{s}$ which, given a term $a$ and an SSA program $s$, returns a new SSA program which
% evaluates $a$, binds it to $x$, and then runs $s$. We will then show that $\ms{let}_{\ms{SSA}}$
% satisfies the following typing rule:
% $$
% \prftree[r]{\rle{let-ssa}}
%   {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
%   {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
%   {\haslb{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{s}{\ms{L}^{\mb{Q}}}}
%   {\haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{x}{a}{s}}{\ms{L}^{\mb{Q}}}}
% $$
% and has the expected semantics
% $$
% \dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{x}{a}{s}}{\ms{L}^{\mb{Q}}}} =
%   \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
%   ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} 
%   ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{s}{\ms{L}^{\zeroqv{\mb{Q}}}}}
%   ; \alpha^\downarrow
% $$
% We may then simply define
% $$
% \ms{SSA}_\ell(\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}) := 
%   (\ssalet{x}{a}{\brb{\ell}{x}})
% $$
% verifying that
% \begin{align*}
%   &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{x}{a}{\brb{\ell}{x}}}{\ell(A)^0}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{0}}{\mb{q}}} 
%   ; \dnt{\Gamma^\mb{0}} \otimes \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
%   ; \dnt{\haslb{\Gamma^{\mb{0}}, x : A}{\epsilon}{\brb{\ell}{x}}{\ell(A)^{\mb{0}}}}
%   ; \alpha^\downarrow \\
%   &= \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} ; \alpha
%   ; \dnt{\qsp{\Gamma, x : A}{\mb{0}, \omega}{\mb{0}, 0}{\mb{0}, \omega}} \\ &\qquad
%   ; (\dnt{\Gamma^{\mb{0}}} \otimes I) \otimes \dnt{\hasty{\Gamma^{\mb{0}}, x : A}{\epsilon}{x}{A}}
%   ; \alpha^\downarrow
%   ; \iota_r
%   ; \cancel{\dnt{\lwk{\Gamma}{\ell(A)^{\mb{0}}}{\ell(A)^{\mb{0}}}}} 
%   \\
%   &= \dnt{\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}} ; \alpha
%   ; \iota_r
% \end{align*}
% as desired. We will define $\ms{let}_{\ms{SSA}}$ by induction on terms $a$; for each branch, we will
% then inductively verify that the typing rule and the desired semantic property holds.
% \begin{itemize}
%   \item (Valid instructions $o$): we define $(\ssalet{x}{o}{s}) := (\letstmt{x}{o}{s})$, which
%   trivially has the desired typing and semantics.
%   \item (Operations $f\;a$, unreachable expressions $\labort{a}$, and injections $\linl{a},
%   \linr{b}$): we define
%   \begin{align*}
%   (\ssalet{x}{f\;a}{s}) := \ssalet{x_a}{a}{\letstmt{x}{f\;x_a}{s}}
%   \end{align*}
%   This is well-typed by induction, since, given $\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}$,
%   $\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{f\;a}{B}$ and
%   $\haslb{\Gamma^{\mb{q}_l}}{\epsilon}{s}{\ms{L}}$
%   \begin{itemize}
%     \item By inversion, we have $f : A \to_\epsilon B$, $\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}$,
%     \item By \brle{op}, we have $\hasty{\Gamma^0, x_a : A}{\epsilon}{f\;x_a}{B}$
%     \item By \brle{let$_1$} and weakening, we have $\haslb{\Gamma^{\mb{q}_l}, x_a :
%     A}{\epsilon}{\letstmt{x}{f\;x_a}{s}}{\ms{L}}$
%     \item Therefore, by induction, we have
%     $\haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{x_a}{a}{\letstmt{x}{f\;x_a}{s}}}{\ms{L}}$ as desired.
%   \end{itemize}
%   This has the desired semantics, since by induction
%   \begin{align*}
%   &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{x_a}{a}{\letstmt{x}{f\;x_a}{s}}}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
%   ; \dnt{\Gamma^{\mb{q}_l}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
%   \\ & \qquad
%   ; \dnt{\qsp{\Gamma, x_a : A}{\mb{q}_l, \omega}{\mb{q}_l, 0}{\mb{0}, \omega}} 
%   ; (\dnt{\Gamma^{\mb{q}_l}} \otimes I) \otimes 
%     \dnt{\hasty{\Gamma^{\mb{q}_l}, x_a : A}{\epsilon}{f\;x_a}{B}}
%   \\ & \qquad
%   ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x_a : A^0}{\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
%   ; \dnt{\Gamma^{\mb{q}_l}} \otimes 
%     (\dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}} ; \dnt{f : A \to_\epsilon B})
%   ; \alpha
%   ; \dnt{\haslb{\Gamma^{\mb{q}_l}, x_a : A^0}{\epsilon}{s}{\ms{L}}} 
%   \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}} 
%   ; \dnt{\Gamma^{\mb{q}_l}} \otimes 
%     \dnt{\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{f\;a}{B}}
%   ; \dnt{\haslb{\Gamma^{\mb{q}_l}}{\epsilon}{s}{\ms{L}}} 
%   \end{align*}
%   as desired. The cases for unreachable expressions $\labort{a}$ and injections $\linl{a}, \linr{b}$
%   are exactly analogous.
%   \item (Let-bindings $\letexpr{x}{a}{b}$): we define
%   \begin{align*}
%   (\ssalet{x}{\letexpr{y}{a}{b}}{s}) := \ssalet{y}{a}{\ssalet{x}{b}{s}}
%   \end{align*}
%   This is well-typed by induction, since given $\qsp{\Gamma}{\mb{q}}{\mb{q}_1}{\mb{q}_{23}}$,
%   $\haslb{\Gamma^{\mb{q}_{23}}}{\epsilon}{\letexpr{x}{a}{b}}{B}$, and $\haslb{\Gamma^{\mb{q}_1}, x :
%   B}{\epsilon}{s}{\ms{L}}$, we have
%   \begin{itemize}
%     \item By inversion, we have $\qsp{\Gamma}{\mb{q}_{23}}{\mb{q}_2}{\mb{q}_3}$,
%     $\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A}$, and
%     $\hasty{\Gamma^{\mb{q}_2, y : A}}{\epsilon}{b}{B}$.
%     \item By weakening, we have $\haslb{\Gamma^{\mb{q}_1}, y : A^0, x : B}{\epsilon}{s}{\ms{L}}$
%     \item By split associativity, we have $\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}$,
%     $\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}$
%     \item By induction, we have that
%     $
%     \haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{y}{a}{\ssalet{x}{b}{s}}}{\ms{L}}
%     $
%     as desired.
%   \end{itemize}
%   This has the desired semantics, since by induction
%   \begin{align*}
%   &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{y}{a}{\ssalet{x}{b}{s}}}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3}}}
%   ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A}}
%   ; \\ &\qquad 
%     \dnt{\qsp{\Gamma, y : A}{\mb{q}_{12}, \omega}{\mb{q}_1, 0}{\mb{q}_2, \omega}}
%   ; \dnt{\Gamma^{\mb{q}_1}} \otimes 
%     \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A}{\epsilon}{b}{B}}
%   ; \dnt{\haslb{\Gamma^{\mb{q}_1}, y : A^0, x : B}{\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3}}}
%   ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} \otimes \dnt{\Gamma^{\mb{q}_3}}
%   ; (\dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\Gamma^{\mb{q}_2}}) 
%     \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A}}
%   ; \\ &\qquad
%     \alpha ; \dnt{\Gamma^{\mb{q}_1}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A}{\epsilon}{b}{B}}
%   ; \alpha ; \dnt{\haslb{\Gamma^{\mb{q}_1}, y : A^0, x : B}{\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{23}}}
%   ; \dnt{\Gamma^{\mb{q}_1}} \otimes (\dnt{\qsp{\Gamma}{\mb{q}_{23}}{\mb{q}_2}{\mb{q}_3}}
%   ; \dnt{\Gamma^{\mb{q}_2}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A}})
%   ; \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A}{\epsilon}{b}{B}}
%   )
%   ; \\ &\qquad
%     \dnt{\haslb{\Gamma^{\mb{q}_1}, x : B}{\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{23}}}
%   ; \dnt{\Gamma^{\mb{q}_1}} \otimes 
%     \dnt{\hasty{\Gamma^{\mb{q}_{23}}}{\epsilon}{\letexpr{y}{a}{b}}{B}}
%   ; \dnt{\haslb{\Gamma^{\mb{q}_1}, x : B}{\epsilon}{s}{\ms{L}}}
%   \end{align*}
%   as desired.
%   \item (Binary let-bindings $\letexpr{(x, y)}{a}{b}$): we define
%   \begin{align*}
%   (\ssalet{x}{\letexpr{(y, z)}{a}{b}}{s}) := \ssalet{w}{a}{\letexpr{(y, z)}{w}{\ssalet{x}{b}{s}}}
%   \end{align*}
%   This is well-typed by induction, since given $\qsp{\Gamma}{\mb{q}}{\mb{q}_1}{\mb{q}_{23}}$,
%   $\haslb{\Gamma^{\mb{q}_{23}}}{\epsilon}{\letexpr{(y, z)}{a}{b}}{C}$, and
%   $\haslb{\Gamma^{\mb{q}_1}, x : B}{\epsilon}{s}{\ms{L}}$, we have
%   \begin{itemize}
%     \item By inversion, we have $\qsp{\Gamma}{\mb{q}_{23}}{\mb{q}_2}{\mb{q}_3}$,
%     $\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A \otimes B}$, and $\hasty{\Gamma^{\mb{q}_2, y : A, z :
%     B}}{\epsilon}{b}{B}$.
%     \item By weakening, we have $\haslb{\Gamma^{\mb{q}_1}, w : (A \otimes B)^0, y : A^0, z : B^0, x
%     : C}{\epsilon}{s}{\ms{L}}$
%     \item By split associativity, we have $\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_3}$,
%     $\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}$
%     \item By induction, we have that
%     $
%     \haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{w}{a}{\letstmt{(y, z)}{w}{\ssalet{x}{b}{s}}}}{\ms{L}}
%     $
%     as desired.
%   \end{itemize}
%   This has the desired semantics, since by induction
%   \begin{align*}
%   &\dnt{\haslb{\Gamma^{\mb{q}}}{\epsilon}{\ssalet{w}{a}{\letstmt{(y, z)}{w}{\ssalet{x}{b}{s}}}}
%     {\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3}}}
%   ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A \otimes B}}
%   ; \dnt{\qsp{\Gamma, w : A \otimes B}{\mb{q}_{12}, \omega}{\mb{q}_{12}, 0}{\mb{0}, \omega}}
%   ; \\ &\qquad 
%     (\dnt{\Gamma^{\mb{q}_{12}}} \otimes I) 
%       \otimes \dnt{\hasty{\Gamma^{\mb{0}}, w : A \otimes B}{\epsilon}{w}{A \otimes B}}
%   ; \\ &\qquad
%     \dnt{\qsp{\Gamma, w : A \otimes B, y : A, z : B}
%       {\mb{q}_{12}, 0, \omega, \omega}
%       {\mb{q}_1, 0, 0, 0}{\mb{q}_2, 0, \omega, \omega}} 
%   ; \\ &\qquad
%     (\dnt{\Gamma^{\mb{q}_1}} \otimes I \otimes I \otimes I)
%       \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, w : (A \otimes B)^0, y : A, z : B}
%       {\epsilon}{b}{C}}
%   ; \\ &\qquad 
%     \dnt{\haslb{\Gamma^{\mb{q}_1}, w : (A \otimes B)^0, y : A^0, z : B^0, x : C}
%     {\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3}}}
%   ; \dnt{\Gamma^{\mb{q}_{12}}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A \otimes B}}
%   ; \alpha
%   ; \dnt{\qsp{\Gamma, y : A, z : B}
%       {\mb{q}_{12}, \omega, \omega}
%       {\mb{q}_1, 0, 0}{\mb{q}_2, \omega, \omega}} 
%   ; \\ &\qquad
%     (\dnt{\Gamma^{\mb{q}_1}} \otimes I \otimes I)
%       \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A, z : B}
%       {\epsilon}{b}{C}}
%   ; \dnt{\haslb{\Gamma^{\mb{q}_1}, y : A^0, z : B^0, x : C}
%     {\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3}}}
%   ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} 
%     \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A \otimes B}}
%   ; \alpha
%   ; \\ &\qquad
%     (\dnt{\Gamma^{\mb{q}_1}} \otimes I \otimes I)
%       \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A, z : B}
%       {\epsilon}{b}{C}}
%   ; \dnt{\haslb{\Gamma^{\mb{q}_1}, y : A^0, z : B^0, x : C}
%     {\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{12}}{\mb{q}_{3}}}
%   ; \dnt{\qsp{\Gamma}{\mb{q}_{12}}{\mb{q}_1}{\mb{q}_2}} 
%     \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A \otimes B}}
%   ; \alpha
%   ; \\ &\qquad
%     \dnt{\Gamma^{\mb{q}_1}}
%       \otimes \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A, z : B}
%       {\epsilon}{b}{C}}
%   ; \dnt{\haslb{\Gamma^{\mb{q}_1}, x : C}
%     {\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{23}}}
%   ; \\ & \qquad \dnt{\Gamma^{\mb{q}_1}} \otimes (
%       \dnt{\qsp{\Gamma}{\mb{q}_{23}}{\mb{q}_2}{\mb{q}_3}} 
%     ; \dnt{\Gamma^{\mb{q}_2}} \otimes \dnt{\hasty{\Gamma^{\mb{q}_3}}{\epsilon}{a}{A \otimes B}}
%     ; \alpha
%     ; \dnt{\hasty{\Gamma^{\mb{q}_2}, y : A, z : B}{\epsilon}{b}{C}}
%   )
%   ; \\ &\qquad
%     \dnt{\haslb{\Gamma^{\mb{q}_1}, x : C}
%     {\epsilon}{s}{\ms{L}}} \\
%   &= \dnt{\qsp{\Gamma}{\mb{q}}{\mb{q}_{1}}{\mb{q}_{23}}}
%   ; \dnt{\Gamma^{\mb{q}_1}} \otimes (
%       \dnt{\hasty{\Gamma^{\mb{q}_{23}}}{\epsilon}{\letexpr{(y, z)}{a}{b}}{C}}
%   )
%   ; \dnt{\haslb{\Gamma^{\mb{q}_1}, x : C}
%     {\epsilon}{s}{\ms{L}}}
%   \end{align*}
%   as desired.
%   \item (Pairs $(a, b)$): we define
%   \begin{align*}
%   (\ssalet{x}{(a, b)}{s}) := (\ssalet{x_a}{a}{\ssalet{x_b}{b}{\letstmt{x}{(x_a, x_b)}{s}}})
%   \end{align*}
%   \TODO{well typed}
%   \TODO{good semantics}
%   \item (Case-statements $\caseexpr{e}{x}{a}{y}{b}$): we define
%   \begin{align*}
%   (\ssalet{x}{\caseexpr{e}{y}{a}{z}{b}}{s}) &:= (
%     \ssalet{x_e}{e}{\awhere{\awhere{\caseexpr{x_e}{y}{\brb{\ell_l}{y}}{z}{\brb{\ell_r}{z}}
%       \\ & \qquad}{
%         \wbranch{ \\ & \qquad \qquad \ell_l}{y}{\ssalet{x_a}{a}{\brb{\ell_o}{x_a}}},
%         \wbranch{ \\ & \qquad \qquad \ell_r}{z}{\ssalet{x_b}{b}{\brb{\ell_o}{x_b}}}
%       } 
%       \\ & \qquad}{
%         \wbranch{\\ & \qquad \qquad \ell_o}{x}{s}
%       }}
%   )
%   \end{align*}
%   \item (Loops $\liter{a}{x}{b}$): \todo{yet it does}
% \end{itemize}

\section{Models}

\label{apx:models}

In this section, we give a few simple families of \subiterexp{}-models highlighting some of the
features of our formalization.

\subsection{Poset-Enriched Elgot Monads}

A wide variety of \subiterexp{}-models can be derived from \emph{poset-enriched Elgot monads} over
$\mb{Set}$, which are just standard monads equipped with a notion of refinement and iteration. We
begin by defining a \emph{poset-enriched monad} as follows:
\begin{definition}[Poset-Enriched Monad]
  We say a monad $T$ over $\mb{Set}$ is \emph{poset-enriched} if each $T(A)$ is equipped with a
  partial order $\tref$ compatible with $\mbind{T}{\cdot}{\cdot}$, i.e., such that, for $a \tref b$
  and $f \tref g$, we have $\mbind{T}{a}{f} \tref \mbind{T}{b}{g}$, where morphisms in the Kleisli
  category $f, g : A \to T(B)$ are given the pointwise partial order.
\end{definition}
Note that, just like for poset-enriched categories, \emph{every} monad is poset-enriched with the
identity order on $T\;A$. Probably the simplest nontrivial example of a poset-enriched monad is
given by adjoining a top element to every set as follows $\top(A) := A \cup \{\top\}$, with pure and
bind defined as for the option monad; we can symmetrically instead adjoin a bottom element $\bot(A)
:= A \cup \{\bot\}$. A more complex example is given by the power-set monad $\mc{P}$ equipped with
the inclusion order, with
\begin{equation}
  \eta_{\mc{P}}(a) := \{a\} \qquad
  \mbind{\mc{P}}{X}{f} := \bigcup_{a \in X}f(a) 
\end{equation}
This has numerous natural submonads which are also poset-enriched, including:
\begin{itemize}
  \item Nonempty sets $\mc{P}^+$
  \item Finite sets $\mc{P}_{\ms{fin}}$
  \item Countable sets $\mc{P}_{\nats}$
  \item Sets of cardinality at most one, which is isomorphic to $\bot$.
  \item Sets of cardinality exactly one, corresponding to pure morphisms.
\end{itemize}
It is easy to see that the Kleisli category of a poset-enriched monad is
always a poset-enriched distributive category; in particular, tensor products and coproducts are
simply given by the product and coproduct in $\mb{Set}$, with
\begin{gather*}
  f \otimes A := (\lambda (x, y) . \mbind{}{f\;x}{\lambda z . (z, y)}) \qquad
  A \otimes f := (\lambda (x, y) . \mbind{}{f\;y}{\lambda z . (x, z)}) 
\end{gather*}
and (inverse) associators, unitors, symmetries, distributors, and injections given by the lifts of
the underlying morphisms in $\mb{Set}$. We can always equip the Kleisli category with the structure
of a distributive effectful category with pure morphisms
\begin{align*}
  \ms{Set}_{T\bot}(A, B) := \{\eta_B \circ f \mid f : A \to B\}
\end{align*}
We can define $\ms{Set}_{T\epsilon}$ for other effects $\epsilon \in \mc{E}$ in a given effect
system as appropriate to the effect system and monad; submonads are often a good place to look for
these.

We would now like to equip the Kleisli category of $T$ with an iteration structure. The notion of an
Elgot monad \cite{goncharov-16-complete-elgot} generalizes directly to the poset-enriched setting:
\begin{definition}[Poset-Enriched Elgot Monad]
  We say a poset-enriched monad $T$ is a (strong) Elgot monad if its Kleisli category is equipped
  with a monotone iteration operator $(\cdot)^\dagger$ satisfying the following properties:
  \begin{itemize}
    \item \emph{Naturality}: for $f : A \to T (B + A)$ and $g : B \to T(C)$, we have $(f ; g +
    A)^\dagger = f^\dagger ; g$
    \item \emph{Codiagonal}: for $f: A \to T ((B + A) + A)$, we have $f^{\dagger\dagger} = (f ;
    [\ms{id}, \iota_r])^\dagger$
    \item \emph{Directed uniformity}: given $f : A \to T(B + A)$, $g: X \to T(B + X)$, and
    \emph{pure} $h : X \to A$, we have
    \begin{itemize}
      \item $h^\uparrow\;f \tref g ; B + h^\uparrow 
        \implies h^\uparrow ; f^\dagger \tref g^\dagger$
      \item$h^\uparrow\;f \antitref g ; B + h^\uparrow 
        \implies h^\uparrow ; f^\dagger \antitref g^\dagger$
    \end{itemize}
    where $h^\uparrow = \eta_A \circ h : X \to T(A)$.
  \end{itemize}
  \item \emph{Strengh}: given $f : A \to T(B + A)$, we have 
  $X \otimes f^\dagger = (X \otimes f ; \delta^{-1})^\dagger$
\end{definition}
We can easily verify that the Kleisli category of a strong Elgot monad is an Elgot category, which
in particular is $\ms{Set}_{T\bot}$-uniform by uniformity. Probably the simplest example of an Elgot
monad is the power-set $\mc{P}$, with
\begin{equation*}
  f^\dagger := \bigcup_i f_i \qquad \text{where} \qquad
  f_0 = \varnothing \qquad f_{i + 1} = f ; [\ms{id}, f_i]
\end{equation*}
Analysis of semantics in this monad corresponds to \emph{partial correctness}, with any infinite
executions discarded. This isn't always what we want, especially since every program can be safely
refined to (and hence ``optimized to'') the infinite loop $0 := \varnothing: A \to B$. Note for
example that
\begin{itemize}
  \item The pure effect is not closed under refinement, since any pure morphism can be refined to
  $0$
  \item The pure effect, as well as the effect of being finite and the effect of being nonempty, are
  \emph{not} iterative, but the effect of being countable and the effect of being deterministic but
  potentially nonterminating \emph{are}.
\end{itemize}

\subsection{Undefined Behavior}

\label{apx:ub}

In this section, we demonstrate how to build a more complex poset-enriched Elgot monad, by
constructing a monad $\ms{UB}$ which supports
\begin{itemize}
  \item \emph{Undefined behavior} (UB), represented as a top element $\ubeff \tref a$ for all $a$.
  \item \emph{Nondeterministic behavior}
  \item \emph{Total correctness}, with nontermination represented as a separate possible outcome
  $\infty$ (allowing us to distinguish between a program which always terminates, never terminates,
  and is nondeterministically nonterminating)
\end{itemize}
As described in Section~\ref{ssec:ub}, we define $\ms{UB}(A) := \mc{P}^+(A \cup \{\infty\}) \cup
\{\ubeff\}$, with
$$
\mbind{\ms{UB}}{\ubeff}{f} = \ubeff \qquad
\mbind{\ms{UB}}{X}{f} = \{f\;a \mid a \in X\} \;\; \text{if } \forall a \in X, f\;a \neq \ubeff
\qquad
\mbind{\ms{UB}}{X}{f} = \ubeff \;\; \text{otherwise}
$$
We can equip this with iteration structure $(\cdot)^\dagger$ given by, given $f : A \to \ms{UB}(B +
A)$,
$$
f^\dagger(a) := \begin{cases}
  f_\infty(a) \cup \bigcup_{i \in \nats}f_i(a) & \text{if } \forall i, f_i(a) \neq \ubeff
  \\
  \ubeff & \text{otherwise}
\end{cases}
$$
where
$$
f_0 := \varnothing \qquad
f_{i + 1} := f ; [\ms{id}, f_i] \qquad
f_\infty(a_0) := \begin{cases}
  \{\infty\} & \text{if } \exists a_i, \forall i, a_{i + 1} \in f(a_i)\\
  \varnothing & \text{otherwise}
\end{cases} 
$$
Note that the $f_i$ are in the slightly larger monad $A \mapsto \mc{P}(A \cup \{\infty\}) \cup
\{\ubeff\}$; but it is straightforward to show that $f^\dagger$ must be nonempty and therefore lie
in the submonad $\ms{UB}$ (since if all $f_i$ are empty, $f_\infty = \{\infty\}$). It is
straightforward to verify that this indeed gives us an Elgot structure.

\subsection{Monad Transformers}

\label{apx:ub-st}

In functional programming, we often use a stack of \emph{monad transformers} to build up complex
effects from simple building blocks. It turns out that many common monad transformers are compatible
with both poset-enrichment and Elgot structure; we give some important examples below:
\begin{itemize}
  \item The \emph{reader transformer} $\ms{Rd}_R\;T\;A := R \to T\;A$ allows us to read from an
  environment $R$, with
  \begin{equation*}
  \eta_{\ms{Rd}_R\;T}\;a := \lambda r . \eta_T\;a \qquad
  \mbind{\ms{Rd}_R\;T}{a}{f} := \lambda r. \mbind{T}{a\;r}{\lambda a' . f\;a'\;r}
  \end{equation*}
  Given $f : A \to \ms{Rd}_R\;T\;(B + A) = A \to R \to T(B + A)$, we define
  \begin{equation*}
    f^{\dagger_{\ms{Rd}_R\;T}} := \lambda a, r . 
      \mbind{T}{((\lambda (r, a) . (r, f\;a\;r)) ; \delta^{-1})^\dagger(r, a)}{\pi_2}
  \end{equation*}
  \item The \emph{writer transformer} $\ms{Wr}_W\;T\;A := T\;(W \times A)$ for a monoid $(W, \cdot,
  1)$ allows us to write to a $W$-typed log, with
  \begin{equation*}
  \eta_{\ms{Wr}_W\;T}\;a := \eta_T\;(1, a) \qquad
  \mbind{\ms{Wr}_W\;T}{a}{f} := \mbind{T}{a}{\lambda (w, a') . 
    \mbind{T}{f\;a}{\lambda (w', b) . (w \cdot w', b)}}
  \end{equation*}
  Given $f : A \to \ms{Wr}_W\;T\;(B + A) = A \to T(W \times (B + A))$, we define
  \begin{equation*}
    f^{\dagger_{\ms{Wr}_W\;T}} := \lambda a . 
      (W \otimes f ; (\lambda (w, (w', c)) . \eta_T(w \cdot w', c)) ; \delta^{-1})^\dagger(1, a)
  \end{equation*}
  \item The \emph{state transformer} $\ms{St}_S\;T\;A := S \to T\;(S \times A)$ allows us to access
  mutable state of type $S$, with
  \begin{equation*}
  \eta_{\ms{St}_S\;T}\;a := \lambda s . \eta_T\;(s, a) \qquad
  \mbind{\ms{St}_S\;T}{a}{f} := \lambda s . 
    \mbind{T}{a\;s}{\lambda (s', a') . f\;a'\;s'}
  \end{equation*}
  Given $f : A \to \ms{St}_S\;T\;(B + A) = A \to S \to T(S \times (B + A))$, we define
  \begin{equation*}
    f^{\dagger_{\ms{St}_S\;T}} := \lambda a, s . 
      ((\lambda (s, a) . f\;a\;s) ; \delta^{-1})^\dagger(s, a)
  \end{equation*}
\end{itemize}
As a concrete example, we can build the heap monad from Section~\ref{ssec:heaps} by simply applying
the state transformer to the UB monad from Appendix~\ref{apx:ub}, with state $S := \nats
\pto_{\ms{fin}} \nats$.

% \subsection{Separation Logic}

% \label{apx:sep}

% \TODO{predicates on heaps above}

% \TODO{basetypes are datatypes + predicates}

% \TODO{objects are sets + predicates, do tensor}

% \TODO{morphisms are predicate-preserving morphisms in the underlying; these become our
% instructions}

% \TODO{forgetful functor is a model morphism to heap model; show results here}

\subsection{Brookes-Style Concurrency}

\label{apx:rel-acq}

In this section, we show how to construct a concurrency monad from a
\citet{brookes-full-abstraction-96}-style model of concurrency, which we axiomatize.
We will then explicitly show how to instantiate the model for sequentially consistent execution
from \citet{brookes-full-abstraction-96}.

We begin by defining a \emph{countable closure operator}, given below:
\begin{definition}[Countable Closure Operator]
  We define a \emph{(countable) closure operator} $\ms{c}: \mc{P}(T) \to \mc{P}(T)$ on $T$ to be a
  function on sets of $T$ which:
  \begin{itemize}
    \item \emph{is extensive}: $X \subseteq \ms{c}(X)$
    \item \emph{is idempotent}: $\ms{c}(\ms{c}(X)) = \ms{c}(X)$
    \item \emph{distributes over countable unions}: $\ms{c}(\bigcup_i X_i) = \bigcup_i \ms{c}(X_i)$
  \end{itemize}
  We say a set $X$ such that $\ms{c}(X) = X$ is \emph{closed} under $\ms{c}$. 
\end{definition}
Note that this differs from the standard definition of a Kuratowski topological closure operator,
which only requires us to distributive over \emph{finite} unions. We define the \emph{lift} of a
closure operator $\ms{c}_A : \mc{P}(T \times A) \to \mc{P}(T \times A)$ to be given by
\begin{equation*}
  \ms{c}_A(X) := \bigcup_{a \in A}\{(t', a) \mid t' \in \ms{c}(\{t \mid (t, a) \in X\})\}
\end{equation*}
Identifying $\mc{P}(T \times A)$ with $A \to \mc{P}(T)$, this is equivalent to stating that
$\ms{c}_A(X) := \ms{c} \circ X$. It is hence easy to check that this gives a closure operator on $T
\times A$.
\begin{definition}[Brookes Monad]
  Given a monoid of \emph{traces} $T$ and a closure operator $\ms{c}: \mc{P}(T) \to \mc{P}(T)$, we
  define the \emph{Brookes monad} $\ms{B}_{\ms{c}}$ over $\ms{c}$ to be given by closed sets of
  pairs $\tret{t}{a}$ of \emph{traces} $t \in T$ and \emph{results} $a \in A$. In particular, we
  define
  $$
  \ms{B}_{\ms{c}}(A) := \ms{c}_A(\mc{P}(T \times A)) \simeq A \to \ms{c}(\mc{P}(T))
  $$
  with
  $$
  \eta_{\ms{B}_{\ms{c}}}\;a := \ms{c}_A(\{\tret{1}{a}\}) \qquad
  \mbind{\ms{B}_{\ms{c}}}{X}{f} 
  := \ms{c}_A(\{\tret{t \cdot t'}{b} \mid \exists a . \tret{t}{a} \in X, \tret{t'}{b} \in X'\})
  $$
  It is easy to see that the Brookes monad is in fact poset-enriched under the inclusion order. We
  say a Brookes monad is \emph{standard} if $T = \langle S, S \rangle^*$ is the monoid of finite
  sequences of \emph{rely-guarantee pairs} of \emph{states} $S$.
\end{definition}
We note that this definition gives us a Kleisli category which is not only poset-enriched, but in
fact compatible with countable unions: with the usual definition $\cup_i f_i := \lambda a . \cup_i
f_i(a)$, we have
\begin{align*}
  ((\bigcup_i f_i) ; g)(a) &:= \ms{c}_C(\{
    \tret{t \cdot t'}{c} \mid \exists b . \tret{t}{b} \in \bigcup_i f_i(a), \tret{t'}{c} \in g(b)
  \}) \\
  &= \ms{c}(\bigcup_i \{
      \tret{t \cdot t'}{c} \mid \exists b . \tret{t}{b} \in f_i(a), \tret{t'}{c} \in g(b)
    \}) \\
  &= \bigcup_i \ms{c}(\{
      \tret{t \cdot t'}{c} \mid \exists b . \tret{t}{b} \in f_i(a), \tret{t'}{c} \in g(b)
    \}) \\
  &= \bigcup_i (f_i ; g)(a)
  \\
  f ; (\bigcup_i g_i)(a) &:= \ms{c}(\{
    \tret{t \cdot t'}{c} \mid \exists b . \tret{t}{b} \in f(a), \tret{t'}{c} \in \bigcup_i g_i(b)
  \}) \\
  &= \ms{c}(\bigcup_i \{
    \tret{t \cdot t'}{c} \mid \exists b . \tret{t}{b} \in f(a), \tret{t'}{c} \in g_i(b)
  \}) \\
  &= \bigcup_i \ms{c}(\{
    \tret{t \cdot t'}{c} \mid \exists b . \tret{t}{b} \in f(a), \tret{t'}{c} \in g_i(b)
  \}) \\
  &= \bigcup_i (f ; g_i)(a)
\end{align*}
and likewise for coproducts.

We can always equip $\ms{B}_{\ms{c}}$ with a (poset-enriched) Elgot structure $(\cdot)^\dagger$ by,
for $f: A \to \ms{B}_{\ms{c}}(B + A)$, defining
\begin{equation*}
  f^\dagger := \bigcup_{i \in \nats}f_i
\end{equation*}
where $f_i : A \to \ms{B}_{\mc{C}}(B)$ are the \emph{iterates} of $f$, defined inductively as
follows
\begin{equation*}
  f_0 := 0_{A, B} = (\lambda x . \varnothing) \qquad
  f_{i + 1} := f ; [\ms{id}_B, f_{i}]
\end{equation*}
We note in particular that $\forall i . f_i \subseteq f_{i + 1}$; similarly, if $g \subseteq f$, we
have that $g_i \subseteq f_i$. We can think of analysis using this structure as corresponding to
\emph{partial correctness}, since any infinite traces are simply discarded (a program which always
diverges will have denotation $\varnothing$). It is straightforward to check that this is indeed an
Elgot structure, since it satisfies:
\begin{itemize}
  \item \emph{Fixpoint}: we have, since $f_0 \cup g = g$,
  \begin{equation*}
    f^\dagger = \bigcup_{i \in \nats}f_i 
               = \bigcup_{i \in \nats}f_{i + 1} 
               = \bigcup_{i \in \nats}(f ; [\ms{id}_B, f_i]) 
               = f ; [\ms{id}_B, \bigcup_{i \in \nats}f_i] 
               = f ; [\ms{id}_B, f^\dagger]
  \end{equation*}
  as desired.
  \item \emph{Naturality}: by induction, we show that $(f ; g + A)_i = f_i ; g$, since 
  $(f ; g + A)_0 = 0_{A, C} = 0_{A, B} ; g$ and
  \begin{equation*}
    (f ; g + A)_{i + 1} = f ; g + A ; [\ms{id}_C, (f ; g + A)_i] 
                        = f ; [g, f_i ; g] = f ; [\ms{id}_B, f_i] ; g = f_{i + 1} ; g
  \end{equation*}
  and therefore
  \begin{equation*}
  (f ; g + A)^\dagger = \bigcup_{i \in \nats}(f ; g + A)_i
  = \bigcup_{i \in \nats}(f_i ; g)
  = (\bigcup_{i \in \nats}f_i) ; g
  = f^\dagger ; g
  \end{equation*}
  \item \emph{Codiagonal}: given $f: A \to (B + A) + A$, define $g = f ; [\ms{id}_{B + A}, \iota_r]$
  and $h = f^\dagger$. We have
  \begin{align*}
    h_{i + 1}
    & = f^\dagger ; [\ms{id}, h_i]
      = f ; [\ms{id}, f^\dagger] ; [\ms{id}, h_i] \\
    & = f ; [[\ms{id}, h_i], f^\dagger ; [\ms{id}, h_i]]
      = f ; [[\ms{id}, h_i], h_{i + 1}] \\
    g_{i + 1} 
    & = f ; [\ms{id}_B, \iota_r] ; [\ms{id}, g_i] 
      = f ; [[\ms{id}, g_i], g_i]
  \end{align*}
  It follows by induction that $g_i \subseteq h_i$, since $g_0 = h_0$, and
  \begin{align*}
  g_{i + 1} 
  = f ; [[\ms{id}, g_i], g_i]
  \subseteq f ; [[\ms{id}, h_i], h_i]
  \subseteq f ; [[\ms{id}, h_i], h_{i + 1}]
  = h_{i + 1}
  \end{align*}
  We therefore have that $g^\dagger \subseteq h^\dagger$. On the other hand, we may show by
  induction on $j$ that $f_j ; [\ms{id}, g^\dagger] \subseteq g^\dagger$, since $0 \subseteq
  g^\dagger$ and
  \begin{align*}
  f_{j + 1} ; [\ms{id}, g^\dagger] 
  & = f ; [\ms{id}, f_j] ; [\ms{id}, g^\dagger]
    = f ; [[\ms{id}, g^\dagger], f_j ; [\ms{id}, g^\dagger]]
    \subseteq f ;  [[\ms{id}, g^\dagger], g^\dagger] = g^\dagger
  \end{align*}
  We now show by induction that $h_i \subseteq g^\dagger$: noting that $h_0 = 0
  \subseteq g^\dagger$, it suffices to show that
  \begin{align*}
  h_{i + 1} 
  & = f ; [[\ms{id}, h_i], f^\dagger ; [\ms{id}, h_i]] 
    \subseteq f ; [[\ms{id}, g^\dagger], f_j ; [\ms{id}, g^\dagger]] \\
  & = \bigcup_{j \in \nats}(f ; [[\ms{id}, g^\dagger], f_j ; [\ms{id}, g^\dagger]])
    \subseteq \bigcup_{j \in \nats}(f ; [[\ms{id}, g^\dagger], g^\dagger]])
    = g^\dagger
  \end{align*}
  It follows that $h^\dagger \subseteq g^\dagger$ and hence that $h^\dagger = g^\dagger$, as
  desired.
  \item \emph{Directed Uniformity}: given arbitrary $f : A \to B + A$, $g : X \to B + X$ and $h : X
  \to A$, we have that
  \begin{itemize}
    \item Given $h ; f \subseteq g ; B + h$, for all $f_i$, we show by induction that 
    $h ; f_i \subseteq g_i$ since $h ; f_0 = 0 \subseteq g_0$ and
    \begin{equation*}
    h ; f_{i + 1} = h ; f ; [\ms{id}, f_i] 
    \subseteq g ; B + h ; [\ms{id}, f_i]
    = g ; [\ms{id}, h ; f_i] \subseteq g ; [\ms{id}, g_i] = g_{i + 1}
    \end{equation*}
    and therefore we have that $h ; f^\dagger = \bigcup_i h ; f_i \subseteq \bigcup_i g_i =
    g^\dagger$
    \item Given $h ; f \supseteq g ; B + h$, for all $f_i$, we show by induction that 
    $h ; f_i \supseteq g_i$ since $h ; f_0 = 0 = g_0$ and
    \begin{equation*}
    h ; f_{i + 1} = h ; f ; [\ms{id}, f_i] 
    \supseteq g ; B + h ; [\ms{id}, f_i]
    = g ; [\ms{id}, h ; f_i] \supseteq g ; [\ms{id}, g_i] = g^\dagger
    \end{equation*}
    and therefore we have that $h ; f^\dagger = \bigcup_i h ; f_i \supseteq \bigcup_i g_i =
    g^\dagger$
  \end{itemize}
\end{itemize}
Following \citet{brookes-full-abstraction-96}, we can build up a model of \emph{sequentially
consistent} concurrent computation by taking a standard Brookes monad with
\begin{itemize}
  \item States maps from locations to values $S := \ms{Loc} \to \ms{Val}$
  \item Closure operator generated by:
  \begin{itemize}
    \item \emph{Stuttering} $\forall \mu \in S . \cdot \tref \langle \mu, \mu \rangle$
    \item \emph{Mumbling} $\forall \mu, \rho, \theta \in S . 
      \langle \mu, \rho \rangle \langle \rho, \theta \rangle \tref \langle \mu, \theta \rangle$
  \end{itemize}
\end{itemize} 
The semantics of a write, for example, is then given by
\begin{equation*}
  \ms{write} : \ms{Loc} \times \ms{Val} \to \ms{B}_{\ms{c}}(\mb{1})
  := \lambda (\ell, v) . 
    \ms{c}_{\mb{1}}(\{\tret{\langle \mu, [\ell \mapsto v]\mu \rangle}{()} \mid \mu \in S\})
\end{equation*}
More complex states (e.g. involving per-thread buffers) and closure operators can allow us to model
weak memory models. In particular, \citet{jagadeesan-brookes-relaxed-12} gives a Brookes model of
TSO, while \citet{release-acquire} gives a Brookes model of release-acquire.

\end{document}
\endinput
