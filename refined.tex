%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\documentclass[acmsmall,screen,review]{acmart}

\usepackage{syntax}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{\normalfont\itshape}

\usepackage{prftree}

\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{xcolor} % \usepackage[dvipsnames]{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{fancyvrb}
\usepackage{enumitem}
\usepackage{string-diagrams}
\usepackage{cancel}
\usepackage{thmtools}
\usepackage{pifont}
\usetikzlibrary{calc}

\lstset{ %
  autogobble=true,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
%    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcounter{todos}
\newcommand{\TODO}[1]{{
  \stepcounter{todos}
  \begin{center}\large{\textcolor{red}{\textbf{TODO \arabic{todos}:} #1}}\end{center}
}}

\newcommand{\todo}[1]{\stepcounter{todos} \textcolor{red}{\textbf{TODO \arabic{todos}}: #1}}

% Math fonts
\newcommand{\mc}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\mathsf{#1}}}

% Math
\newcommand{\nats}{\mathbb{N}}

% Syntax atoms
\newcommand{\lbl}[1]{{`#1}}
\newcommand{\lto}{:}
\newcommand{\linl}[1]{\iota_l\;{#1}}
\newcommand{\linr}[1]{\iota_r\;{#1}}
\newcommand{\labort}[1]{\ms{abort}\;{#1}}

% Syntax
\newcommand{\letexpr}[3]{\ensuremath{\ms{let}\;#1 = #2;\;#3}}
\newcommand{\caseexpr}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\letstmt}[3]{\ensuremath{\ms{let}\;#1 = #2; #3}}
\newcommand{\brb}[2]{\ms{br}\;#1\;#2}
\newcommand{\ite}[3]{\ms{if}\;#1\;\{#2\}\;\ms{else}\;\{#3\}}
\newcommand{\casestmt}[5]{\ms{case}\;#1\;\{\linl{#2} \lto #3, \linr{#4} \lto #5\}}
\newcommand{\loopstmt}[4]{\ms{loop}\;#1\;\{#2(#3) \lto #4\}}
\newcommand{\awhere}[2]{#1\;\ms{where}_{\ms{nonrec}}\;#2}
\newcommand{\cwhere}[2]{#1\;\ms{where}_{\ms{rec}}\;#2}
\newcommand{\where}[2]{#1\;\ms{where}\;#2}
\newcommand{\wbranch}[3]{#1(#2) \lto \{#3\}}
\newcommand{\cfgsubst}[1]{\ms{cfgs}\;\{#1\}}
\newcommand{\wseq}[2]{{#1} \mathbin{{;}{;}} {#2}}
\newcommand{\rupg}[1]{{#1}^\upharpoonright}
\newcommand{\lupg}[1]{{#1}^\upharpoonleft}
\newcommand{\liter}[3]{\ms{iter}\;#1\;\{ \linr{#2} \lto #3 \}}
\newcommand{\einf}[1]{#1 \in \mc{E}^\infty}

\newcommand{\ncaseexpr}[3]{\ms{case}_{#1}\;#2\;\{#3\}}
\newcommand{\splitexpr}[3]{\ms{split}_{#1; #2}(#3)}
\newcommand{\webranch}[3]{#1(#2) \lto #3}

% Judgements
\newcommand{\qsp}[4]{#1 \vdash #2 = #3 + #4}
\newcommand{\qwk}[4]{#1 \vdash #2 \geq #3 + #4}
\newcommand{\swk}[3]{#1 \mapsto #2 ; #3}
\newcommand{\cwk}[2]{#1 \mapsto #2}
\newcommand{\lwk}[2]{#1 \rightsquigarrow #2}
\newcommand{\thyp}[3]{#1 : {#2}^{#3}}
\newcommand{\bhyp}[2]{#1 : #2}
\newcommand{\lhyp}[2]{#1(#2)}
\newcommand{\rle}[1]{{\scriptsize\textsf{#1}}}
\newcommand{\qbc}[2]{(#1) , #2}

\newcommand{\hasty}[4]{#1 \vdash_{#2} #3: {#4}}
\newcommand{\haslb}[4]{#1 \vdash_{#2} #3 \rhd #4}

\newcommand{\ahasty}[4]{#1 \vdash_{#2}^{\ms{anf}} #3 : {#4}}
\newcommand{\thaslb}[3]{#1 \vdash^{\ms{t}}_{\ms{ssa}} #2 \rhd #3}
\newcommand{\ahaslb}[3]{#1 \vdash^{\ms{anf}} #2 \rhd #3}
\newcommand{\bhaslb}[3]{#1 \vdash^{\ms{b}}_{\ms{ssa}} #2 \rhd #3}
% \newcommand{\chaslb}[3]{#1 \vdash^{\ms{c}}_{\ms{ssa}} #2 \rhd #3}

\newcommand{\shaslb}[3]{#1 \vdash^{\ms{s}} #2 \rhd #3}

\newcommand{\isop}[4]{#1 \in \mc{I}_{#4}(#2, #3)}
\newcommand{\issubst}[4]{#1 \vdash_{#2} #3 \rhd #4}
\newcommand{\lbsubst}[4]{#1 \vdash #2: #3 \rightsquigarrow #4}
\newcommand{\teqv}{\approx}
\newcommand{\tref}{\twoheadrightarrow}
\newcommand{\tmle}[5]{#1 \vdash_{#2} #3 \tref #4 : {#5}}
\newcommand{\tmlep}[6]{#1 \vdash_{#2} #3 \tref^{#6} #4 : {#5}}
\newcommand{\tmeq}[5]{#1 \vdash_{#2} #3 \teqv #4 : {#5}}
\newcommand{\lbeq}[4]{#1 \vdash #2 \teqv #3 \rhd {#4}}
\newcommand{\tmseq}[4]{\issubst{#1 \teqv #2}{#3}{#4}}
\newcommand{\lbseq}[5]{\lbsubst{#1 \teqv #2}{#3}{#4}{#5}}
\newcommand{\brle}[1]{{\textsf{#1}}}

\newcommand{\tossa}[2]{\ms{SSA}(#1 \Rightarrow #2)}
\newcommand{\ssalet}[3]{\ms{SSA}_{\ms{let}}(#1, #2, #3)}
\newcommand{\toanf}[1]{\ms{ANF}(#1)}
\newcommand{\anflet}[3]{\ms{ANF}_{\ms{let}}(#1, #2, #3)}
\newcommand{\toterm}[1]{\ms{Term}(#1)}
\newcommand{\etoty}[1]{[#1]}
\newcommand{\ctoty}[1]{[#1]}
\newcommand{\ltoty}[2]{[#1]}
\newcommand{\dltoty}[2]{[#1; #2]}

% Denotational semantics
\newcommand{\dnt}[1]{\llbracket{#1}\rrbracket}
\newcommand{\ednt}[1]{\left\llbracket{#1}\right\rrbracket}
\newcommand{\tmor}[1]{{!}_{#1}}
\newcommand{\dmor}[1]{{\Delta}_{#1}}
\newcommand{\entrymor}[3]{\ms{esem}_{#1, #3}(#2)}
\newcommand{\loopmor}[3]{\ms{lsem}_{#1, #3}(#2)}
\newcommand{\substpure}[1]{#1\;\ms{pure}}

% Comonadic lore
\newcommand{\lmor}[1]{\ms{let}(#1)}
\newcommand{\envcom}[2]{{#1}_{#2 \otimes \cdot}}
\newcommand{\rlmor}[1]{\ms{rlet}(#1)}
\newcommand{\rcase}[1]{\ms{rcase}(#1)}
\newcommand{\rfix}[1]{\ms{rfix}(#1)}
\newcommand{\rseq}[3]{#2 \gg_{#1} #3}
\newcommand{\envpil}[1]{\pi_{{#1}l}}
\newcommand{\envpir}[1]{\pi_{{#1}r}}

\newcommand{\toenv}[2]{\ms{env}_{#1}(#2)}
\newcommand{\envcop}[3]{[#2, #3]_{#1}}
\newcommand{\envinr}[1]{\iota^{#1}_{r}}
\newcommand{\envinl}[1]{\iota^{#1}_{l}}
\newcommand{\envtn}[3]{{#2} \otimes_{#1} {#3}}

% Composition
\newcommand{\invar}{\square}
\newcommand{\outlb}{\blacksquare}
\newcommand{\pckd}[1]{\langle #1 \rangle}

% Weak memory
\newcommand{\bufloc}[1]{\overline{#1}}

% Branding
\newcommand{\submonssa}{\(\lambda_{\leq\otimes}\)}
\newcommand{\subdistssa}{\(\lambda_{\ms{dist}}\)}
\newcommand{\subiterssa}{\(\lambda_{\ms{iter}}\)}
\newcommand{\isotopessa}{\(\lambda_{\ms{SSA}}\)}
\newcommand{\thsubmon}[1]{\ms{Th}_{\leq\otimes}(#1)}
\newcommand{\thsubdist}[1]{\ms{Th}_{\ms{dist}}(#1)}
\newcommand{\thsubiter}[1]{\ms{Th}_{\ms{iter}}(#1)}

% Formalization pointers
\newcommand{\formalizedas}[1]{Formalized as \texttt{#1}}

% Commutativity
\newcommand{\rightmove}{\rightharpoonup}
\newcommand{\leftmove}{\leftharpoondown}
\newcommand{\slides}{\rightleftharpoons}

% Quantities
\newcommand{\zeroq}{0}
\newcommand{\oneq}{1}
\newcommand{\delq}{1^?}
\newcommand{\cpyq}{\omega^+}
\newcommand{\topq}{\omega}

% Operators
\newcommand{\pto}{\rightharpoonup}
\newcommand{\alquant}{\ms{q}}
\newcommand{\alcount}{\sharp}
\newcommand{\aldquant}{\bar{\ms{q}}}
\newcommand{\varcount}[2]{\sharp(#1, #2)}

% Truth tables
\newcommand{\cmark}{\textcolor{green}{\ding{51}}}%
\newcommand{\xmark}{\textcolor{red}{\ding{55}}}%
% \newcommand{\cmark}{\textcolor{Green}{\ding{51}}}%
% \newcommand{\xmark}{\textcolor{BrickRed}{\ding{55}}}%


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{A Complete Refinement System for Substructural SSA}

\author{Jad Ghalayini}
\email{jeg74@cl.cam.ac.uk}
\orcid{0000-0002-6905-1303}

\author{Neel Krishnaswami}
\email{nk480@cl.cam.ac.uk}
\orcid{0000-0003-2838-5865}

\begin{abstract}
  \TODO{write the abstract}
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Type theory}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{SSA, Categorical Semantics, Elgot Structure, Effectful Category}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

\section{Introduction}

\TODO{we want to study SSA with refinement and effects; so we need+get linearity}

\section{SSA}

\TODO{recall syntax with BBA / $\phi$-nodes}

\TODO{where-blocks and dominance}

\TODO{this system is bad for metatheory: ANF substitution restrictions, lots of syntactic
categories}

\TODO{so we'll introduce an equivalent but simpler syntax (we promise it's equivalent)}

\section{Expression Language}

\subsection{Syntax and Typing Rules}

In this section, we introduce and give typing rules for the \subiterssa{} expression language, which
has grammar given in Figure~\ref{fig:subiterssa-syntax}. \subiterssa{} is, at first glance, a
standard first-order language with branching and iteration, designed to be a functional analogue of
the standard \textsc{While} language. We will begin by going over each production rule. For the rest
of this section, we assume a fixed set of \emph{base types} $\mc{X}$ and a set of
\emph{instructions} $\mc{I}$. 

\begin{figure}
  \begin{grammar}
    <\(A, B, C\)> ::= 
    \(X\)
    \;|\; \(A \otimes B\)
    \;|\; \(\mathbf{1}\)
    \;|\; \(A + B\)
    \;|\; \(\mathbf{0}\)

    <\(a, b, c\)> ::=
    \(x\)
    \;|\; \(f\;a\)
    \;|\; \(\letexpr{x}{a}{b}\)
    \;|\; \(()\)
    \;|\; \((a, b)\)
    \;|\; \(\letexpr{(x, y)}{a}{b}\)
    \alt  \(\linl{a}\)
    \;|\; \(\linr{b}\)
    \;|\; \(\caseexpr{a}{x}{b}{y}{c}\)
    \;|\; \(\labort{a}\)
    \;|\; \(\liter{a}{x}{b}\)
    
    <\(q\)> ::= \(\zeroq\) | \(\oneq\) | \(\cpyq\) | \(\delq\) | \(\topq\)

    <\(\Gamma\)> ::= \(\cdot\) \;|\; \(\Gamma, x : A\)

    <\(\mb{q}\)> ::= \(\cdot\) \;|\; \(\mb{q}, q\)
  \end{grammar}
  \caption{Syntax for \subiterssa{} types, expressions, quantities, and contexts.} \Description{}
  \label{fig:subiterssa-syntax}
\end{figure}

We will equip \subiterssa{} with a substructural type-and-effect system. To allow us to support both
destructuring let-bindings and case-statements, our grammar of types $A, B, C$ will consist of:
\begin{itemize}
  \item \emph{Base types} $X \in \mc{X}$
  \item \emph{Tensor products} of types $A \otimes B$, and a \emph{unit type} $\mb{1}$; we write
  this as a tensor product rather than a cartesian product to emphasize that $A$ or $B$ may be
  substructural
  \item \emph{Coproducts} $A + B$, and an \emph{empty type} $\mb{0}$.
\end{itemize}

Expressions $a, b, c$ can consist of
\begin{itemize}
  \item \emph{Variables} $x, y, z$
  \item \emph{Applications} $f\;a$, consisting of instructions $f \in \mc{I}$ applied to an
  expression $a$
  \item \emph{Let-bindings} $\letexpr{x}{a}{b}$ and \emph{destructuring let-bindings} $\letexpr{(x,
  y)}{a}{b}$
  \item \emph{Case-expressions} $\caseexpr{e}{x}{a}{y}{b}$, representing branching control-flow
  \item \emph{Iteration-expressions} $\liter{a}{x}{b}$ representing a variant of
  \emph{tail-controlled loop}, which:
  \begin{itemize}
    \item Evaluates an initial value $a : A$
    \item Evaluates the loop body $b : B + A$ with $x = a$; if the loop evaluates to a value of type
    $B$, we return it, otherwise, we re-evaluate the loop with $x$ having the new value of type $A$
  \end{itemize}
\end{itemize}

The primary judgement of our type system is of the form $\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}$.
This says that in context $\Gamma$ with \emph{variable quantities} $\mb{q}$, the expression $a$ has
type $A$ and \emph{effects} $\epsilon$. However, before we can define this judgment, we need to
explain what we mean by usage, and what the allowed effects are. 


\subsubsection{Variable Quantities}
Our type system needs to track how often individual variables are used  to
reason about rewrites involving substructural effects. Inspired by substructural logic, which distinguishes linear (exactly once), afficne (at most once), and relevant (at least once), we introduce a join semilattice of \emph{quantities} to model these usages. The primitive quantities are:
\begin{itemize}
  \item $\zeroq$ -- corresponding to being used zero times
  \item $\oneq$ -- corresponding to being used exactly once
  \item $\cpyq$ -- corresponding to being used multiple ($\geq 1$) times
\end{itemize}
This forms a partial order $\{\zeroq, \oneq \leq \cpyq\}$. To be able to make this into a proper
analysis, we simply complete this order into a join-semilattice by adding elements
\begin{itemize}
  \item $\zeroq \sqcup \oneq$ -- written $\delq$, corresponding to being used at most once
  \item $\zeroq \sqcup \cpyq$ -- written $\topq$, corresponding to being used any number of times
\end{itemize}
We will call the set $Q^0 = \{\zeroq, \oneq, \cpyq, \delq, \topq\}$ the \emph{extended} set of
quantities, and $Q = \{\oneq, \cpyq, \delq, \topq\}$ the set of (\emph{nonzero}) quantities. We note
in particular that $Q$ forms a lattice, with $\cpyq \sqcap \delq = 1$. We will in general define the
\emph{product} of quantities $q, q' \in Q^0$ as follows:
\begin{equation}
  q * q' = \begin{cases}
    0 & \text{if } q = 0 \text{ or } q' = 0 \\
    q \sqcap q' & \text{if } q, q' \in Q
  \end{cases}
\end{equation}
Our contexts will then simply
consist of a list $\Gamma$ of variables typed $x : A$ along with a list of quantities $q$ of equal
length $\mb{q}$, which we will write as $\Gamma^{\mb{q}}$. This may equivalently be viewed as a list
of variables $x : A^q$ each annotated with a quantity, and, in particular, we will define syntax
sugar
\begin{equation}
  \Gamma^{\mb{q}}, x : A^q = (\Gamma, x : A)^{\mb{q}, q} \qquad
  \Gamma^{\mb{q}}, x : A =  (\Gamma, x : A)^{\mb{q}, \topq}
\end{equation}
Since we will need to track the usage of variables anyways, it requires only minimal additional
complexity to add support for substructural types (which are types whose elements can \emph{only} be used a
certain number of times) in as well. In particular, assuming that every base type $X \in \mc{X}$ is
equipped with a \emph{linearity} $\alquant(X) \in Q$, we can define the linearity of a type $A$
inductively as follows:
\begin{equation}
  \alquant(A \otimes B) = \alquant(A + B) = \alquant(A) \sqcap \alquant(B) \qquad
  \alquant(\mb{1}) = \alquant(\mb{0}) = \topq
\end{equation}
We can further define the linearity of a context $\Gamma$ by induction as follows
\begin{equation}
  \alquant(\cdot) = \topq \qquad
  \alquant(\Gamma^{\mb{q}}, x : A^q) 
    = \alquant(\Gamma^{\mb{q}}) \sqcap \begin{cases}
    \alquant(A) \sqcap q & \text{if } q \neq 0 \\
    \topq & \text{if } q = 0
  \end{cases}
\end{equation}
In particular, note that the linearity of an unused variable is always unrestricted.
%
We will enforce our quantity restrictions through the means of \emph{weakening} and \emph{splitting}
judgements, which will determine how variables may be left unused or apportioned between
sub-contexts, respectively. In particular, the judgement $\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}$,
pronounced ``$\Gamma^{\mb{q}}$ weakens $\Delta^{\mb{q'}}$," is defined as follows:
\begin{gather*}
  \prftree[r]{\rle{nil}}{\cwk{\cdot}{\cdot}} \qquad 
  \prftree[r]{\rle{cons}}
    {\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}}
    {q' * \alquant(A) \leq q * \alquant(A)}
    {\cwk{\Gamma^{\mb{q}}, x : A^q}
         {\Delta^{\mb{q}'}, x : A^{q'}}} \qquad
  \prftree[r]{\rle{skip}}
    {\cwk{\Gamma^{\mb{q}}}{\Delta^{\mb{q}'}}}
    {\zeroq \leq q * \alquant(A)}
    {\cwk{\Gamma^{\mb{q}}, x : A^q}{\Delta}^{\mb{q}'}}
\end{gather*}
\emph{Affinity} is encoded in the condition $\zeroq \leq q * \alquant(A)$ in the rule \brle{split};
which ensures that only affine variables may be discarded. On the other hand, the rule \brle{cons}
states that we may replace a variable quantity $q$ with another quantity $q'$ which allows
\emph{less} usages \emph{with respect to that variable's quantity}: for example, for an affine
variable, the quantities $\cpyq$ allows \emph{less} usages than the quantity $\delq$, since only the
latter allows deletion, but copying is never possible. This clearly induces a \emph{preorder} on
contexts, with two contexts equivalent if their component variables can be used the same way.

We may then go on to define \emph{context splitting} $\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}$ as
follows:
\begin{gather*}
  \prftree[r]{\rle{nil}}
    {\qsp{\cdot}{\cdot}{\cdot}{\cdot}} \qquad
  \prftree[r]{\rle{both}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\cpyq \leq q \sqcap \alquant(A)}
    {\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, q)}{(\mb{q}_r, q)}}
    \\
  \prftree[r]{\rle{left}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, q)}{(\mb{q}_r, \zeroq)}} \qquad
  \prftree[r]{\rle{right}}
    {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
    {\qsp{\Gamma, x : A}{(\mb{q}, q)}{(\mb{q}_l, \zeroq)}{(\mb{q}_r, q)}}
\end{gather*}
The rules \brle{left} and \brle{right} allow us to use a variable, regardless of quantity, in either
the choice of subexpression, whereas the rule \brle{both} states that for a variable to be usable in
two seperate subexpressions, it must be relevant.

\subsubsection{Effects}
Our language of effects is a bounded\footnote{has a maximum element $\top$ and minimum element
$\bot$} join-semilattice $\mc{E}$. We will represent pure expressions as having the bottom effect
$\bot$, whereas expressions with effect $\top$ have ``arbitrary'' effect, and expressions with
effect $\epsilon \sqcup \epsilon'$ have both effects $\epsilon$ and $\epsilon'$.

However, since we want to rewrite effectful programs in addition to classifying them, it is not
enough to know simply what set of effects a program might have, but we also need to know how effects
interact with each other. In particular, we need to know:
\begin{enumerate}
  \item Which effects are \emph{iterable}, i.e., stable under loops. 
  % In particular, all iterable  effects must have nontermination as a \emph{subeffect}.
  \item What \emph{multiplicity} each effect has, and in particular, whether a given effect
  $\epsilon$ is \emph{duplicable}, \emph{fusable}, \emph{introducable}, or \emph{eliminable}.
  \item Which effects $\epsilon$ are \emph{left-movers} (i.e. can be moved before) or
  \emph{right-movers} (i.e. can be moved after) other effects $\eta$
\end{enumerate}

First, not all effects are stable under arbitrary iteration. For example, a pure, total computation
iterated infinitely often can now exhibit the effect of nontermination. Indeed, any total effect
(such as reading or writing from a location) repeated infinitely often can gain the nontermination
effect. To model stability, we are going to require that there is an upwards-closed subset
$\mc{E}^\infty \subseteq \mc{E}$ of \emph{iterative effects}. The intuition behinds the
upwards-closed requirement is that once nontermination is in the effect $\epsilon$, then it will
continue to be present in any supereffect.

Second, to represent multiplicity, we are going to take advantage of the fact that we have already
introduced a notion of quantitity into our type system.  However, unlike in pure linear type
systems, we are interested in refinement (a directed notion) rather than pure equations.  So, we
need to break apart a structural property like contraction into a pair of directed properties of
duplicability and fusability (which are contraction in each direction of refinement). Likewise
weakening factors into the pair of directed weakening properties of eliminability and
introducability.

Because of this, we represent multiplicity by assigning a \emph{pair} of quantities $\alquant^+(e),
\alquant^-(e) \in Q$ to each effect, such that
\begin{itemize}
  \item An effect can be eliminated if $\delq \leq \alquant^+(e)$, and introduced if $\delq \leq
  \alquant^-(e)$
  \item An effect can be duplicated if $\cpyq \leq \alquant^+(e)$, and fused if $\cpyq \leq
  \alquant^-(e)$
\end{itemize}
To be compatible with our notion of sub-effect, such a map should be \emph{antitone} and have
the property that $\alquant^p(\bot) = \topq$ for $p \in \{+, -\}$ (i.e., pure computations can
be used as often as you like).

Third, when actually rewriting programs with effects, we need to know which effectful terms can be
moved past one another. For example, reading from memory and writing I/O cannot interfere with each
other and hence can be reordered. To model this, we introduce a \emph{directed commutativity
relation} $\rightmove \subseteq \mc{E} \times \mc{E}$. This is intended to mean that if $\epsilon
\rightmove \epsilon'$, then a computation performing $\epsilon$-effects can be moved past a
computation performing $\epsilon'$-effects without introducing new behaviour. We require that $\bot
\rightmove \epsilon$ and $\epsilon \rightmove \bot$, to ensure that pure computations can be moved
freely, and we also require that the relation in antitone, to model that decreasing the number of
effects never loses rewrites. 

As notational abbreviations, we write:
\begin{itemize}
  \item $\epsilon \leftmove \eta \iff \eta \rightmove \epsilon$
  \item $\epsilon \slides \eta \iff \epsilon \rightmove \eta \land \epsilon \leftmove \eta$
  \item $\epsilon \rightmove^+ \eta \iff \epsilon \rightmove \eta$
  \item $\epsilon \rightmove^- \eta \iff \epsilon \leftmove \eta$
\end{itemize}

Putting all this together, we arrive at the following definition for an
\emph{effect system}:
\begin{definition}[Effect system]
  We define an \emph{effect system} $\mc{E}$ to be a bounded join-semilattice of effects $\mc{E}$
  equipped with:
  \begin{itemize}
  \item an upwards closed subset $\mc{E}^\infty$ of \emph{iterative effects} containing $\top$, and
  \item a pair of antitone maps $\alquant^+, \alquant^- : \mc{E} \to Q$ which map $\bot$ to $\topq$,
  \item a \emph{directed commutativity relation} $\rightmove \subseteq \mc{E} \times \mc{E}$,
  which is an antitone relation   such that, for all effects
  $\epsilon$, $\bot \rightmove \epsilon$ and $\epsilon \rightmove \bot$. 
  \end{itemize}

\end{definition}


\subsubsection{Typing rules}

We now have all the pieces we need to define a \subiterssa{}-\emph{signature}:
\begin{definition}[\subiterssa-signature]
  A \subiterssa signature $\mc{S} = (\mc{X}, \mc{I}, \mc{E})$ consists of:
  \begin{itemize}
    \item A set of \emph{base types} $X \in \mc{X}$
    \item A set of \emph{instructions} $f \in \mc{I}$
    \item An iterative effect system $\mc{E}$
  \end{itemize}
  such that we associate:
  \begin{itemize}
    \item Every base type $X$ type to a \emph{quantity} $\ms{q}(X) \in \{1, \delq, \cpyq, \topq\}$.
    \item Every instruction to a \emph{source type} $\ms{src}(f) = A$, a \emph{target type}
    $\ms{trg}(f) = B$, and an \emph{effect} $\ms{eff}(f) = e$ (where types are given by the grammar
    in Figure~\ref{fig:subiterssa-syntax}).
  \end{itemize}
\end{definition}
All the following definitions in this section will be with respect to an arbitrary
\subiterssa{}-signature $\mc{S}$. 

We can now give the typing rules for \subiterssa{} in Figure~\ref{fig:subiterssa-typing}. Our rules
are for the most part syntax directed, with one rule for each production in our grammar. In
particular,
\begin{itemize}
  \item We type variables with the \brle{var} rule, which states that a variable $x$ has type $A$ in
  the context $\Gamma^{\mb{q}}$ if $\Gamma^{\mb{q}}$ weakens to the singleton context $x: A^\oneq$,
  i.e., if $x$ has nonzero quantity and all other (unused) variables are affine. Since accessing a
  variable is a pure operation, we may assign the resulting derivation an arbitraty effect
  $\epsilon$
  \item To type a let-binding $\letexpr{x}{a}{e}$ in $\Gamma^{\mb{q}}$ with \brle{let$_1$} with
  effect $\epsilon$, we must:
  \begin{itemize}
    \item Split the context into a left-component $\mb{q}_l$ and a right-component
    $\mb{q}_r$, such that:
    \item $a$ is well-typed and has effect $\epsilon$ in the \emph{right} component
    $\Gamma^{\mb{q}_r}$; in general, we put bindings on the right to make our semantics a little bit
    easier to define. $\Gamma^{\mb{q}_l}$ plus an unrestricted parameter $x: A^\top$.
  \end{itemize}
  \item \brle{case} and \brle{let$_2$} are the same, except that \brle{let$_2$}'s body requires two
  parameters (one for each component of the tensor product), while both branches of a case-statement
  share the \emph{same} left-component $\Gamma^{\mb{q}_l}$ (since exactly one branch is executed.)
  \item \brle{unit} is well-typed and pure (and therefore can be assigned an arbitrary effect
  $\epsilon$) in any context composed solely of affine variables, i.e. satisfying
  $\cwk{\Gamma^{\mb{q}}}{\cdot}$.
  \item \brle{pair} allows us to type pairs in the obvious manner by splitting the context between
  the left and right component of the pair.
  \item Finally, the \brle{iter} rule is a little bit more complicated: we split the context into a
  component $\mb{q}_r$ for the initial value and a component $\mb{q}_l$ for the body. The initial
  value is then evaluated and passed in as an additional parameter of type $A$ to the body. We
  require that the body's context has unrestricted quantity since the loop may execute any number of
  times; while one could argue that we should only require the body's context to have quantity
  $\cpyq$ (since the loop body is guaranteed to execute at least once, as long as $a$ terminates),
  this would make our semantics more complicated, and such variables can be passed in as arguments
  to the loop body. Our final requirement is that the effect of a loop must be iterative, i.e.,
  stable under infinite repetitions.
\end{itemize}

\begin{figure}
  \begin{gather*}
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma^{\mb{q}}_{\mb{e}}}{x : A^\oneq}}
        {\hasty{\Gamma^{\mb{q}}_{\mb{e}}}{\epsilon}{x}{A}} 
      \qquad
    \prftree[r]{\rle{let$_1$}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}}}{}{\letexpr{x}{a}{b}}{B}}
      \\
    \prftree[r]{\rle{op}}{f : A \to_\epsilon B}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{f\;a}{B}}
      \qquad
    \prftree[r]{\rle{inst}}
      {f \in \mc{I}}
      {\ms{src}(f) = A}
      {\ms{trg}(f) = B}
      {\ms{eff}(f) \leq \epsilon}
      {f : A \to_\epsilon B}
      \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma^{\mb{q}}}{\cdot}}{\hasty{\Gamma^{\mb{q}}}{\epsilon}{()}{\mb{1}}} 
      \qquad
    \prftree[r]{\rle{pair}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{(a, b)}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{}{a}{A \otimes B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\letexpr{(x, y)}{a}{c}}{C}}
      \\
    \prftree[r]{\rle{inl}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\linl{a}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\linr{b}}{A + B}} \qquad    
    \prftree[r]{\rle{abort}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\labort{a}}{C}}
      \\
    \prftree[r]{\rle{case}}{\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{e}{A + B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{b}{C}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\caseexpr{e}{x}{a}{y}{b}}{C}} \\
    \prftree[r]{\rle{iter}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \topq}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{\liter{a}{x}{b}}{B}}
  \end{gather*}
  \caption{Typing rules for \subiterssa{}}
  \Description{}
  \label{fig:subiterssa-typing}
\end{figure}

\subsection{Syntactic Metatheory}

As a basic sanity check for our calculus, we can verify that it satisfies \emph{weakening}, stated
as follows:
\begin{lemma}[name=Weakening, restate=synmonwk]
  The following rule is admissible:
  \begin{equation*}
    \prftree[r]{\rle{wk}}
      {\cwk{\Gamma'^{\mb{q}'}}{\Gamma^{\mb{q}}}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\hasty{\Gamma'^{\mb{q}'}}{\epsilon}{a}{A}}
  \end{equation*}
\end{lemma}

We now attempt to define what substitution looks like in the substructural, effectful context. We
begin by defining a typing judgement $\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma}{\Delta^{\mb{q}'}}$
for substitutions (viewed as a duplicate-fre list of mappings $x \mapsto a$ from variables to
terms), with rules in Figure~\ref{fig:subiterssa-subst}. This may be read as ``$\sigma$ takes the
context $\Gamma^{\mb{q}}$ to the context $\Delta^{\mb{q}'}$ with effect $\epsilon$.'' Our rules may
be interpreted as follows:
\begin{itemize}
  \item \brle{nil} simply states that the empty substitution $\cdot$ takes any affine context
  $\Gamma^{\mb{q}}$ to the empty context $\cdot$; this is equivalent to the observation that any
  well-typed term in the empty context is also well-typed in any affine context. We allow an
  arbitrary effect $\epsilon$ here, since the empty substitution is always pure.
  \item Our \brle{zero} rule is a bit unusual, but required as a consequence of the fact that we
  allow unused variables to appear in our contexts. It states that if a variable $x : A^0$ is
  unused, then we can map it to an arbitrary (potentially even ill-typed) term $a$; this makes sense
  because, since $x$ will never appear in well-typed terms, $a$ will never appear in their
  substitutions, and therefore does not need to be restricted. our contexts. We leave the effect of
  $\sigma$ unchanged.
  \item \brle{cons}: to type a substitution $\sigma, x \mapsto a$ taking  $\Gamma^{\mb{q}}$ to
  $\Delta^{\mb{q}'}, x: A^q$ with effect $\epsilon$, we split the input context into a context
  $\Gamma^{\mb{q}_l}$, used to type $\sigma$ with effect $\epsilon_l \leq \epsilon$, and
  $\Gamma^{\mb{q}_r}$, used to type $a$ with effect $\epsilon_r \leq \epsilon$. We additionally
  require that $\Gamma^{\mb{q}_r}$ can be used with quantity $q$; i.e., is relevant if $q$ is
  relevant and affine if $q$ is affine. Finally, we require that the effect of $\sigma$
  ($\epsilon_l$) and the effect of $a$ ($\epsilon_r$) commute.
\end{itemize}

\begin{figure}
  \begin{gather*}
    \prftree[r]{\rle{nil}}{\cwk{\Gamma^{\mb{q}}}{\cdot}}
                              {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\cdot}{\cdot}} \qquad 
    \prftree[r]{\rle{zero}}
      {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma}{\Delta}}
      {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma, x \mapsto a}{\Delta^{\mb{q}'}, x : A^0}}
    \\
    \prftree[r]{\rle{cons}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\issubst{\Gamma^{\mb{q_l}}}{\epsilon_l}{\sigma}{\Delta^{\mb{q}}}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon_r}{a}{A}}
      {q \leq \alquant(\Gamma^{\mb{q}_r})}
      {\epsilon_l \slides \epsilon_r}
      {\epsilon_l, \epsilon_r \leq \epsilon}
      {\issubst{\Gamma^{\mb{q}}}{\epsilon}{\sigma, x \mapsto a}
      {\Delta^{\mb{q}'}, x : A^q}}
  \end{gather*}
  \caption{Substitution rules for \subiterssa{}}
  \Description{}
  \label{fig:subiterssa-subst}
\end{figure}%
We denote capture-avoiding substitution of $a$ by $\sigma$ as $[\sigma]a$ We can now state the
substitution lemma for our calculus as follows:
\begin{lemma}[name=Substitution, restate=synmonsubst]
  The following rule is admissible:
  \begin{equation*}
    \prftree[r]{\rle{subst}}
      {\issubst{\Gamma'^{\mb{q}'}}{\epsilon}{\sigma}{\Gamma^{\mb{q}}}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\hasty{\Gamma'^{\mb{q}'}}{\epsilon}{[\sigma]a}{A}}
  \end{equation*}
\end{lemma}

\subsection{Refinement Theory}


Now that we have some basic metatheoretic results, we can attempt to develop our refinement
relation. We write our refinement judgement as
\begin{equation*}
  \tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}
\end{equation*}
which we will read as ``$a$ is refined by $b$ in the context $\Gamma^{\mb{q}}$ modulo rewrites
$\mc{R}$.'' Here $\mc{R}$ is a set of rewrites of the form $\tmle{\Gamma^{\mb{q}}}{}{a}{b}{A}$; we
will generally assume that $\mc{R}$ is closed under pure substitution, i.e. that the following rule
is admissible
\begin{equation*}
  \prftree[r]{}
    {\issubst{\Gamma^{\mb{q}}}{\bot}{\sigma}{\Delta^{\mb{q}'}}}
    {(\tmle{\Delta^{\mb{q}'}}{}{a}{b}{A}) \in \mc{R}}
    {(\tmle{\Gamma^{\mb{q}}}{}{[\sigma]a}{[\sigma]b}{A}) \in \mc{R}} 
\end{equation*}
Our goal is to construct a refinement relation $\tref$ at every context
satisfying the following properties: 
\begin{enumerate}
  \item $\tref$ contains $\mc{R}$
  \item $\tref$ is a \emph{congruence} with respect to our term formers, and in particular is a
  partial order
  \item $\tref$ abstracts away irrelevant syntactic details, e.g. associativity of let-bindings.
  \label{item:abstracts-syntax}
  \item $\tref$ expresses the \emph{computational} properties of our language constructs, e.g.
  reduction of let-bindings and unrolling of fixpoints.
  \label{item:does-computation}
\end{enumerate}
The rules in Figure~\ref{fig:congruence-refinement} guarantee the first two properties. In
particular, this also means that equivalence of terms, defined as follows, is also a congruence:
\begin{equation}
  \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}
  \iff \tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A} 
  \land \tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{a}{A}
\end{equation}
To satisfy property \ref{item:abstracts-syntax}, we introduce a set of \emph{binding rules} in
Figure~\ref{fig:binding-rules}, which are given as a set of equivalences governing the interaction
of let-bindings and our other language constructs. We don't provide rules for every construct;
for example, rules for pairs are notably omitted, since these can be derived from $\beta$-reduction
and the other rules.

\TODO{one issue is that our congruence rules are not \emph{continuous} w.r.t. to loops}

\TODO{there is no finite axiomatization of the theory of loops due to Milner trauma, remove this
if I can't find a citation}

\TODO{so we need an axiom schema; an infinite family of commutativity axioms for loops}

\TODO{these are the \emph{uniformity} rules; since our rewrite rules are \emph{directed}, our
uniformity rules will be as well, and we need one for both directions, i.e., }

Given
\begin{gather*}
  {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}} \qquad
  {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}} \qquad
  \alquant(\Gamma^{\mb{q}_l}) = \top \qquad
  \einf{\epsilon}
  \\
  \qquad {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
  \qquad {\hasty{\Gamma^{\mb{q}_m}, x : A}{\eta}{s}{S}}
  \qquad {\hasty{\Gamma^{\mb{q}_l}, y : S}{\epsilon}{b}{B + A}}
  \qquad {\hasty{\Gamma^{\mb{q}_c}, x : A}{\epsilon}{b'}{B + A}}
\end{gather*}

\TODO{we have}

\begin{gather*}
  \prftree[r]{\rle{unif$^p$}}
    {\eta \rightmove \epsilon}
    {\tmlep{\Gamma^{\mb{q}_c}, x : A}{\mc{R}}
      {\letexpr{y}{s}{b}}
      {\caseexpr{b'}{x}{\linl{x}}{x}{\linr{s}}}{B + S}{p}}
    {
      \tmlep{\Gamma^{\mb{q}}}
        {\mc{R}}
        {\letexpr{x}{a}{\liter{s}{y}{b}}}
        {\liter{a}{x}{b'}}
        {B}
        {p}
    } \\
\end{gather*}

\TODO{note in particular that this means commuting with $\epsilon$ includes commuting with
infinitely many $\epsilon$ if $\epsilon$ is iterative}

\TODO{where, for each direction $p \in \{+, -\}$, we will write}

\begin{equation*}
  \tmlep{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}{+}
  \iff \tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}
  \qquad
  \tmlep{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}{-}
  \iff \tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{a}{A}
\end{equation*}

\begin{figure}
  \begin{gather*}
    \prftree[r]{\rle{base}}
      {(\tmle{\Gamma^{\mb{q}}}{}{a}{b}{A}) \in \mc{R}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}} \qquad
    \prftree[r]{\rle{refl}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a}{A}}
    \qquad
    \prftree[r]{\rle{trans}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{c}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{c}{A}}
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{var}}
      {\cwk{\Gamma^{\mb{q}}}{x : A^q_\epsilon}}
      {1 \leq q}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{x}{x}{A}} \qquad
    \prftree[r]{\rle{op}}
      {f : A \to_\epsilon B}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{f\;a}{f\;a'}{B}} \\
    \prftree[r]{\rle{let$_1$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{b}{b'}{B}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{\letexpr{x}{a'}{b'}}{B}} \\
    \prftree[r]{\rle{unit}}
      {\cwk{\Gamma^{\mb{q}}}{\cdot}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{()}{()}{\mb{1}}} \qquad
    \prftree[r]{\rle{pair}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_l}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{b}{b'}{B}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{(a, b)}{(a', b')}{A \otimes B}} \\
    \prftree[r]{\rle{let$_2$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{a}{a'}{A \otimes B}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A, y : B}{\mc{R}}{c}{c'}{C}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{(x, y)}{a}{c}}{\letexpr{(x, y)}{a'}{c'}}{C}}
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{inl}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\linl{a}}{\linl{a'}}{A + B}} \qquad
    \prftree[r]{\rle{inr}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{b}{b'}{B}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\linr{b}}{\linr{b'}}{A + B}} \\
    \prftree[r]{\rle{case}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{e'}{A + B}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{a'}{C}}
      {\tmle{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{b'}{C}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{e}{x}{a}{y}{b}}{\caseexpr{e'}{x}{a'}{y}{b'}}{C}} \\
    \prftree[r]{\rle{abort}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{a}{a'}{\mb{0}}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\labort{a}}{\labort{a'}}{C}}
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{iter}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\tmle{\Gamma^{\mb{q}_r}}{\mc{R}}{a}{a'}{A}}
      {\tmle{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{b}{b'}{B + A}}
      {\tmle{\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{b}}{\liter{a'}{x}{b'}}{B}}
  \end{gather*}
  \caption{\subiterssa{} congruence rules}
  \Description{}
  \label{fig:congruence-refinement}
\end{figure}


\begin{figure}
  \begin{gather*}
    \prftree[r]{\rle{let-op}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {f : A \to_\epsilon B}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{c}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{y}{f\;a}{c}}
        {\letexpr{x}{a}{\letexpr{y}{f\;x}{c}}}
        {C}}
      \\
    \prftree[r]{\rle{let-let$_1$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}}
      {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_m}, x : A}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{c}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{y}{(\letexpr{x}{a}{b})}{c}}
          {\letexpr{x}{a}{\letexpr{y}{b}{c}}}
          {C}
      }
      \\
    \prftree[r]{\rle{let-let$_2$}}
      {
        \prfStackPremises
        {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}}
        {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}}
      }
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
      {\hasty{\Gamma^{\mb{q}_m}, x : A, y : B}{\epsilon}{c}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, z : C}{\epsilon}{d}{D}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{z}{(\letexpr{(x, y)}{a}{c})}{d}}
          {\letexpr{(x, y)}{a}{\letexpr{z}{c}{d}}}
          {D}
      }
      \\
    \prftree[r]{\rle{let-case}}
      {
        \prfStackPremises
        {\qsp{\Gamma}{\mb{q}}{\mb{q}_c}{\mb{q}_r}}
        {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_l}{\mb{q}_m}}
      }
      {\hasty{\Gamma^{\mb{q}_m}}{\mc{R}}{e}{A + B}}
      {
        \prfStackPremises
        {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
        {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      }
      {
        {\hasty{\Gamma^{\mb{q}_r}, z : C}{\mc{R}}{d}{D}}
      }
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{z}{\caseexpr{e}{x}{a}{y}{b}}{d}}
        {\caseexpr{e}{x}{\letexpr{z}{a}{d}}{y}{\letexpr{z}{b}{d}}}
        {D}
      } 
      \\
    \prftree[r]{\rle{let-abort}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{\mc{R}}{a}{\mb{0}}}
      {\hasty{\Gamma^{\mb{q}_r}, x : A}{\mc{R}}{b}{B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{x}{\labort{a}}{b}}
        {\letexpr{y}{a}{\letexpr{x}{\labort{y}}{b}}}
        {B}
      } 
      \\
    \prftree[r]{\rle{let-iter}}
      {
      \prfStackPremises
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_c}}
      {\qsp{\Gamma}{\mb{q}_c}{\mb{q}_m}{\mb{q}_r}}
      }
      {
      \prfStackPremises
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\alquant(\Gamma^{\mb{q}_m}) = \top}
      }
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_m}, x : A}{\epsilon}{b}{B + A}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\epsilon}{c}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\letexpr{y}{\liter{a}{x}{b}}{c}}
        {\liter{a'}{x}{\caseexpr{b}{y}{c}{z}{\linr{z}}}}
        {C}
      }
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{let$_2$-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A \otimes B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A, y : B}{\epsilon}{c}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{(x, y)}{a}{c}}
          {\letexpr{z}{a}{\letexpr{(x, y)}{z}{c}}}
          {C}
      } \\
    \prftree[r]{\rle{case-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{A + B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{e}{x}{a}{y}{b}}
        {\letexpr{z}{e}{\caseexpr{z}{x}{a}{y}{b}}}
        {C}
      } \\
    \prftree[r]{\rle{iter-bind}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{b}}{\letexpr{y}{a}{\liter{y}{x}{b}}}{B}}
  \end{gather*}
  \caption{Binding rules for \subiterssa{}}
  \Description{}
  \label{fig:binding-rules}
\end{figure}

% \begin{gather*}
%   \prftree[r]{\rle{refl}}
%     {\hasty{\Gamma^{\mb{q}}}{\mc{R}}{\epsilon}{a}{A}}
%     {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{a}{A}} \qquad
%   \prftree[r]{\rle{trans}}
%     {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}}
%     {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{b}{c}{A}}
%     {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{c}{A}}\qquad
%   \prftree[r]{\rle{symm}}
%     {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{a}{b}{A}}
%     {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{b}{a}{A}}
% \end{gather*}

\TODO{now we want some basic equations which always hold}

\TODO{we start with re-associating data flow:}


\begin{figure}
  \begin{gather*}
    \prftree[r]{\rle{term}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{\mb{1}}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{()}}{a}{\mb{1}}} \\
    \prftree[r]{\rle{init}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{\mb{0}}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b'}{B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{\labort{a}}{b}}{\letexpr{x}{\labort{a}}{b'}}{B}}
      \\
    \prftree[r]{\rle{let$_2$-$\eta$}}
      {\hasty{\Gamma^{\mb{q}}}{\epsilon}{a}{A \otimes B}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{(x, y)}{a}{(x, y)}}{a}{A \otimes B}
      }
    \\
    \prftree[r]{\rle{let$_2$-$\beta$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\qsp{\Gamma}{\mb{q}_l}{\mb{q}_a}{\mb{q}_b}}
      {\hasty{\Gamma^{\mb{q}_a}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_b}}{\epsilon}{b}{B}}
      {\hasty{\Gamma^{\mb{q}_r}, x : A, y : B}{\epsilon}{c}{C}}
      {
        \tmeq{\Gamma^{\mb{q}}}{\mc{R}}
          {\letexpr{(x, y)}{(a, b)}{c}}
          {\letexpr{x}{a}{\letexpr{y}{b}{c}}}{C}
      } \\
    \prftree[r]{\rle{case-$\beta_l$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{\linl{e}}{x}{a}{y}{b}}
        {\letexpr{x}{e}{a}}
        {C}
      } \\
    \prftree[r]{\rle{case-$\beta_r$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_r}}{\mc{R}}{e}{B}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\mc{R}}{a}{C}}
      {\hasty{\Gamma^{\mb{q}_l}, y : B}{\mc{R}}{b}{C}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{\linr{e}}{x}{a}{y}{b}}
        {\letexpr{y}{e}{b}}
        {C}
      } \\
    \prftree[r]{\rle{case-$\eta$}}
      {\hasty{\Gamma^{\mb{q}}}{\mc{R}}{e}{A + B}}
      {\tmeq{\Gamma^{\mb{q}}}{\mc{R}}
        {\caseexpr{e}{x}{\linl{x}}{y}{\linr{y}}}
        {e}
        {A + B}
      } \\
    \prftree[r]{\rle{iter-$\beta$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, x : A}{\epsilon}{b}{B + A}}
      {\tmeq
        {\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{b}}
        {\letexpr{x}{a}{\caseexpr{b}{y}{y}{z}{\liter{z}{x}{b}}}}{B}}
    \\
    \prftree[r]{\rle{codiag}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\alquant(\Gamma^{\mb{q}_l}) = \top}
      {\einf{\epsilon}}
      {\hasty{\Gamma^{\mb{q}_r}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_l}, y : A}{\epsilon}{b}{(B + A) + A}}
      {\tmeq
        {\Gamma^{\mb{q}}}{\mc{R}}{\liter{a}{x}{\liter{x}{y}{b}}}
        {\liter{a}{y}{\caseexpr{b}{x}{x}{y}{\linr{y}}}}{B}}
  \end{gather*}
  \begin{gather*}
    \prftree[r]{\rle{let$_1$-$\beta^p$}}
      {\qsp{\Gamma}{\mb{q}}{\mb{q}_l}{\mb{q}_r}}
      {\hasty{\Gamma^{\mb{q}_l}}{\epsilon}{a}{A}}
      {\hasty{\Gamma^{\mb{q}_r}, x : A^q}{\eta}{b}{B}}
      {\epsilon \rightmove^p \eta}
      {q \leq \alquant(\Gamma^{\mb{q}_r}) \sqcap \alquant^p(\epsilon)}
      {
        \tmlep{\Gamma^{\mb{q}}}{\mc{R}}{\letexpr{x}{a}{b}}{[x/a]b}{B}{p}
      }
  \end{gather*}
  \caption{Reduction rules for \subiterssa{}}
  \Description{}
  \label{fig:reduction-rules}
\end{figure}


\TODO{refinement theory}

\section{Semantics}

\TODO{denotational structure}

\TODO{semantics}

\TODO{soundness}

\TODO{completeness}

\section{SSA Typing and Semantics}

\TODO{typing rules go brr}

\TODO{denotational semantics}

\TODO{by completeness, $\subseteq$ expressions}

\TODO{by translation, expressions $\subseteq$}

\section{Concrete Models}

\TODO{UB and printing}

\TODO{separation logic}

\TODO{Release-Acquire Weak Memory}

\subsection*{Acknowledgements}

This work was supported in part by a European Research Council (ERC) Consolidator Grant for the
project ``TypeFoundry'', funded under the European Union's Horizon 2020 Framework Programme (grant
agreement no. 101002277).

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\clearpage 

\appendix

\end{document}
\endinput
